
MFC PictureControl控件上自适应显示图片，分图片失真或者图片不失真两种





图片不失真，但是没有铺满整个图片控件区域：


问题描述：给定两个非空的链表，表示两个非负整数。 数字以相反的顺序存储，每个节点包含一个数字。 添加两个数字并将其作为链表返回。
测试代码：

使用VTK生成分布在球内部或者表面的三维点云数据，可以设置球的中心，半径以及生成的三维点的个数并选择可以设置在球内部生成或者是球表面生成。

问题描述:将一个string型的字符转成int型的数字，需要处理字符串输入的各种情况，如字符串前面的空格，+号，-号等符号。
     测试代码：

在原先的博客VTK读取一个TXT文档中的三维点坐标绘制三维点云基础上，有小伙伴询问是否可以以点云中每一个三维点的坐标为中心绘制一个小的球体，用于标识特征点，这种就让我想到了化学里面的分子结构，所以就在原有博客的基础上进行了改写，实现了点云不是以点的方式而是以小球体形式显示出来，实现了大量球体的同时绘制。
不多说直接贴代码：

整体图：




局部的线框显示细节图：




局部表面显示细节图：


LeetCode第一题：
问题描述：给定一个整形的数组，在给定一个特定的整数值，要求返回这个整形数组中两个元素的和等于给定的整数的元素索引。
STL容器vector是新手入门STL最常用也是最好用的容器类，其不像array需要固定大小，而是可以动态的在容器尾部或者是中间插入元素，相当的好用，但是我们往往会在一个程序中向vector中压入了很多的元素，在使用完vector中的元素之后，只是会用clear去清理vector中的元素，有些小伙伴认为清空容器就等于释放了内存，其实真正的是这样的吗？我们不妨来做一个测试。
首先我们声明一个double型的容器，往里面压入了10000000个元素，然后用clear方法，看是否能真正的释放掉vector所占的内存，这里用SDK中的 GetProcessMemoryInfo方法来获取当前进程的所占用的内存。
代码如下：

程序运行结果：




我们可以看到使用clear方法虽然清空了vector中的元素，但是并没有释放掉vector所占用的内存，高效的管理内存是程序设计所要求的，C++ 11有了一个全新的shrink_to_fit()方法，该方法与clear()搭配使用，将vector所占用大小缩小到合适的范围，以下进行测试
代码如下：






我们可以看到，使用shrink_to_fit方法可以快速的释放掉vector所占用的内存。
先说说题外话，OpenGL是一个跨平台优秀的三维可视化库，而在Windows中内部封装的OpenGL还是1.1版本，不吐槽，维护自身Direct3D的发展也是情有可原。如果你是Win32系统，编译环境也是Win32的话，对OpenGL只是练习，那么就用简单的GLUT来配置OpenGL环境就好了，但是如果你想用X64(64位)环境来编译的话，这个GLUT会编译不成功，因为它不提供64位下的使用环境，而且太老掉牙了，版本已经不更新了，那么这个时候你就需要freeglut这个包(国外推荐使用freeglut，摒弃glut),这个包提供了32位(x86)和64(x64)两种编译环境下可用的静态链接库和动态链接库。关于64位环境编译的程序与32环境编译的程序之间的区别就是32位程序在系统中最多能申请到2G内存（2的32次方字节），而64位程序在系统中最多能申请到（2的64次方字节）的内存，64位程序理论上可以使用当前PC机上所装载的全部的内存，极大的提高了程序的性能。下面介绍了Glut和FreeGlut的详细配置教程，以便在32位编译环境和64位编译环境都得心应手的使用OpenGL。
*我的VS2010的安装位置：D:\Program Files (x86)\Microsoft Visual Studio 10.0
1.关于Glut的配置
1.1. 下载GLUT。Windows环境下的GLUT下载地址：
http://www.opengl.org/resources/libraries/glut/glutdlls37beta.zip



1.2
1.3 
1.4 
1.5 

2.Freeglut的配置




我使用的环境具体是Win764位+VS2010+Freeglut2.8.1,而Freeglut2.8.1这个版本支持VS2010,可使用最高的版本3.0，同样支持各种VS版本。


2.1 Freeglut的下载
Freeglut2.8.1:http://download.csdn.net/detail/hw140701/9830604
Freeglut其他版本的下载地址：
Freeglut3.0版本：
http://www.transmissionzero.co.uk/software/freeglut-devel/

http://download.csdn.net/detail/hw140701/9830606



2.2 生成VS2010 64位编译环境下下可用的Freeglut的包含头文件，静态链接库lib,动态链接库dll。
解压缩包，打开解压后的压缩文件夹，里面会有一个VisualStduio的文件夹，如下


    打开VisualStudio文件夹，里面会有VS2008，VS2010，VS2012三个版本的


    选择VS2010，打开项目文件freeglut.sln。


    选择Release版本，x64平台编译，右键解决方案，点击全部生成


然后你会在解压的文件夹下发现两个新的文件夹inclue和lib文件夹




include文件夹下会有GL文件夹，里面包含了freeglut所需用到的头文件，freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h,注意这里的glut.h与Glut包的glut.h文件不相同。
lib文件夹下会有一个x64文件夹，里面包含了freeglut.lib和freeglut.dll文件。
2.3 具体配置
 Freeglut配置本质上与Glut的配置原理相同，不过，我们这里配置的是64位的freeglut，稍微有一些不同。这里也简单介绍一下freeglut32位的配置，如果你要生成freeglut32可用的包含文件，静态链接库以及动态链接库，请参见上节中64的生成方法，不要需要将编译平台改为Win32，此节不再赘述。
1.将\freeglut-2.8.1\freeglut-2.8.1\include\GL文件夹下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2.将freeglut.lib复制到D:\ProgramFiles (x86)\Microsoft Visual Studio 10.0\VC\lib下。
    3.将freeglut.dll复制到C:\Windows\System32下
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\SysWOW64下。
    1.将\freeglut-2.8.1\freeglut-2.8.1\include\GL文件夹下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2.将freeglut.lib复制到D:\ProgramFiles (x86)\Microsoft Visual Studio 10.0\VC\lib\amd64下，注意这里是放64位静态链接库的地方。
    3.将freeglut.dll复制到C:\Windows\SysWOW64下
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\ System32下。
 
最后在使用的时候只需添加#include<GL/freeglut.h>就可以了。
2.4 Freeglut3.0的配置
    类似于Freeglut2.8.1的配置
下载网址就是
http://www.transmissionzero.co.uk/software/freeglut-devel/
选择freeglut3.0.0 MSVC Package




解压缩文件，有include,bin,lib三个文件夹
2.4.1 Freeglut3.0 32位的配置
    1.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\include\GL下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\lib下的
freeglut.lib复制到D:\Program Files (x86)\Microsoft Visual Studio10.0\VC\lib。
    3.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\bin下的
freeglut.dll复制到C:\Windows\System32下。
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\SysWOW64下。
 
2.4.2 Freeglut3.0 64位配置
    1.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\include\GL下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2. \freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\lib\x64下的
freeglut.lib复制到D:\Program Files (x86)\Microsoft Visual Studio10.0\VC\lib\amd64下。
    3. \freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\bin\x64下的
freeglut.dll复制到C:\Windows\ SysWOW64下
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\ System32下。




3.Glew的配置
3.1 Glew的下载
http://www.cnblogs.com/Akunwjy/p/Freeglut.html













VTK生成指定圆心以及指定半径的三维球，并将其导出为obj三维模型格式



Meshlab中载入qiu.obj




可在meshlab中将其转换为其他的三维数据格式或者提取球体表面的三维点云。
    冠脉三维重建就是从两幅不同角度拍摄的冠脉医学图片根据相机参数(角度)重建出原有的三维冠脉形态。
    具体文献可以参考：
      1.黄家祥. 冠状动脉树三维骨架重建方法的研究[D]. 天津大学, 2003.
      2.王国铸. 单臂冠脉造影三维重建与定量分析[D]. 华中科技大学, 2012.
      3.郝培远. 冠脉造影三维重建定量分析(QCA)及最佳投照角度的研究[D]. 南方医科大学, 2011.等文献





这里以黄家祥这篇文章的数据作为例子，具体的冠脉三维重建步骤可见这篇文章黄家祥. 冠状动脉树三维骨架重建方法的研究[D]. 天津大学, 2003。
以下为其中的一个实验所给出的数据，两幅不同角度的图片为。




         图A                               图B




图A和图B的相机参数分别为RAO 0，CAUD35和LAO 80，CRAN15。

图A和图B的相机参数分别为RAO 0，CAUD35和LAO 80，CRAN15。




















有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。

有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。

有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。






    匹配的结果如下：
匹配的结果如下：
















上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。

上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。

上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。












以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）

以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）

以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）

以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）












总体上来看，重建效果与论文中最后给出的结果类似，VTK封装了OpenGL底层的绘图命令，所以在光照与材质方面不需要我们去过多的设置就会有逼真的三维显示效果。
总体上来看，重建效果与论文中最后给出的结果类似，VTK封装了OpenGL底层的绘图命令，所以在光照与材质方面不需要我们去过多的设置就会有逼真的三维显示效果。




一个基于指针和重载操作符的数组类设计Array,可以进行数组范围检查，与平常看到的类而言，这个类的编写让人感觉逻辑十分清晰，以及更加可以理解面向对象程序设计理念。
Arry.h




1.显示一个地球各大洲板块的轮廓线

2. 地图指北针图例



原文地址：Graphics Software  http://www.dgp.toronto.edu/~rms/links.htmlGraphics Software
贴出来贴出来贴出来，防止自己忘掉。。。。

Shape Modeling
Texturing
突发奇想，想写一个轰炸自己QQ好友的聊天轰炸机，哈哈哈，看了半天自己就写了一个Low的聊天轰炸机，纯粹依靠剪切板往聊天窗口复制文字，然后模拟回车按钮完成发送，写了一个简单的MFC对话框Demo，大牛自动跳出，无需再看。
主要代码如下：



1.单独拉出你想轰炸的QQ好友的聊天窗口，不要合在一起；
2.设置你想轰炸的QQ好友的昵称，就是你前面拉出来的单独的会话窗口好友的昵称；
3.选择你的BOOM.txt文件，里面是你想轰炸别人的话；
4.设置轰炸的次数。
截图如下：






源码链接：源码链接，Debug和Release版本，里面自带了我自己写的BOOM.txt




主要用到OpenCV自带的CascadeClassifier这个类下的detectMultiScale函数，其检测效果并不是很好
    

（1）静态图片上的人脸检测





可以看出，有些人脸没有检测出来，或者是检测出来有位置错误。
（2）摄像头人脸检测

问题描述：判断一个数是不是回文数。
回文数：就是从左往右念和从右往左念都是一样的，对称的一个数，如121,789987等。
注意：负数不是回文数，如-121。
解题思路一：如果一个数倒序输出后还等于原始的值，那么该数为回文数。
解题思路2：如果一个数最左边的数等于最右边的数，然后再去除这两个数，然后再判断最左边的数依然等于最右边的数，直到最后一个数，那么该数为回文数。


在leetcode里面提交的结果是第一种方法貌似比第二种要快。
题目描述：反转整数输出，注意的是输入被假定为一个32位有符号整数。当反整数溢出时，函数应返回0。
  今年的华为的实习生招聘笔试的第一个题与这个有点类似，不过华为的是输入两个整数，反转，然后输出两个整数反转后两个数的和。
  测试代码：

最近有小伙伴在问，我想显示一个求得的三维点云中的每一个点的法向量的指向，怎么获得这种逼真的三维显示效果呢？当然是OpenGL啦，也是我自己用的比较习惯，所以就花了十几分钟帮助上面提问的小伙伴解决问题，然后也提供给大家一个查看三维点云法向量的工具，稍后我会在我的ＣＳＤＮ的下载频道上传该软件的Ｒｅｌｅａｓｅ版本供大家使用，主要的显示效果是三维点云中的每一个点使用实心球体表示，法向量用一个方向箭头和圆锥体表示，类似于坐标轴的指向。主要用到三个函数，Render3DCylinder（在任意两个三维点间画圆柱体），Render3DSphere（以任意三维点为中心画球体），Render3DCone（在任意两个三维点之间画圆锥体）。
其三个函数的主要代码如下：






整个程序的源码由于项目的关系不能给出，只能给出发布版本，不过主要的核心的功能是利用上述的三个函数实现的。相应的程序的Realease版本的下载地址：[免费]OpenGL+MFC显示三维点云中每一个点的法向量，Release版本-CSDN下载  http://download.csdn.net/download/hw140701/9970732http://download.csdn.net/download/hw140701/9970732



自己封装的三维向量类Vector.h,包含一些常见的三维向量类的操作符重载和一些基本运算，可以直接复制粘贴作为头文件包含在项目文件中。

Win32编译环境下，用ADO数据库连接Access数据库一般都不会报错，但是最近由于项目上的需要，程序需要编译成64位以便申请到更多的使用内存空间，当把编译方式从Win32改为x64的时候，突然出现了数据库连接出现未知错误，这时候就猜到了应该是编译环境的改变导致了数据库连接出错，在参考了其他大神的解决方案之后，终于解决了这个问题,我的环境为Win7
 64+MFC(VS2010)+ADO+Access2007。
    参考链接如下：
    http://blog.csdn.net/sundacheng1989/article/details/17925431
    http://www.cnblogs.com/bluedoctor/p/3925871.html
    http://blog.csdn.net/kirawoo/article/details/39032387
    http://blog.csdn.net/u010891996/article/details/12522911


解决方法：
步骤1：去官网下载AccessDatabaseEngine_64.exe,下载链接
https://www.microsoft.com/zh-cn/download/details.aspx?id=13255
或者直接去我的下载频道进行下载
http://download.csdn.net/detail/hw140701/9830665





步骤2:这一个步骤是强制安装刚刚下载的AccessDatabaseEngine_64.exe，如果不强制安装的话，它会要求你卸载你所安装的全部的Office软件，那多麻烦！！！，所以选择忽略提醒，强制安装，
AccessDatabaseEngine_64.exe，如果不强制安装的话，它会要求你卸载你所安装的全部的Office软件，那多麻烦！！！，所以选择忽略提醒，强制安装，
打开cmd.exe,在命令行输入“你的AccessDatabaseEngine_64.exe的存放路径” /passive，比如我的就是"F:\软件\我下载的\Windows数据库编程\AccessDatabaseEngine_64.exe"
 /passive强制安装，输完这个命令就等待安装完成。
打开cmd.exe,在命令行输入“你的AccessDatabaseEngine_64.exe的存放路径” /passive，比如我的就是"F:\软件\我下载的\Windows数据库编程\AccessDatabaseEngine_64.exe"
 /passive强制安装，输完这个命令就等待安装完成。
AccessDatabaseEngine_64.exe的存放路径
AccessDatabaseEngine_64.exe
步骤3：在安装完上述引擎之后，你需要修改一下你的代码，在win32编译环境下我们的数据库的链接字符串是
步骤3：在安装完上述引擎之后，你需要修改一下你的代码，在win32编译环境下我们的数据库的链接字符串是
m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%s",databaseName);

如果你需要在x64的编译环境环境下连接Access数据库你需要修改为
如果你需要在x64的编译环境环境下连接Access数据库你需要修改为
m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

为了更好的适配不同的编译环境，我将我的代码修改为
为了更好的适配不同的编译环境，我将我的代码修改为


m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);
当是32位程序的时候就为
当是32位程序的时候就为
当是32位程序的时候就为
m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);








然后重启一下PC，应该就可以编译成功了。
然后重启一下PC，应该就可以编译成功了。
然后重启一下PC，应该就可以编译成功了。
然后重启一下PC，应该就可以编译成功了。




Meshlab是一个强大的三维模型处理的软件，在三维点云的处理方面也十分强大，不仅仅可以用三维点云重构出三维模型，还可以计算出三维点云每个点的法向量，这在逆向工程和基于三维点云的隐式曲面重建中非常有用。
   我的Meshlab的版本是3.3，可以在网上自行下载破解版。
1.Meshlab读取三维点云
第一步：打开Meshlab软件
第二步：点击File菜单下的ImportMesh导入txt文档，需要选择你的txt文档中XYZ坐标之间的分隔符，导入成功后会显示你的三维点云数据
2.三维点云重建
点击下图图标，弹出右侧图层侧边栏
然后点击Fiter菜单下Normals，Curtavures and Oreientation下的Smooths normals on a point set计算三维点云的法向量，如下图
然后设置计算点云法向量的参数，默认就好，如有需要可以自行设置，点击Apply等计算完成然后点击Close关闭对话框
计算完点击法向量之后，点击Filter菜单下Remeshing Simplication and Reconstruction下的Surface Reconstruction：Ball Pivoting进行三维点云重建
然后设置三维点云重建参数，默认就好，也可以自行设置，点击Apply等重建完成，点击close关闭对话框
然后点击下列图标显示重建的三维模型，也可以设置光照等其他参数
以下为三维重建结果
3.法向量的导出与计算
三维点云的法向量的导出与计算有两种方式，一种是在上一节三维重建中我们已经得到了重建后的三维模型，那么每个点都带有法向量，可以直接导出即可，还有一种就是从杂乱的三维点中计算每一个三维点的法向量
3.1从三维模型中导出三维点云中每个点的法向量
接着第二节的步骤，点击File菜单下Export Mesh as 
然后在接下来的对话框中选择xyz格式
然后在 接下来的对话框中勾选Normal就可以生成文本格式的三维点以及三维点法向量
以下为文本格式的三维点坐标以及三维点法向量的结果
3.2 直接从三维散乱点云中生成三维点的法向量
然后点击Filter菜单下Normals，Curtavures and Oreientation下的Compute normals for point set计算三维点云的法向量，如下图
在弹出来的对话框可以自行设置参数，先Apply然后再Close
法向量的导出与3.1中的一样，可以自行参考。


以下为三维点云以及点云的法向量的可视化结果，点云表示为红色的点，法向量表示为绿色的线段
在程序开发中我们经常看见有一些软件左侧有目录树或者是图层树，点击之后就可以右侧View窗口显示相关的内容，其实实现这种机制有两种方法，第一种就是对MFC的View窗口进行窗口分割，左侧的窗口view类派生于CTreeView，其中CTreeView自带一个变量用于View中的树控件的控制。第二种方法就是用一个可停靠的面板嵌套一个对话框，再在对话框中添加树控件，同样可以达到相同的目的。
以下详解搭建步骤：
第一步：在VS2010中生成一个MFC经典风格的单文档程序，命名为CMyTestMFCDlg，编译下保证没有出错。

第二步：为该工程添加一个新类CMyDockablePane，派生于CDockablePane。



第三步：新建上述类完成后，在CMainFrame头文件中包含该类的头文件#include
 "MyDockablePane.h"
   声明该类的对象：



编译运行：


第四步：插入一个新的对话框，命名为IDD_DIALOG_DOCKDIALOG，在对话框属性中将Style设为Child，Border设为None。
为该对话框新建类：CDockDialog，基类为CDialogEx。
添加一个树控件，IDC_TREE_Test，为树控件关联一个控件变量m_TreeControl
在MyDockablePane.h中包含头文件#include
 "DockDialog.h"
添加CDockDialog
 类的成员变量：CDockDialog m_TestDlg;
添加CMyDockablePane的WM_CREATE和WM_SIZE消息响应函数
在函数中添加以下代码

CDockDialog类中重载虚函数OnInitDialog()，添加以下代码初始化树控件

CDockDialog头文件中添加#include "resource.h"




最后即可编译成功
最后即可编译成功






在网上看见一个对3D建模介绍十分全面的博客，来自中国科技大学图形与几何计算实验室刘利刚老师，介绍的非常棒，膜拜一下。
此处注明转载博客网址：3D建模与处理软件简介-中国科技大学刘利刚
3D建模与处理软件简介
刘利刚
中国科技大学
http://staff.ustc.edu.cn/~lgliu
 
【前言】自半年前笔者发表博客“什么是计算机图形学”以来，时常有人来向笔者询问3D模型的构建方法与工具。
笔者的研究方向是以3D技术为主，具体包括3D建模，3D处理及3D打印三个方面，在3D建模与处理方面从事了
十多年的研究，接触过很多3D相关的软件，在这方面有些经验。因此，特撰写此文，以帮助我们的学生及关注3D
技术的人了解3D建模和3D技术。本文仅仅为笔者根据自己的经验对3D建模与处理软件浅薄的理解，不涉及对技术
的深入讨论，是非学术性的。因此，笔者尽量尝试用通俗的语言介绍一下各种3D建模的软件和工具，以帮助还未接
触3D技术的学生来了解这些工具，以便在今后的科研和工作中能够选择合适的3D工具。笔者对本文的有些内容的理
解也是很有限的，值得进一步的学习和交流。有不当之处，还请读者谅解指正。
 
 
一、           专业3D建模软件
 
1.       3DS
 Max
美国Autodesk公司的3D
 Studio Max（前身是Discreet公司的，后被Autodesk收购）是基于PC系统的三维建模、动画
、渲染的制作软件，为用户群最为广泛的3D建模软件之一。常用于建筑模型、工业模型、室内设计等行业。因为
其广泛性，它的插件也很多，有些很强大，基本上都能满足一般的3D建模的需求。我们的学生也需要经常用到3DS
Max来构建模型。网上关于3DS
 Max的教程和学习视频非常多，使用者众多。
 
2.       Maya
Maya也是Autodesk公司出品的世界顶级的3D软件，它集成了早年的两个3D软件Alias和Wavefront（这两个软件在我
读博时就非常有名，当时就代表了最先进的动画及数字技术，我曾用过Wavefront）。相比于3DS
 Max，Maya的专
业性更强，功能非常强大，渲染真实感极强，是电影级别的高端制作软件。在工业界，应用Maya的多是从事影视
广告，角色动画，电影特技等行业。我们的学生也经常用Maya来制作和渲染3D模型，生成漂亮的渲染结果放在论
文中。
 
3.       Softimage
Softimage曾经是加拿大Avid公司旗下的专业的3D动画设计软件，后被Autodesk收购。它在影视动画方面，特别是
角色功能非常强大。许多电影，比如《泰坦尼克号》、《失落的世界》、《第五元素》等，都曾使用Softimage来
制作大量的惊人的视觉效果。
 
4.       LightWave
LightWave是美国NewTek公司开发的一款3D动画制作软件，具有悠久的历史，我在读博时曾接触过。它的功能非
常强大，特别是在生物建模和角色动画方面功能异常强大，广泛应用在电影、电视、游戏、网页、广告、印刷、
动画等各领域。在电影《泰坦尼克号》中细致逼真的船体模型及其他众多游戏的场景和动画都曾使用LightWave
来制作的。
 
5.       Rhino（犀牛）
Rhino是美国Robert
 McNeel公司开发的专业3D造型软件，它对机器配置要求很低，安装文件才几十兆，但“麻雀虽
小，五脏俱全”，其设计和创建3D模型的能力是非常强大的，特别是在创建NURBS曲线曲面方面功能强大，也得到
很多建模专业人士的喜爱。在与上海造船厂研究所的合作项目中，我们用Rhino来进行船体曲面的NURBS建模和修
改，非常方便灵活。
 
6.       Cinema
 4D
Cinema 4D (C4D)是德国Maxon公司的3D创作软件，在苹果机上用得比较多，特别是在欧美日为最受欢迎的三维动
画制作工具。2009-2010年我在美国哈佛大学访问期间，经常看到学生用C4D在进行3D建模和动画的设计。
 
7.       Creator
MultiGen-Paradigm公司开发的Creator是专门创建用于大型3D虚拟仿真的实时三维模型的软件。其强大之处在于管
理3D模型数据的数据库，使得输入、结构化、修改、创建原型和优化模型数据库非常容易。前几年与一家从事数
字城市的公司合作时我们就用Creator快速创建大量的城市建筑模型，并且生成数据库来管理这些模型，还是相当
的方便。
 
注：从上述介绍可知，美国Autodesk公司当之无愧是当今3D建模和动画的“老大”，拥有3DS
 Max、Maya和Softimage等
3D建模和动画专业软件。3DS
 Max和Maya在3D建模方面各有特色，前者更为大众化些，相对容易掌握些，后者在专
业级的行业应用更为广泛，特别在制作动画和高质量渲染方面强于前者。我们的学生用Maya的相对多些，包括建模，
渲染和动画制作。Softimage和LightWave在3D动画方面表现强大。Rhino对NURBS曲面的支持更好。Creator适合于构
建大量的3D模型并构建数据库进行管理和修改。
 
 
二、           CAD建模和产品设计软件
 
1.       AutoCAD
AutoCAD (Auto Computer-Aided Design)是美国Autodesk公司出品的自动计算机辅助设计(CAD)软件，用于二维绘图
、文档规划和三维设计。适用于制作平面布置图、地材图、水电图、节点图及大样图等。广泛应用于土木建筑、装
饰装潢、城市规划、园林设计、电子电路、机械设计、航空航天、轻工化工等诸多领域。大家买房时看的房型图大
部分都是用AutoCAD来做的。
 
2.       CATIA
Catia由法国Dassault
 Systems公司开发的CAD/CAE/CAM一体化的三维软件，支持产品开发的整个过程，从概念(CAI
D)，到设计(CAD)，到分析(CAE)，到制造(CAM)的完整流程。可帮助制造厂商设计未来的产品，并支持从项目前阶
段、具体的设计、分析、模拟、组装到维护在内的全部工业设计流程，在机械行业，航空航天、汽车工业、造船工
业等应用广泛。其实体造型和曲面设计的功能非常强大。我读博期间曾接触过Catia，在它上面写过一个NURBS曲
面转换的插件程序。
 
3.       SolidWorks
SolidWorks是世界上第一个基于Windows开发的三维CAD系统，后被法国Dassault
 Systems公司(开发Catia的公司)所
收购。相对于其他同类产品，SolidWorks操作简单方便、易学易用，国内外的很多教育机构（大学）都把SolidWork
s列为制造专业的必修课。SolidWorks在杭州有专门的研发机构，我有个学生硕士毕业后在那里进行研发工作。
 
4.       UG
 NX
UG NX由美国Unigraphics
 Solutions (UGS)公司开发的CAD/CAE/CAM一体化的三维软件，后被德国西门子公司收购
。广泛用于通用机械，航空航天、汽车工业、医疗器械等领域。现在西门子公司在上海有专门的研发机构对UG
 NX
产品进行升级完善，我有2个学生博士毕业后在那里负责产品的开发和维护。
 
5.       Pro/E
Pro/Engineer是美国PTC公司(Parametric
 Technology Corporation)旗下的CAD/CAM/CAE一体化的三维软件。在参数化
设计，基于特征的建模方法具有独特的功能，在模具设计与制造方面功能强大，机械行业用的比较多。
 
注：除了上述所介绍的CAD/CAE
 /CAM系统软件（它们各有特色，在市场中都占有一定的份额）外，还有其他一些同
类产品，比如法国Missler公司的Topsolid和以色列Cimatron公司的Cimatron。一般在机械设计与产品研发相关的行业中
才会接触到这些软件，专业性比较强，在网上很容易能找到它们的相关资料。
 
 
三、           3D雕刻建模软件：笔刷式高精度建模软件
 
3D雕刻建模软件(Sculpturing
 modeling)，也称为笔刷式高精度建模软件，顾名思义，就是像艺术家那样用不同的“笔
刷”工具在模型表面上进行“雕刻”的自由创作。建模过程就像玩橡皮泥一样，利用拉，捏，推，扭等操作来对几何
进行编辑，生成任意的高度复杂和丰富的几何细节（如怪兽的复杂表面细节）。这些工具的出现颠覆了过去传统三
维设计工具的工作模式，解放了艺术家们的双手和思维，告别过去那种依靠鼠标和参数来笨拙创作的模式，完全尊
重设计师的创作灵感和传统工作习惯。
 
1.       ZBrush
美国Pixologic公司开发的ZBrush软件是世界上第一个让艺术家感到无约束自由创作的3D设计工具。 ZBrush能够雕刻
高达 10 亿多边形的模型，所以说限制只取决于的艺术家自身的想象力。
 
2.       MudBox
MudBox是Autodesk公司的3D雕刻建模软件，它和ZBrush相比各有千秋。在某些人看来，MudBox的功能甚至超过了
ZBrush，可谓ZBrush的超级杀手。
 
3.       MeshMixer
最近，Autodesk公司又开发出一款笔刷式3D建模工具MeshMixer，它能让用户通过笔刷式的交互来融合现有的模型
来创建3D模型（似乎是类似与Poisson融合或Laplacian融合的技术），比如类似“牛头马面”的混合3D模型。
值得注
意的是，最新版本的
MeshMixer
还添加
3D
打印支撑优化新算法，值得关注。我们
Siggraph
 Asia 2013
的论文“
Cost-effe
ctive
 Printing of 3D Objects with Skin-Frame Structures
”也给出了一种为
3D
打印加尽可能少的支撑材料的新算法（详
见我的博文“
经济节约型的3D打印技术
”），该算法也是具有较好的市场前景，我们也在努力进行产业转化。
 
4.       其他
其他还有一些同类的3D雕刻建模软件，比如3DCoat，Sculptris，Modo等。这里就不再详细介绍了。
 
注1：在工业界，人们更偏向于使用四边形网格(quad
 mesh)，而不是三角网格，一个很重要的原因就是这些雕刻建模
工具善于在四边形网格上进行细节的生成和编辑，因为四边形网格的边更能反应物体表面的流线方向(edge
 flow)。我
们Pacific Graphics 2010的一篇论文B-mesh，就是在建模过程中同时生成具有良好流线方向的四边形基网格(base
 mesh)，
然后直接可以导入到这些雕刻软件中进行进一步的细节雕刻建模。
 
注2：虽然这些笔刷式建模工具上手容易，给了用户便利的方式进行3D细节建模，但是，要想真正构建一个细节复杂
和逼真的3D模型还是不容易的，除了用户需要熟练掌握软件的各种工具及雕刻技巧外，还需要用户具有较好的艺术和
绘画功底。
 
 
四、           基于草图的3D建模软件
 
基于笔划或草图的交互方式由于其符合人类原有日常生活中的思考习惯，交互方式直观简单（就像在图纸上画画
一样来构建3D模型），是最近十多年来计算机图形学中研究的热点建模方法之一。这方面的研究论文有很多，比
如Siggraph 1999年的Teddy，到Siggraph
 2006年的SmoothSketch，Graphics
 Interface 2007的Magic Canvas，Siggraph 
2007年的FiberMesh，SigCHI
 2010年的ICanDraw等。最近，我们也提出一种基于阴影引导的草图交互的3D建模的
技术“Modeling
 by Drawing with Shadow Guidance”，从已知的模型数据库中提取信息来引导用户的笔划交互，能构
建更为精准的3D模型，该工作发表在Pacific
 Graphics 2013上。
虽然在科研上提出了很多基于草图的
3D
建模技术，
但是至今仍未能有比较成熟的商业化的软件出现，可能是因为要理解不同用户的划线和草图还是一件比较困难的
事情。对于一些比较规则的物体，比如建筑、家具等人造物体，这种方式相对可行些，比如
Google
的
SketchUp
（在
国内我们也称为“草图大师”）。
SketchUp
是一套面向普通用户的易于使用的
3D
建模软件。使用
SketchUp
，创建
3D
模型就像我们使用铅笔在图纸上作图一般，软件能自动识别你画的这些线条，加以自动捕捉。它的建模流程简单
明了，就是画线成面，而后拉伸成体，这也是建筑或室内场景建模最常用的方法。
SketchUp
还可以将你自己的制
作成果发布到
Google
 Earth
上和其他人共享，或者是提交到
Google
的
3D
 Warehouse
（
Google
的
3D
模型库）。当然你
也能从
Warehouse
那儿得到想要的素材，以此作为创作的基础。很有趣的是，在
2012
年
Google
公司的
SketchUp
被美
国
Trimble
公司收购了。去年出了个
Trimble
 SketchUp 2013
，网评似乎不太好。不知其是否能继续免费。
最近国内出
了一款叫做“
EasyToy
”的采用草图式的
3D
建模软件，适用于卡通动漫形象与玩具的设计。但我还没有试用过，不知
用户体验如何。另外，日本东京大学的
Takeo
 Igarashi
教授也发布了一些基于草图式的
3D
建模系统，比如
Teddy
，在
其主页上可以下载到。
另外，值得一提的是，基于草图的交互方式在现在正在兴起的
Web3D
建模领域会有新的广阔
空间。
Web3D
建模在稍后会介绍。
 
 
五、           基于照片的3D建模软件
 
从物体的照片来进行3D模型的构建，是计算机图形学和计算机视觉的一大研究方向，称为基于图像的几何建模(Ima
ge based modeling)。这种技术已逐渐成熟且走向实用阶段，最近有些软件能够让用户拿着普通相机或者手机对着要
建模的实物从不同视角拍摄若干照片，然后软件就能根据这些照片自动地生成相应的3D模型。这种基于
图片的建
模技术提供给了非专业建模人士来构建
3D
模型的工具。
 
1.       Autodesk
 123D
Autodesk公司最近发布了一套平民级的建模软件Autodesk
 123D，用户不需复杂的专业知识，只要为物体从不同的
视角拍摄几张照片，该软件就能自动地为其生成3D模型，而且软件是完全免费的。
(1)    Autodesk
 123D是一款免费的3D CAD 工具，用户可以使用一些简单的图形来设计、创建、编辑三维模型，或者
在一个已有的模型上进行修改。
(2)    Autodesk
 123D Catch是建模软件的重点，用户使用相机或手机来从不同角度拍摄物体、人物或场景，然后上传
到云，然后该软件利用云计算的强大计算能力，可将数码照片中几分钟的时间内转换为3D模型，而且还自动带上
纹理信息。我们试用过几次，感觉它的使用还是很方便的。但是其生成的3D几何的细节不多，主要是通过纹理信
息来表现真实感的。有时软件也会失败，生成的几何是不正确的。
(3)    Autodesk
 123D Make是将3D模型转换为2D的切割图案，用户可利用硬纸板、木料、金属或塑料等低成本材料
将这些图案迅速拼装成实物，从而再现原来的数字化模型。这让用户能够“制造”出所造的3D模型，有点像3D打印
的雏形。目前123D Make只有Mac版的。
(4)    Autodesk
 123D Sculpt是一款运行在iPad上的3D雕刻软件（前面已介绍过），通过绘画的方式在模型上雕刻
几何细节。
 
2.       3DSOM
 Pro
3DSOM Pro是一款从高质量的照片来生成3D建模的软件，它可以通过一个真实物体的照片来进行3D建模，并且制
作的模型可以在网络上以交互的方式呈现。
 
3.       PhotoSynth
微软开发了一款产品PhotoSynth，可将大量的照片做3D处理，但是它不是真正创建3D模型，而是根据照片之间的
相机参数及空间对应关系，建构一个虚拟的3D场景，使得用户能够在从不同角度和位置来查看该场景，而显示的
场景图像是由给定的照片所合成的。其基本原理来自于Siggraph 2006的论文“Photo
 Tourism: exploring photo colle
ctions in
 3D”及其他相关论文。
 
注：从多幅不同角度拍摄的照片来重建3D物体，从技术原理上来讲是可行的，但是由于算法的一些步骤，比如图像
中物体特征点的检测和匹配，相机参数的估计等，还会出现不太正确的结果，使得重建结果有时不够稳定，甚至不
正确。随着技术和计算能力的不断发展，相信这些会逐步得到解决。到时，从照片来重建3D模型的技术可能是最为
方便的3D建模技术了，因为人人都有手机，随时都可以拍照上传到云端来构建3D模型。如果有了大数据库的支持，
从单张照片来构建3D模型也是可能的，可以参看我们的Siggraph
 2011的论文。
 
 
六、           其他3D建模软件
 
1.       人体建模软件
关于构建人体模型及动画，首推Metacreations公司的Poser软件（俗称“人物造型大师”）和开源的MakeHuman软件
。这两款软件都是基于大量人类学形态特征数据，可以快速形成不同年龄段的男女脸部及肢体模型，并对局部体
形进行调整。可以轻松快捷地设计人体造型、动作和动画。我读博期间用过Poser构建人体模型来做morphing，
还是蛮方便的。
 
2.       城市建模软件
加拿大Esri公司的CityEngine是三维城市建模的首选软件，可以利用二维数据快速创建三维场景，并能高效的进行
规划设计。应用于数字城市、城市规划、轨道交通、管线、建筑、游戏开发和电影制作等领域。另外，CityEngine
对ArcGIS的完美支持，使很多已有的基础GIS数据不需转换即可迅速实现三维建模，缩短了三维GIS系统的建设周
期。该软件的核心技术是Siggraph 2001的论文“Procedural
 Modeling of Cities”及其他相关论文，早期是ETH Zurich
大学的Pascal Mueller研究小组创办的Procedural公司开发的，后被Esri公司收购。
 
3.       其他小巧的3D建模软件
下面的这个网页还介绍了一些其他3D建模相关的软件或程序：
http://tech.sina.com.cn/s/2008-10-20/08192519895.shtml
这些软件大部分都非常小巧，而且是开源且完全免费的。有很多媒体工作者和艺术家用这些小软件来制作3D作品
，其中Blender, K-3D, Art of Illusion, Seamless3d,
 Wings3D等软件的使用面稍微广泛些。有兴趣的读者可以到网上找
到相关资料去了解和学习，这里不作详细介绍。
 
4.       网页3D
 (Web3D)建模工具
最近，出现了一些基于网页(web)开发的3D模型设计软件，即基于WebGL，可以在浏览器中完成3D建模的工具。
比如3DTin，TinkerCAD（去年被Autodesk收购）等，它们的界面简单直观，有Chrome等浏览器插件插件，可以在
线生成3D模型，直接存在云端，并在社区分享模型。
在互联网的时代，
Web3D
技术将被越来越被广泛使用，建议
大家多关注。
 
 
七、           虚拟现实软件和平台
 
虚拟现实软件本质上不是用于3D建模的，而是用来对生成好的3D模型和场景提供关于视觉、听觉、触觉等虚拟的
模拟，让用户如同身历其境一般。相关软件也有很多，这不是本文的重点，只大致提及几个比较常见的。
 
1.       VirTools和Quest3D
法国VirTools公司的VirTools和美国Act-3D公司的Quest3D都是元老级的虚拟现实制作软件，简单来说，就是工业
或游戏用的实时图形渲染引擎，是3D虚拟和互动技术的集成工具。可以让没有程序基础的美术人员利用内置的行
为模块快速制作出许多不同用途的3D产品，如网际网络、计算机游戏、多媒体、建筑设计、交互式电视、教育训
练、仿真与产品展示等 。网上的学习资料比较多。
 
2.       Unity3D
 (U3D)
Unity Technologies开发的Unity3D
 (U3D)是最近几年冒出来的新秀，是一个全面整合的专业虚拟3D和游戏引擎。
它在制作虚拟现实及3D游戏方面上手非常容易，操作简单，互动性好，有强大的地形渲染器。我们的学生使用
U3D可以很快地制作一个3D游戏，因此也强烈推荐大家学习使用。
 
3.       Vega
Vega是MultiGen-Paradigm公司开发的用于实时视觉模拟和虚拟现实应用的开发引擎，提供很多的C/C++语言的应
用程序接口API，结合其应用程序的图形用户GUI界面软件LynX，可以迅速创建各种实时交互的3D环境。对于开
发3D游戏和3D场景漫游的项目非常方便。
 
4.       OSG
 (Open Scene Graph)
OSG (Open Scene Graph)是一套开源的基于C++平台的应用程序接口API，能够让开发者快速、便捷地创建高性能
、跨平台的交互式图形程序。它将3D场景定义为空间中一系列连续的对象，能够对3D场景进行有效的管理。由于
OSG是开源和完全免费的，很多3D应用的软件都选用OSG作为基础架构。几年前，我们与一个公司合作开发的义
齿软件就选用OSG作为管理3D数据的框架，使得开发非常方便。
 
5.       其他
其他的一些用于3D应用程序开发的软件开发包(SDK)或API还有GLUT(OpenGL
 Utility Toolkit), OpenGL Performer, 
CG2 VTree, Quamtum3D Mantis等。有兴趣的读者也可以去了解一下。
 
注：相比于十年前，由于有了上述开发平台和开发包，现在开发一个看起来还比较cool的3D应用程序或游戏不是那么
困难，随着技术的不断发展和3D应用不断渗入到各行各业，相信以后会更加方便。
 
 
八、           开源3D网格处理库
 
1.       PCL
 (Point Cloud Library)
Point Cloud Library (PCL)是一个独立的大型跨平台的处理二维/三维图像和点云数据的C++模板库，它基于许多第三
方库，比如Boost、Eigen、FLANN、VTK、CUDA、OpenNI、Qhull等，实现了大量点云相关的通用算法和高效数
据结构，涉及到点云获取、滤波、分割、配准、检索、特征提取、识别、追踪、曲面重建（包括Poisson重建算法
）、可视化等。早期的PCL是由Dr.
 Radu Bogdan Rusu在德国慕尼黑工业大学读博士期间开发的，目的是要为三维
点云数据处理的研究及应用，建立出一个共同的基础架构。另外，PCL利用OpenMP、GPU、CUDA等先进高性能
计算技术，通过并行化提高程序实时性。集成了Kinect Fusion重建算法。有人将其地位比喻为3D的OpenCV，足以
可见其对3D的开发和研究的重要性，我们的学生在科研过程中经常用到PCL。
 
2.       CGAL
 (Computational Geometry Algorithms Library)
CGAL是一套开源的C++算法库，提供了计算几何相关的数据结构和算法，诸如三角剖分（2D约束三角剖分及二维
和三维Delaunay三角剖分），Voronoi图（二维和三维的点，2D加权Voronoi图，分割Voronoi图等），多边形，多
面体（布尔运算），网格生成（二维Delaunay网格生成和三维表面和体积网格生成等），几何处理（表面网格简
化，细分和参数化等），凸壳算法，搜索结构（近邻搜索，kd树等），插值，形状分析，拟合等。CGAL功能强
大，是我们学生做科研的必备程序库之一。
 
3.       MeshLab
MeshLab是一个开源的处理三角形网格的C++算法库，提供了三角网格的数据结构和算法，诸如曲面重建、编辑
、修复、光顺、编辑等算法。MeshLab也是我们学生做科研的必备程序库之一。
 
4.       其他开源网格处理库
OpenMesh：由德国RWTH
 Aachen大学的Leif Kobbelt研究小组开发的C++网格处理库
Libigl: 由瑞士Ethz大学的Olga
 Sorkine研究小组开发的C++网格处理库
Trimesh：有美国Princeton大学的Thomas
 Funkhouser研究小组开发的C++网格处理库
 
5.       网格剖分(Delaunay)与生成库
Triangle, NetGen：平面三角网格生成库
TetGen, Stellar：空间四面体网格生成库
 
注：这里列出了几个主要的网格处理的C++代码库，我们的学生在学习和科研的过程中会经常用到它们。当然，网上
还有其他的各种算法库，对我们的科研和开发都是非常有用，我们有时也会用到，这里就不再详述。
 
 
九、           基于扫描（逆向设计）的3D建模软件
 
随着深度相机的普及及扫描仪的价格迅速下降，人们采集三维数据变得容易，从采集到的三维点云来重建三维
模型的工作在最近几年的Siggraph(Asia)上能常见到，比如我们Siggraph
 Asia 2010，Siggraph
 2013等的工作。最近
几年产生了许多基于点云数据的建模与处理（或逆向工程和设计）的软件，而且各种扫描设备的生产厂商也会发
布相应的点云重建的软件。
 
1.       Geomagic
Geomagic (俗称“杰魔”) 包括系列软件Geomagic
 Studio、Geomagic Qualify和Geomagic
 Piano。其中Geomagic Studio
是被广泛使用的逆向工程软件，具有下述所有特点：确保完美无缺的多边形和 NURBS 模型处理复杂形状或自由
曲面形状时，生产效率比传统 CAD软件提高数倍；可与主要的三维扫描设备和CAD/CAM软件进行集成；能够作
为一个独立的应用程序运用于快速制造，或者作为对CAD软件的补充。是我们学生科研的必备软件之一。
 
2.       RapidForm
RapidForm是韩国INUS公司出品的逆向工程软件，提供了新一代运算模式，可实时将点云数据运算出无接缝的多
边形曲面，使它成为 3D扫描数据的最佳化的接口，是很多3D扫描仪的OEM软件。我们购买的Konica
 Minolta的激
光扫描仪Range 7就是用RapidForm来进行逆向设计。我们SGP
 2010的ARAP参数化算法作为目前为止最好的参数化
算法之一，被集成到了RapidForm软件中。
 
3.       ReconstructMe
ProFactor公司开发的ReconstructMe是一个功能强大且易于使用的三维重建软件，能够使用微软的Kinect或华硕的
Xtion进行实时3D场景扫描（核心算法是Kinect
 Fusion），几分钟就可以完成一张全彩3D场景。我们尝试过，效果
还可以。ReconstructMeQt提供了一个实时三维重建利用ReconstructMe
 SDK（开源）的图形用户界面。
 
注：法国ManCTL公司开发的Skanect为Mac平台的第一款3D 扫描软件，也支持者华硕的Xtion或者微软的Kinect进行
实时3D 扫描。
 
4.       Artec
 Studio
Artec公司出品的Artec
 Eva, Artec Spider等手持式的结构光3D扫描仪，重量轻且易于使用，成为许多3D体验馆扫描
物体的首选产品。我试用过Artec Eva后感觉还是需要较多的技巧才能扫描好物体，而且后期需要用软件进行较多
的处理，比如数据的去噪、修复、光滑、补洞等。
同时，
Artec
公司还开发了一款软件
Artec
 Studio
，可以和微软的
Kinect
或华硕的
 
Xtion
以及其他厂商的体感周边外设配合使用，使其成为三维扫描仪。
Kinect
通过
Artec
 Studio
可以
完成模型扫描，然后进行后期处理，填补漏洞、清理数据、进行测量、导出数据等。不确定它是否也使用了
Kinect 
Fusion
算法。
 
5.       PolyWorks
PolyWorks是加拿大InnovMetric公司开发的点云处理软件，提供工程和制造业3D测量解决方案，包含点云扫描、
尺寸分析与比较、CAD和逆向工程等功能。
 
注1：全球四大逆向工程软件除了Geomagic
 Studio和RapidForm外，还包括ImageWare和CopyCAD，由于后两者我不
熟悉，在此就不介绍了，有兴趣的读者可以到网上去找相关资料了解。
 
注2：微软的Kinect作为快速获取3D数据的传感器，可以作为3D扫描仪来使用，我们曾使用3台Kinects来扫描人体全
身，论文发在2012年的IEEE
 TVCG期刊。现在有多款软件或者开发库（包括上面介绍的PCL，ReconstrutMe，Artec
Studio，Skanect），支持将单台Kinect作为手持式扫描仪来扫描物体，其核心都是Kinect
 Fusion算法。
 
 
十、           后记
 
最近，随着人们对3D建模的需求越来越大，出现了许多其他形式的3D建模软件和工具，比如Blokify, 基于块状化
3D建模软件，特别适合孩子们制作模型。这些新出现的工具我这里就不一一介绍了，大家可以关注网上的一些科
技新闻网站、论坛或博客等。
 
 
1.       3D模型数据浏览与转换软件
上面介绍的大部分的软件或库都支持查看不同格式的3D模型数据。如果仅仅是浏览或查看现有的3D模型数据，我
个人推荐3D Exploration软件（相当于查看图像的ACDSee软件），它是一个专门用来查看各种格式的3D模型文件，
包括3DS数据 (*.3ds,
 *.prj, *.asc)、LightWave Objects (*.lwo,*.lw)、 DirectX(*.x)、AutoCAD
 (*.dxf)、Object File Fo
rmat (*.off)、Wavefront
 (*.obj)等，还可以用鼠标交互从不同视角来查看。而且还能查看各种图像文件，包括bmp
、rle、dib、gif、jpg、png、tif、tga、pcx等。当然也能查看带纹理的3D模型。3D
 Exploration是我的机器必装软件
之一，强烈推荐。另一个我推荐的同类软件是Deep Exploration，它除了可以浏览3D数据外，还可以转换数据格式
（最新版本还支持Sketchup文件），同时它还可以对你的模型进行编辑及添加注释制作动画等，我也强烈推荐。
注：现在有很多3D数据格式，几乎每个3D建模软件都会定义自己的数据格式。几种比较公认的3D数据格式有VR
ML、obj、off、stl
 (用于3D打印的数据格式)等。现在有些组织在力推3D数据的标准。相信随着3D技术的发展，这
些格式都将越来越标准化和统一化。对各种数据格式需要更多了解的，可以到网上找找，比如：
http://www.cnblogs.com/sunliming/archive/2012/02/28/2372398.html
 
 
2.       3D模型渲染软件
本文介绍的各种3D建模软件一般都能渲染3D模型，但要得到更为逼真的真实感渲染效果，还可以使用专门的3D
模型渲染软件，比如Pixar Renderman、POV-Ray、 V-Ray、 Mental
 Ray、Final-Render等，这里就不详细介绍。一
般我们使用Maya进行渲染放在论文中，已经足够漂亮了，读者可以在我们的许多论文中看到利用Maya渲染的结果
图。
 
3.       其他相关的软件
本文以介绍3D建模的软件和库为主，另外，还有许多跟3D技术相关的软件和开发包我没有提及，比如图像处理、
可视化、处理医学图像、建筑设计、装潢设计及艺术设计等。读者可以根据各自的专业去网上寻找所需要的专业
软件。
 
4.       学习使用3D建模软件
相比于2D平面软件Adobe
 Photoshop，Illustrator，CorelDraw等，学习3D软件难度稍大些，需要了解和掌握一些3D
的概念、3D交互习惯和技巧。因此，想要在短期熟练掌握好一个3D建模软件，是不太可能的，需要多用、多摸索
、多体会。网上有许多教材和视频，您可以跟着去学习。总之，您要多去玩，就能玩熟了。如果您能有个确定的
目标来学习3D软件，比如完成项目或者论文中所需要的效果，您就能掌握得更快！因为，带有确定目标和任务的
学习，是最高效的学习。但您如果暂时用不到，暂可不必花太多时间去学习，学了但不去用，也容易忘。只要您
学习软件的速度快就可以，而这正是我们对学生的基本要求。
 
5.       3D时代的来临
最近两年3D打印机的兴起，引起人们的极大好奇与广泛关注，同时也有些争论。虽然还不清楚它是否能成为人们
生活中不可或缺的一项技术，但不可否认，3D打印技术确实已经给世界带来巨变，已逐渐在某些领域表现出巨大
的价值，比如，提高了制造行业的生产力，在医学领域得到了广泛应用（义齿，假肢，器官等），为艺术家提供
了有效的创作工具等等。个人认为，3D打印提供给了平民零技能制造的技术，会朝着“私人定制”（个性化需求）
的方向发展；随着大量草根参与到3D的设计和制造，3D打印将逐步颠覆人们创造东西的能力。正因人们对3D模型
有了巨大的需求，3D打印技术才使得计算机图形学“落地”，这也使得我们这个学科终于在人们生活中体现了巨大
的价值。关于3D打印技术将给大规模工业经济带来的巨大冲击以及给我们的生活将带来的巨大变化，这里不展开
讨论，我将以后抽空撰文加以详述。
我们再来看一下这几年的一些巨头科技公司的变化，
2011
年微软公司的
Kinect
让人们获取
3D
数据的硬件代价降低了许多，
2012
年
3D
打印的兴起造就了两家上市公司
Stratasys
和
3D
 Systems
，
2013
年苹果公司收购了
Kinect
的核心技术公司
PrimeSense
，谷歌公司收购了大名鼎鼎的机器人公司
Boston
 Dynamics
，这
些都说明，越来越多的高科技企业在快速发展
3D
科技，
3D
时代已经来临！
随着人们对
3D
技术有了越来越多的需求，本文所介绍的
3D
建模工具将会发挥出更为巨大的价值。随着科学和技术的发展，云计算与物联网的进一步发展，将会出现越来越便利的
3D
建模工具，比如
Autodesk
 123D
正在将
3D
技术从专业变成非专业，人们接触
3D
技术的门槛将越来越低，创造的
3D
模型越来越丰富。我坚信，日后
3D
技术将“飞入寻常百姓家”，会越来越平民化，且成为人们生活中重要的一部分。
当然，当前人们对3D技术的了解还远远不够，大部分的人对3D技术仍然很陌生。另一个我个人看好的市场就是3D
教育与培训，普及3D技术与培养3D技术人才已时不我待。
另外，现在也开始有了一些
3D
模型共享的网站在运营，
能够提供给全世界的用户下载、上传、分享
3D
数据；类似于十多年随着
Internet
发展而产生的图像共享网站，这些
3D
数据共享网站也将在不久的未来产生巨大的价值，
3D
模型数据也将逐步进入“大数据时代”。
我们很庆幸成为
3D
科技新时代的弄潮儿，有很多的机会和挑战在等待着我们！让我们一起努力！
三维模型重建顾名思义就是从一些数据（点云，图片，三维轮廓线等）重建出物体的三维逼真的三维模型，在其重建的过程中针对不同的数据的的三维重建会有不同的处理算法，如针对点云数据的三维重建有很多种重建方法,如基于Delaunay三角化，Voronoi图，隐式曲面等方法，另外在三维模型的重建过程（MarchingCube，RayCast,网格构建等）以及三维模型生成后的后处理算法（三维网格简化，三维网格加密，三维模型表面光滑，三维模型的空洞修补等等）也是层出不穷，在这其中需要用到大量的三维图形学知识（从简单的画点画线算法到复杂的体绘制算法，以及光照计算，材质映射等）。在最后的实现方面致力于提高算法效率和运行性能，各种加快算法实现的三维数据结构（KD树，八叉树等）的提出和实现，以及压榨计算机和服务器性能的并行算法（OpenMP，MPI）等，减少算法实现过程中的内存占用以及运行时间（降低空间复杂度以及时间复杂度）。三维模型重建上的优秀算法或者是优秀实例我也只是管中窥豹，上面所提到的有些名词我也是大致了解，我尽自己最大的能力介绍下自己闲暇时间以前做过的相关三维模型重建的实例和其他相关的关于三维重建方面的知识，毕竟能力有限，知识面还有待拓展。
1.编程语言
是用的编程语言是C/C++，基本上相关的图形学方面的实现都是使用C/C++作为开发语言，不是说别的语言如Java，Python等语言不好，确实在效率方面以及内存处理方面C/C++有着比较大的优势，而且现在市面上的三维图形库其底层语言就是C/C++，所以使用起来更加方便。一门语言有其适用的场景和场合，正如Java在WEB和APP上面的天然优势一样，C/C++在图形处理，图像识别以及其他的图形处理领域也有着很大的优势。
2.我所使用的第三方库
（1）三维图形库OpenGL
OpenGL(Open Graphics Library)，OpenGL图形绘制库，有着优秀的二维和三维图形API，是一个功能强大的三维图形绘制的底层库，有着大量的调节三维模型视觉效果的函数，例如光照，模型材质，纹理等等。早期OpenGL包GLUT依然比较强劲，但是其不能用于64位平台的编译，而且GLUT官方已经不维护了，那么有一个新的FreeGlut横空出世，支持最新的OpenGL绘图标准，并且支持64位平台的编译，能够完全取代老化的GLUT库。


（2）三维图形库VTK
VTK（Visualization Tool Kit）同样也是一个优秀的三维图形库，近年来相当的火爆，它以OpenGL作为底层绘制语言进行封装，用户不需要考虑太多的光照以及材质影响到模型可视化效果的设置，这些VTK都已经帮你做好了，你需要考虑的是如何从原始数据绘制出你的图形。其内部封装了大量的三维图形处理函数，基本上你所能想到的算法都能找到影子，比如著名的面绘制方法MarchingCube，体绘制方法Raycast等等，往往你能在阅读他的帮助文档的时候看到一个意想不到的功能。


（3）计算机视觉库OpenCV
OpenCV（Open Source Computer Vision Library）今年来大热的计算机视觉库，同样以C/C++作为底层语言，封装了大量的图形处理和计算机视觉领域的算法，比如说图像识别领域，机器人，人类视觉仿真，好像现在大热的人工智能领域也开始使用OpenCV进行视觉领域方面的处理。


（4）矩阵运算库Eigen
在三维图形处理过程中通常需要大量的矩阵运算，而Eigen是一个轻量级的矩阵运算库，其函数API涵盖了几乎所有的矩阵运算，但是它的使用只需要包含一个头文件，不需要过于复杂的配置就可以使用已经封装好的各种矩阵运算函数。


（5）并行计算库OpenMP
OpenMP可以在你把项目代码构建好之后也仍然可以通过几行代码将你的程序自动的进行并行化计算，使用起来非常的简单，并行计算可以大幅度的提高你的程序的运行速度以及计算的效率。如果你的IDE是VS，那么你只需要简单的开启OpenMP就可以了，然后在VS中包含其头文件就可以使用OpenMP封装的函数进行并行程序设计。


其他的如CGAL（几何算法库），QT（图形界面库，不过本人更喜欢用老掉牙的MFC）等等。


3.我所接触到的三维重建类型
（1）点云三维重建（隐式曲面重建）
原始三维点云（三维点云以及法向量）-斯坦福兔子1889个点，采用OpenGL从底层写的径向基隐式曲面点云重建方法


采用径向基隐式曲面重建后的三维模型

（2）医学序列图片三维重建（使用VTK进行医学图片处理，模型构建采用MarchingCube算法）
重建结果

（3）OpenCV双目视觉重建（医学冠脉三维重建，VTK做可视化）
左视图A

右视图B

使用OpenCV做的三维冠脉重建，VTK做的显示

（4）基于轮廓线的三维模型重建
轮廓线


重建的三维模型




4.结语
万事开头难，作为一个刚刚入门三维重建领域的人写这篇文章心中的感觉简直是战战兢兢，三维模型重建方面的知识浩如沧海，我只不过是只窥得了寥寥数星。只不过自己想把自己学习到的一些知识与有缘人交流分享，共同进步。不知以后还不会不在三维领域工作与发展，不过之后的事情谁又知道呢。
后面我会详细介绍一些三维重建算法以及一些实例。



最近需要用到三维点云数据，但是网上大部分的数据资源的数据格式都是杂乱无章而且没有清晰的数据说明，为了方便，自己整理了常用的三维点云数据，格式都是按照X坐标空格Y坐标空格Z坐标这种数据格式排列，方便数据读取和进行三维点云的重建实验。
   其中的数据包含了著名的斯坦福兔子，大象，马，凳子，人头等三维点云数据，显示的效果如下：






















以下为三维点云的重建效果：
三维点云数据我已经上传到我的下载频道：常见的三维点云数据，已经整理数据格式 - 下载频道 - CSDN.NET  http://download.csdn.net/detail/hw140701/9852949
常见的三维点云数据，已经整理数据格式 - 下载频道 - CSDN.NET http://download.csdn.net/detail/hw140701/9852949



另外一些常见的三维模型的下载地址为：常见的三维模型下载地址：http://www.cc.gatech.edu/projects/large_models/
希望可以帮助到有缘人0.0




最近在项目中有一种结构体数据需要存储，数据结构体如下

现在需要根据在m_Vector中的每一个结构体的ID来获得其对应的pinwei值，所以就写了一个函数，如下
然后上程序上面测试，对于一个size大约15000的容器，大概每次循环需要进行20次FindpinweiValueInVector（）函数的调用，所以在Vector中查找值的最坏的情况是时间复杂度为O(n),即进行15000*20，这还是每次的循环，当一个菜单执行完毕整整花了大概6个半小时左右，程序运行效率低下。


所以，必须要有一种查找效率较高的容器，就想到的map,map为平衡二叉树，查找效率为对数级别，时间复杂度为O(logN)，查找相对来说较快，1000大小的数据最坏只需要3次就可以查找到，15000只需要4次多就可以查找到。
所以声明一个map<int,double>型的容器，用于建立mystruct的ID与pinwei之间的对应关系，然后将Vector存储的值插入到map中，然后在map中根据键值（ID）查找Value(pinwei)。
函数如下



总结：以前在项目中用惯了STL的Vector，因为其比数组来的方便，不需要定义数组长度，可以不断的pushback(),但是其在大数据量中的查找效率简直令人发指，所以以后在什么时候得根据特定的情况使用特定的容器，不要习惯性的使用Vector。
后来又测试了下，用hash_map更快。


1.OpenMP介绍
OpenMP 是 Open MultiProcessing 的缩写，用于共享内存并行系统的多处理器程序设计的一套指导性编译处理方案。在项目程序已经完成好的情况下不需要大幅度的修改源代码，只需要加上专用的pragma来指明自己的意图，由此编译器可以自动将程序进行并行化，并在必要之处加入同步互斥以及通信。当选择忽略这些pragma，或者编译器不支持OpenMp时，程序又可退化为通常的程序(一般为串行)，代码仍然可以正常运作，只是不能利用多线程来加速程序执行。OpenMP提供的这种对于并行描述的高层抽象降低了并行编程的难度和复杂度，这样程序员可以把更多的精力投入到并行算法本身，而非其具体实现细节。对基于数据分集的多线程程序设计，OpenMP是一个很好的选择。



2.VS2010中开启OpenMP
右键项目属性-配置属性-C/C++-语言-OpenMP支持-点击是。






3. OpenMP并行化测试
在已有源代码的基础上，要对此段代码进行并行化处理，只需要使用

程序结果




当我们修改为8个线程的时候，其结果为




可以看出4个线程和8个线程都执行了cout << "Thread  " << omp_get_thread_num() << endl; //omp_get_thread_num()是获取当前线程id号这句代码，而且先后顺序没有特定的从线程1到线程2执行，可以看出简单的实现了并行块的设计。


下面以一个较大的for循环来测试OpenMP并行程序与普通串行程序的速度问题。
需要对for程序代码段执行并行化需要添加#pragma omp parallel for
串行化程序：





并行化程序：





在我们建立三维模型的过程中，当用多边形网格或者是三角面片来近似的表示曲面的表面时，曲面被离散成许多的平面多边形，如果我们的网格较大，离散度较粗，在模型表面使用明暗处理后，两两相邻的多边形会出现凸起或者是凹陷的折痕，在连接处显得比周围处亮或者暗，这就是所谓的马赫夫效应，如下图所示
针对于出现的马赫夫效应，我们需要进行明暗处理，消除或者是减少三维模型的马赫夫效应，使其看上去更加的光滑美观，常用的明暗处理技术有双线性光强插值—Gouraud明暗处理技术和双线性法向插值-Phong明暗处理技术。以下展示经过明暗处理前后结果对比
OpenGL提供了两种着色模式
void glShadeModel ( GLenum mode)，恒定着色
GL_FLAT，光滑着色GL_SMOOTH，而GL_SMOOTH中则是使用了Gouraud明暗处理技术，对于Phong明暗处理技术可以参见http://blog.csdn.net/dalewzm/article/details/46291397
http://blog.csdn.net/silangquan/article/details/10011169

Gouraud明暗处理算法在处理亮度的不连续性方面很有效，但是在明暗强度函数的斜率急剧变化处仍然可以看到马赫夫效应，不能完全消除光强度的不连续性。而Phong明暗处理是对表面的法向量而不是亮度进行插值，大大改善了Gouraud模型对高亮度镜面反射光的处理，在每一点都是用法向量的一个近似值，所以一般法向量插值的结果要优于亮度插值，在很大程度上消除了马赫夫效应，但是会大大增加明暗处理的时间。


鉴于此，我在用MC算法建立三维模型的时候，由于我的网格设置较大，导致出现了马赫夫效应，即模型表面的可视化效果不光滑，如下：



于是使用OpenGL自带的Gouraud明暗处理技术，以一个MC算法生成的章鱼模型为例子，效果如下
相比未使用明暗处理的模型，使用了Gouraud处理的模型从可视化的角度上来看更加的光滑，效果更好。




MFC PictureControl控件上自适应显示图片，分图片失真或者图片不失真两种





图片不失真，但是没有铺满整个图片控件区域：


问题描述：给定两个非空的链表，表示两个非负整数。 数字以相反的顺序存储，每个节点包含一个数字。 添加两个数字并将其作为链表返回。
测试代码：

VS2010-MFC在状态栏上添加进度条比在VC6.0中更加简单，不需要再从CStatusBar类中派生子类。
仔细查看VS2010生成的MainFrm.h文件我们可以看出，m_wndStatusBar已经是CMFCStatusBar的对象了，而不是CStatusBar对象。
CStatusBar对象。
所以就去微软的官网查看CMFCStatusBar的帮助文档，有中文，太好了
CMFCStatusBar的帮助文档，有中文，太好了
微软提供的MFC的帮助文档，有中文

微软提供的MFC的帮助文档，有中文

CMFCStatusBar类的帮助文档
此类自带进度条，只需要调用就可以了






以下为如何在VS2010单文档程序中在进度栏上添加进度条
步骤1:如上图所示，将m_wndStatusBar从protected型变量改成public型变量；
m_wndStatusBar从protected型变量改成public型变量；
步骤2：在MainFrm.cpp中添加进度条的标识IDS_PROGRESS
步骤2：在MainFrm.cpp中添加进度条的标识IDS_PROGRESS




并在资源文件字符串表String Table中新增一个字符串IDS_PROGRESS，如下图
并在资源文件字符串表String Table中新增一个字符串IDS_PROGRESS，如下图








步骤3：在CMainFrame的OnCreate()函数中添加以下代码，用于初试化状态栏
步骤3：在CMainFrame的OnCreate()函数中添加以下代码，用于初试化状态栏




步骤4：在View中某个读取文件的响应函数，添加以下代码，即可在状态栏显示文件加载进度条，以及当前文件大小和百分比信息




当我们点击读取文件后，文件总长度可以通过FILE类的Ftell函数进行获取，然后就可以在状态栏查看当前文档的加载进度以及已经加载文件的大小




整个编写流程就完成了，比VC 里面简单太多了。
使用VTK生成分布在球内部或者表面的三维点云数据，可以设置球的中心，半径以及生成的三维点的个数并选择可以设置在球内部生成或者是球表面生成。

问题描述:将一个string型的字符转成int型的数字，需要处理字符串输入的各种情况，如字符串前面的空格，+号，-号等符号。
     测试代码：

在原先的博客VTK读取一个TXT文档中的三维点坐标绘制三维点云基础上，有小伙伴询问是否可以以点云中每一个三维点的坐标为中心绘制一个小的球体，用于标识特征点，这种就让我想到了化学里面的分子结构，所以就在原有博客的基础上进行了改写，实现了点云不是以点的方式而是以小球体形式显示出来，实现了大量球体的同时绘制。
不多说直接贴代码：

整体图：




局部的线框显示细节图：




局部表面显示细节图：


LeetCode第一题：
问题描述：给定一个整形的数组，在给定一个特定的整数值，要求返回这个整形数组中两个元素的和等于给定的整数的元素索引。
STL容器vector是新手入门STL最常用也是最好用的容器类，其不像array需要固定大小，而是可以动态的在容器尾部或者是中间插入元素，相当的好用，但是我们往往会在一个程序中向vector中压入了很多的元素，在使用完vector中的元素之后，只是会用clear去清理vector中的元素，有些小伙伴认为清空容器就等于释放了内存，其实真正的是这样的吗？我们不妨来做一个测试。
首先我们声明一个double型的容器，往里面压入了10000000个元素，然后用clear方法，看是否能真正的释放掉vector所占的内存，这里用SDK中的 GetProcessMemoryInfo方法来获取当前进程的所占用的内存。
代码如下：

程序运行结果：




我们可以看到使用clear方法虽然清空了vector中的元素，但是并没有释放掉vector所占用的内存，高效的管理内存是程序设计所要求的，C++ 11有了一个全新的shrink_to_fit()方法，该方法与clear()搭配使用，将vector所占用大小缩小到合适的范围，以下进行测试
代码如下：






我们可以看到，使用shrink_to_fit方法可以快速的释放掉vector所占用的内存。
MFC的界面太丑了，但是学会之后写一写简单的可交互的PC端程序还是可以的，但是用VS2010自己生成的MFC工程上的控件程序还是MFC经典风格，实在是看不下去，如下




要使其按钮带有Win7风格，带有Aero的美化效果，就需要在MFC工程的头文件Stdafx.h文件中，加入以下代码








但是如果想要有更加好的效果，还是自绘吧。
先说说题外话，OpenGL是一个跨平台优秀的三维可视化库，而在Windows中内部封装的OpenGL还是1.1版本，不吐槽，维护自身Direct3D的发展也是情有可原。如果你是Win32系统，编译环境也是Win32的话，对OpenGL只是练习，那么就用简单的GLUT来配置OpenGL环境就好了，但是如果你想用X64(64位)环境来编译的话，这个GLUT会编译不成功，因为它不提供64位下的使用环境，而且太老掉牙了，版本已经不更新了，那么这个时候你就需要freeglut这个包(国外推荐使用freeglut，摒弃glut),这个包提供了32位(x86)和64(x64)两种编译环境下可用的静态链接库和动态链接库。关于64位环境编译的程序与32环境编译的程序之间的区别就是32位程序在系统中最多能申请到2G内存（2的32次方字节），而64位程序在系统中最多能申请到（2的64次方字节）的内存，64位程序理论上可以使用当前PC机上所装载的全部的内存，极大的提高了程序的性能。下面介绍了Glut和FreeGlut的详细配置教程，以便在32位编译环境和64位编译环境都得心应手的使用OpenGL。
*我的VS2010的安装位置：D:\Program Files (x86)\Microsoft Visual Studio 10.0
1.关于Glut的配置
1.1. 下载GLUT。Windows环境下的GLUT下载地址：
http://www.opengl.org/resources/libraries/glut/glutdlls37beta.zip



1.2
1.3 
1.4 
1.5 

2.Freeglut的配置




我使用的环境具体是Win764位+VS2010+Freeglut2.8.1,而Freeglut2.8.1这个版本支持VS2010,可使用最高的版本3.0，同样支持各种VS版本。


2.1 Freeglut的下载
Freeglut2.8.1:http://download.csdn.net/detail/hw140701/9830604
Freeglut其他版本的下载地址：
Freeglut3.0版本：
http://www.transmissionzero.co.uk/software/freeglut-devel/

http://download.csdn.net/detail/hw140701/9830606



2.2 生成VS2010 64位编译环境下下可用的Freeglut的包含头文件，静态链接库lib,动态链接库dll。
解压缩包，打开解压后的压缩文件夹，里面会有一个VisualStduio的文件夹，如下


    打开VisualStudio文件夹，里面会有VS2008，VS2010，VS2012三个版本的


    选择VS2010，打开项目文件freeglut.sln。


    选择Release版本，x64平台编译，右键解决方案，点击全部生成


然后你会在解压的文件夹下发现两个新的文件夹inclue和lib文件夹




include文件夹下会有GL文件夹，里面包含了freeglut所需用到的头文件，freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h,注意这里的glut.h与Glut包的glut.h文件不相同。
lib文件夹下会有一个x64文件夹，里面包含了freeglut.lib和freeglut.dll文件。
2.3 具体配置
 Freeglut配置本质上与Glut的配置原理相同，不过，我们这里配置的是64位的freeglut，稍微有一些不同。这里也简单介绍一下freeglut32位的配置，如果你要生成freeglut32可用的包含文件，静态链接库以及动态链接库，请参见上节中64的生成方法，不要需要将编译平台改为Win32，此节不再赘述。
1.将\freeglut-2.8.1\freeglut-2.8.1\include\GL文件夹下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2.将freeglut.lib复制到D:\ProgramFiles (x86)\Microsoft Visual Studio 10.0\VC\lib下。
    3.将freeglut.dll复制到C:\Windows\System32下
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\SysWOW64下。
    1.将\freeglut-2.8.1\freeglut-2.8.1\include\GL文件夹下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2.将freeglut.lib复制到D:\ProgramFiles (x86)\Microsoft Visual Studio 10.0\VC\lib\amd64下，注意这里是放64位静态链接库的地方。
    3.将freeglut.dll复制到C:\Windows\SysWOW64下
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\ System32下。
 
最后在使用的时候只需添加#include<GL/freeglut.h>就可以了。
2.4 Freeglut3.0的配置
    类似于Freeglut2.8.1的配置
下载网址就是
http://www.transmissionzero.co.uk/software/freeglut-devel/
选择freeglut3.0.0 MSVC Package




解压缩文件，有include,bin,lib三个文件夹
2.4.1 Freeglut3.0 32位的配置
    1.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\include\GL下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\lib下的
freeglut.lib复制到D:\Program Files (x86)\Microsoft Visual Studio10.0\VC\lib。
    3.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\bin下的
freeglut.dll复制到C:\Windows\System32下。
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\SysWOW64下。
 
2.4.2 Freeglut3.0 64位配置
    1.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\include\GL下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2. \freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\lib\x64下的
freeglut.lib复制到D:\Program Files (x86)\Microsoft Visual Studio10.0\VC\lib\amd64下。
    3. \freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\bin\x64下的
freeglut.dll复制到C:\Windows\ SysWOW64下
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\ System32下。




3.Glew的配置
3.1 Glew的下载
http://www.cnblogs.com/Akunwjy/p/Freeglut.html













VTK生成指定圆心以及指定半径的三维球，并将其导出为obj三维模型格式



Meshlab中载入qiu.obj




可在meshlab中将其转换为其他的三维数据格式或者提取球体表面的三维点云。
    冠脉三维重建就是从两幅不同角度拍摄的冠脉医学图片根据相机参数(角度)重建出原有的三维冠脉形态。
    具体文献可以参考：
      1.黄家祥. 冠状动脉树三维骨架重建方法的研究[D]. 天津大学, 2003.
      2.王国铸. 单臂冠脉造影三维重建与定量分析[D]. 华中科技大学, 2012.
      3.郝培远. 冠脉造影三维重建定量分析(QCA)及最佳投照角度的研究[D]. 南方医科大学, 2011.等文献





这里以黄家祥这篇文章的数据作为例子，具体的冠脉三维重建步骤可见这篇文章黄家祥. 冠状动脉树三维骨架重建方法的研究[D]. 天津大学, 2003。
以下为其中的一个实验所给出的数据，两幅不同角度的图片为。




         图A                               图B




图A和图B的相机参数分别为RAO 0，CAUD35和LAO 80，CRAN15。

图A和图B的相机参数分别为RAO 0，CAUD35和LAO 80，CRAN15。




















有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。

有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。

有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。






    匹配的结果如下：
匹配的结果如下：
















上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。

上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。

上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。












以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）

以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）

以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）

以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）












总体上来看，重建效果与论文中最后给出的结果类似，VTK封装了OpenGL底层的绘图命令，所以在光照与材质方面不需要我们去过多的设置就会有逼真的三维显示效果。
总体上来看，重建效果与论文中最后给出的结果类似，VTK封装了OpenGL底层的绘图命令，所以在光照与材质方面不需要我们去过多的设置就会有逼真的三维显示效果。




一个基于指针和重载操作符的数组类设计Array,可以进行数组范围检查，与平常看到的类而言，这个类的编写让人感觉逻辑十分清晰，以及更加可以理解面向对象程序设计理念。
Arry.h




当初学Python进一个Python学习群，不久之后群主大大就发了自己写的一个爬虫，就是爬取www.mzitu.com网站上的妹纸图片，看完之后，惊为天人，一脸懵逼，觉得群主大大好厉害，当初自己进群的初衷以及学Python的初衷就是为了做爬虫，然后慢慢的开始。所以说这次，就是为了实践一下，爬取这个网站上的所有的图片，别邪恶哦，虽然是隐藏福利，我只是为了写爬虫实践，我只是为了写爬虫实践，我只是为了写爬虫实践！！！


网络爬虫会给网站服务器造成巨大负荷，所以，本次实践的源码仅供参考交流，不宜用于商业应用，由此造成的任何法律责任本人不予承担。


为了得到这个网站上所有的妹子图片，就得分析网站的架构，通过分析发现http://www.mzitu.com/all这个网址下有2013-2017年网站上所有的相册的链接，所以准备通过以下步骤爬取网站上的所有图片。


第1步：在http://www.mzitu.com/all下获取所有的相册的链接以及相册的名字
第2步：根据每个相册的链接得到每个相册每一个图片页面的链接
第3步：根据每一个图片的链接得到每一张图片的名字以及图片链接


第一步：在http://www.mzitu.com/all下获取所有的相册的链接以及相册的名字
在
http://www.mzitu.com/all下获取所有的相册的链接以及相册的名字
分析网站源码，查看每一个相册链接以及名字的所处标签




由图上可以看出，每一个相册的链接以及名称都位于<a >标签下


第二步：根据每个相册的链接得到每个相册每一个图片页面的链接
根据每个相册的链接得到每个相册每一个图片页面的链接
通过分析网站源码，分析每一个相册下每一个图片页面的链接
通过分析网站源码，分析每一个相册下每一个图片页面的链接




通过分析，发现每一个图片页面链接都处于<div class="pagenavi">的<a herf>下，但是只有几个图片的页面的链接，如上图所示，分别只有2,3,4.......65，但是图片页面的规律是相册链接+"/"+页面编号，在这里我们得到最大的页面编号65，就可以通过循环得到每一个图片页面的链接，所以在这里通过字符选取将编号压入进一个list，然后通过max方法得到最大编号，得到每一个相册图片页面的链接。


第三步：根据每一个图片的链接得到每一张图片的名字以及图片链接
根据每一个图片的链接得到每一张图片的名字以及图片链接
根据以上得到的图片页面链接，在每个页面内爬取图片的下载链接以及图片的名称
根据以上得到的图片页面链接，在每个页面内爬取图片的下载链接以及图片的名称




通过分析，图片链接以及名称都位于<img>标签内


通过以上的分析，将整个流程写为Python代码，在其中使用了第三方包Beautifulsoup,现附上全部代码，如有错误，请指教







刚刚开始写的时候，会遇到服务器断开链接，以及主机在一定时间内无法连接的错误，在百度上，谷歌上看了半天，可能是由于网站的反爬虫机制，我自己的解决办法如下，不知道你们可不可行：
1、关闭windows防火墙，爬完再开
2、采用多headers，伪装不同的浏览器
3、每下载完，sleep一下，减缓访问网站的频率，如果过快，网站服务器会认为你是爬虫
4、设置全局超时时间，有时候因为网速的问题会出现这种情况
5、设置代理IP


刚刚开始不知道为什么这个网站不能用代理IP访问，一访问，网站服务器就强制断开连接，后来又可以了，尽量用代理IP，免得被封IP，代理ip网站可上http://ip.zdaye.com/查询


在这个代码中，没有采用多线程机制，所以爬起来比较慢，勿喷。
最好在晚上爬，网速快。
爬取结果（隐藏福利）：






1.显示一个地球各大洲板块的轮廓线

2. 地图指北针图例



由于最近的需要在任意两个三维点直接绘制三维圆柱体管道，OpenGL太底层了，以至于什么东西都要自己写
在网上参考了如下的博客:
http://blog.csdn.net/ryfdizuo/article/details/6548257

http://blog.sina.com.cn/s/blog_5cd804e70100oxca.html

http://blog.sina.com.cn/s/blog_3d2759c90100rpnf.html

在上述博客中有详细的原理介绍，而我只是将代码改成自己可以用的形式，以便调用。
代码如下：









增大其传进去的两个参数：段数Slices，以及递归次数stacks，可以获得更加光滑的圆柱体绘制效果：
由于有这个需求，就是当在对话框设置一些数值的时候，可以在对话框上预览三维图像。
（1）生成一个基于对话框的程序，或者直接在单文档或者多文档上插入一个对话框，生成一个新的对话框类CGridingDlg,名字可以任取。
（2）配置好工程的OpenGL环境，不知道可以百度。
（3）在CGridingDlg的头文件中添加以下变量:
CGridingDlg的头文件中添加以下变量:






(4)重载对话框类CGridingDlg的虚函数OnInitDialog(),添加WM_TIMER消息，
(4)重载对话框类CGridingDlg的虚函数OnInitDialog(),添加WM_TIMER消息，
CGridingDlg的虚函数OnInitDialog(),添加WM_TIMER消息，
添加函数SetupPixelFormat(HDC hDC)---->用于设置OpenGL的像素格式
添加函数SetupPixelFormat(HDC hDC)---->用于设置OpenGL的像素格式
添加函数SetupPixelFormat(HDC hDC)---->用于设置OpenGL的像素格式



在对话框上面添加一个Picture控件，用于显示图形，设置其ID为IDC_STATIC_PictureRender
在对话框上面添加一个Picture控件，用于显示图形，设置其ID为IDC_STATIC_PictureRender
在对话框上面添加一个Picture控件，用于显示图形，设置其ID为IDC_STATIC_PictureRender






添加InitializeOpenGL()函数用于在对话框中初始化OpenGL。
添加InitializeOpenGL()函数用于在对话框中初始化OpenGL。
添加InitializeOpenGL()函数用于在对话框中初始化OpenGL。















RenderScene()函数添加进去，每隔多少毫秒就调用RenderScene()，时间间隔设置的越少就可以形成连续绘制的效果
RenderScene()，时间间隔设置的越少就可以形成连续绘制的效果






RenderScene()函数中封装一个函数，将该函数放置于RenderScene()函数的绘图代码区就好了。
RenderScene()函数的绘图代码区就好了。
绘制的效果如下
绘制的效果如下
绘制的效果如下
绘制的效果如下
绘制的效果如下




















但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。


























































































由于需要在三维空间中进行三维模型的碰撞与相交，为了加快检测的效率，考虑用三维物体包围盒。AABB与OOBB包围盒比起来原理简单，容易实现，为了更好的在三维空间中使用AABB包围盒，所以自己写了一个关于三维的AABB包围盒类AABB类，写了不同参数的构造函数，以及关于AABB包围盒的各种成员方法，虽然不是很全，但是可以满足日常的需要。
下面贴代码：
AABB.h


原文地址：Graphics Software  http://www.dgp.toronto.edu/~rms/links.htmlGraphics Software
贴出来贴出来贴出来，防止自己忘掉。。。。

Shape Modeling
Texturing
突发奇想，想写一个轰炸自己QQ好友的聊天轰炸机，哈哈哈，看了半天自己就写了一个Low的聊天轰炸机，纯粹依靠剪切板往聊天窗口复制文字，然后模拟回车按钮完成发送，写了一个简单的MFC对话框Demo，大牛自动跳出，无需再看。
主要代码如下：



1.单独拉出你想轰炸的QQ好友的聊天窗口，不要合在一起；
2.设置你想轰炸的QQ好友的昵称，就是你前面拉出来的单独的会话窗口好友的昵称；
3.选择你的BOOM.txt文件，里面是你想轰炸别人的话；
4.设置轰炸的次数。
截图如下：






源码链接：源码链接，Debug和Release版本，里面自带了我自己写的BOOM.txt




主要用到OpenCV自带的CascadeClassifier这个类下的detectMultiScale函数，其检测效果并不是很好
    

（1）静态图片上的人脸检测





可以看出，有些人脸没有检测出来，或者是检测出来有位置错误。
（2）摄像头人脸检测

问题描述：判断一个数是不是回文数。
回文数：就是从左往右念和从右往左念都是一样的，对称的一个数，如121,789987等。
注意：负数不是回文数，如-121。
解题思路一：如果一个数倒序输出后还等于原始的值，那么该数为回文数。
解题思路2：如果一个数最左边的数等于最右边的数，然后再去除这两个数，然后再判断最左边的数依然等于最右边的数，直到最后一个数，那么该数为回文数。


在leetcode里面提交的结果是第一种方法貌似比第二种要快。
用惯了AfxMessageBox（），总感觉这个东西不那么顺手，就想在状态显示当前程序的提示信息。
想要在任何类中都设置状态栏的信息，必须获取到m_wndStatusBar的指针。
所以第一步，将CMainFrame中的m_wndStatusBar的保护类型从保护改为public
m_wndStatusBar的保护类型从保护改为public




第二步：在任意类中添加下列代码，改变状态栏的提示信息



参考书籍：数据结构（C++版）陈宝平主编
参考链接：http://www.cnblogs.com/charley_yang/archive/2010/12/08/1900256.html
二叉树类封装以及代码

题目描述：反转整数输出，注意的是输入被假定为一个32位有符号整数。当反整数溢出时，函数应返回0。
  今年的华为的实习生招聘笔试的第一个题与这个有点类似，不过华为的是输入两个整数，反转，然后输出两个整数反转后两个数的和。
  测试代码：

最近有小伙伴在问，我想显示一个求得的三维点云中的每一个点的法向量的指向，怎么获得这种逼真的三维显示效果呢？当然是OpenGL啦，也是我自己用的比较习惯，所以就花了十几分钟帮助上面提问的小伙伴解决问题，然后也提供给大家一个查看三维点云法向量的工具，稍后我会在我的ＣＳＤＮ的下载频道上传该软件的Ｒｅｌｅａｓｅ版本供大家使用，主要的显示效果是三维点云中的每一个点使用实心球体表示，法向量用一个方向箭头和圆锥体表示，类似于坐标轴的指向。主要用到三个函数，Render3DCylinder（在任意两个三维点间画圆柱体），Render3DSphere（以任意三维点为中心画球体），Render3DCone（在任意两个三维点之间画圆锥体）。
其三个函数的主要代码如下：






整个程序的源码由于项目的关系不能给出，只能给出发布版本，不过主要的核心的功能是利用上述的三个函数实现的。相应的程序的Realease版本的下载地址：[免费]OpenGL+MFC显示三维点云中每一个点的法向量，Release版本-CSDN下载  http://download.csdn.net/download/hw140701/9970732http://download.csdn.net/download/hw140701/9970732



自己封装的三维向量类Vector.h,包含一些常见的三维向量类的操作符重载和一些基本运算，可以直接复制粘贴作为头文件包含在项目文件中。

Win32编译环境下，用ADO数据库连接Access数据库一般都不会报错，但是最近由于项目上的需要，程序需要编译成64位以便申请到更多的使用内存空间，当把编译方式从Win32改为x64的时候，突然出现了数据库连接出现未知错误，这时候就猜到了应该是编译环境的改变导致了数据库连接出错，在参考了其他大神的解决方案之后，终于解决了这个问题,我的环境为Win7
 64+MFC(VS2010)+ADO+Access2007。
    参考链接如下：
    http://blog.csdn.net/sundacheng1989/article/details/17925431
    http://www.cnblogs.com/bluedoctor/p/3925871.html
    http://blog.csdn.net/kirawoo/article/details/39032387
    http://blog.csdn.net/u010891996/article/details/12522911


解决方法：
步骤1：去官网下载AccessDatabaseEngine_64.exe,下载链接
https://www.microsoft.com/zh-cn/download/details.aspx?id=13255
或者直接去我的下载频道进行下载
http://download.csdn.net/detail/hw140701/9830665





步骤2:这一个步骤是强制安装刚刚下载的AccessDatabaseEngine_64.exe，如果不强制安装的话，它会要求你卸载你所安装的全部的Office软件，那多麻烦！！！，所以选择忽略提醒，强制安装，
AccessDatabaseEngine_64.exe，如果不强制安装的话，它会要求你卸载你所安装的全部的Office软件，那多麻烦！！！，所以选择忽略提醒，强制安装，
打开cmd.exe,在命令行输入“你的AccessDatabaseEngine_64.exe的存放路径” /passive，比如我的就是"F:\软件\我下载的\Windows数据库编程\AccessDatabaseEngine_64.exe"
 /passive强制安装，输完这个命令就等待安装完成。
打开cmd.exe,在命令行输入“你的AccessDatabaseEngine_64.exe的存放路径” /passive，比如我的就是"F:\软件\我下载的\Windows数据库编程\AccessDatabaseEngine_64.exe"
 /passive强制安装，输完这个命令就等待安装完成。
AccessDatabaseEngine_64.exe的存放路径
AccessDatabaseEngine_64.exe
步骤3：在安装完上述引擎之后，你需要修改一下你的代码，在win32编译环境下我们的数据库的链接字符串是
步骤3：在安装完上述引擎之后，你需要修改一下你的代码，在win32编译环境下我们的数据库的链接字符串是
m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%s",databaseName);

如果你需要在x64的编译环境环境下连接Access数据库你需要修改为
如果你需要在x64的编译环境环境下连接Access数据库你需要修改为
m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

为了更好的适配不同的编译环境，我将我的代码修改为
为了更好的适配不同的编译环境，我将我的代码修改为


m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);
当是32位程序的时候就为
当是32位程序的时候就为
当是32位程序的时候就为
m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);








然后重启一下PC，应该就可以编译成功了。
然后重启一下PC，应该就可以编译成功了。
然后重启一下PC，应该就可以编译成功了。
然后重启一下PC，应该就可以编译成功了。




这两天有个筒子叫我帮他爬这个网站http://bbs.baobeihuijia.com/forum-191-1.html上的失踪儿童信息，准备根据失踪儿童的失踪时的地理位置来更好的寻找失踪儿童，这种事情本就应该义不容辞,如果对网站服务器造成负荷，还请谅解。


这次依然是用第三方爬虫包BeautifulSoup，还有Selenium+Chrome，Selenium+PhantomJS来爬取信息。
通过分析网站的框架，依然分三步来进行。
第一步：获取http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接
http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接
第二步：获取每一个分页链接上所发的帖子的链接
第二步：获取每一个分页链接上所发的帖子的链接
第三步：获取每一个帖子链接上要爬取的信息，编号，姓名，性别，出生日期，失踪时身高，失踪时间，失踪地点，以及是否报案
第三步：获取每一个帖子链接上要爬取的信息，编号，姓名，性别，出生日期，失踪时身高，失踪时间，失踪地点，以及是否报案
起先用的BeautifulSoup，但是被管理员设置了网站重定向，然后就采用selenium的方式，在这里还是对网站管理员说一声抱歉。
1、获取http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接
获取
http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接




通过分析：发现分页的页面链接处于<div class="pg">下，所以写了以下的代码
通过分析：发现分页的页面链接处于<div class="pg">下，所以写了以下的代码
BeautifulSoup形式：


2.获取每一个分页链接上所发的帖子的链接
2.获取每一个分页链接上所发的帖子的链接
获取每一个分页链接上所发的帖子的链接






每个帖子的链接都位于href下
每个帖子的链接都位于href下
每个帖子的链接都位于href下
所以写了以下的代码：
所以写了以下的代码：
所以写了以下的代码：
BeautifulSoup形式：
BeautifulSoup形式：
BeautifulSoup形式：



获取每一个帖子链接上要爬取的信息，编号，姓名，性别，出生日期，失踪时身高，失踪时间，失踪地点，以及是否报案，并写入CSV中








通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
BeautifulSoup形式：
BeautifulSoup形式：
BeautifulSoup形式：
BeautifulSoup形式：




现附上所有代码，此代码仅供参考，不能用于商业用途，网络爬虫易给网站服务器造成巨大负荷，任何人使用本代码所引起的任何后果，本人不予承担法律责任。贴出代码的初衷是供大家学习爬虫，大家只是研究下网络框架即可，不要使用此代码去加重网站负荷，本人由于不当使用，已被封IP，前车之鉴，爬取失踪人口信息只是为了从空间上分析人口失踪的规律，由此给网站造成的什么不便，请见谅。








附上所有代码：
附上所有代码：
附上所有代码：
附上所有代码：




































配置步骤
1.在pycharm编译其中按上一篇文章简单粗暴：使用pycharm安装对应的Python版本第三方包，在包的搜索窗口输入Selenium，然后点击Install Package即可。




2.下载最新版本的Chrome浏览器安装


3.下载最新版本ChromeDrive.exe
可进入以下网址进行下载
http://chromedriver.storage.googleapis.com/index.html

下载下来为一个压缩包文件，解压缩，得到chromedrive.exe
chromedrive.exe


4.将下载的最新版本的chromedrive.exe拷贝到你的python3.x的安装目录，或者是C:Windows目录下
整个Selenium+Chrome的环境配置就完成了
我的python3.x安装路劲为：C:\Users\Administrator\AppData\Local\Programs\Python\Python35\




到这里整个Selenium+Chrome环境配置就完成了，快使用下列代码打开你的浏览器吧

5.上面代码每次都会打开一次Chrome浏览器，但是假如我们循环次数较多时，每次都打开一次浏览器会干扰我们在桌面上的其他工作，所以这里介绍一个无界面的浏览器包PhantomJS
首先在官网下载地址：http://phantomjs.org/download.html
或者CSDN下载频道以往版本：http://download.csdn.net/detail/tylanbin/7211747
然后得到压缩包，解压，将里面的PhantomJS.exe文件复制到你的python安装路径或者C:windows下，只要是系统的环境path目录都行
PhantomJS.exe文件复制到你的python安装路径或者C:windows下，只要是系统的环境path目录都行
然后只需要把上面driver=webdriver.Chrome()改成driver=webdriver.PhantomJS()即可


driver=webdriver.PhantomJS()即可
PhantomJS


Meshlab是一个强大的三维模型处理的软件，在三维点云的处理方面也十分强大，不仅仅可以用三维点云重构出三维模型，还可以计算出三维点云每个点的法向量，这在逆向工程和基于三维点云的隐式曲面重建中非常有用。
   我的Meshlab的版本是3.3，可以在网上自行下载破解版。
1.Meshlab读取三维点云
第一步：打开Meshlab软件
第二步：点击File菜单下的ImportMesh导入txt文档，需要选择你的txt文档中XYZ坐标之间的分隔符，导入成功后会显示你的三维点云数据
2.三维点云重建
点击下图图标，弹出右侧图层侧边栏
然后点击Fiter菜单下Normals，Curtavures and Oreientation下的Smooths normals on a point set计算三维点云的法向量，如下图
然后设置计算点云法向量的参数，默认就好，如有需要可以自行设置，点击Apply等计算完成然后点击Close关闭对话框
计算完点击法向量之后，点击Filter菜单下Remeshing Simplication and Reconstruction下的Surface Reconstruction：Ball Pivoting进行三维点云重建
然后设置三维点云重建参数，默认就好，也可以自行设置，点击Apply等重建完成，点击close关闭对话框
然后点击下列图标显示重建的三维模型，也可以设置光照等其他参数
以下为三维重建结果
3.法向量的导出与计算
三维点云的法向量的导出与计算有两种方式，一种是在上一节三维重建中我们已经得到了重建后的三维模型，那么每个点都带有法向量，可以直接导出即可，还有一种就是从杂乱的三维点中计算每一个三维点的法向量
3.1从三维模型中导出三维点云中每个点的法向量
接着第二节的步骤，点击File菜单下Export Mesh as 
然后在接下来的对话框中选择xyz格式
然后在 接下来的对话框中勾选Normal就可以生成文本格式的三维点以及三维点法向量
以下为文本格式的三维点坐标以及三维点法向量的结果
3.2 直接从三维散乱点云中生成三维点的法向量
然后点击Filter菜单下Normals，Curtavures and Oreientation下的Compute normals for point set计算三维点云的法向量，如下图
在弹出来的对话框可以自行设置参数，先Apply然后再Close
法向量的导出与3.1中的一样，可以自行参考。


以下为三维点云以及点云的法向量的可视化结果，点云表示为红色的点，法向量表示为绿色的线段
在程序开发中我们经常看见有一些软件左侧有目录树或者是图层树，点击之后就可以右侧View窗口显示相关的内容，其实实现这种机制有两种方法，第一种就是对MFC的View窗口进行窗口分割，左侧的窗口view类派生于CTreeView，其中CTreeView自带一个变量用于View中的树控件的控制。第二种方法就是用一个可停靠的面板嵌套一个对话框，再在对话框中添加树控件，同样可以达到相同的目的。
以下详解搭建步骤：
第一步：在VS2010中生成一个MFC经典风格的单文档程序，命名为CMyTestMFCDlg，编译下保证没有出错。

第二步：为该工程添加一个新类CMyDockablePane，派生于CDockablePane。



第三步：新建上述类完成后，在CMainFrame头文件中包含该类的头文件#include
 "MyDockablePane.h"
   声明该类的对象：



编译运行：


第四步：插入一个新的对话框，命名为IDD_DIALOG_DOCKDIALOG，在对话框属性中将Style设为Child，Border设为None。
为该对话框新建类：CDockDialog，基类为CDialogEx。
添加一个树控件，IDC_TREE_Test，为树控件关联一个控件变量m_TreeControl
在MyDockablePane.h中包含头文件#include
 "DockDialog.h"
添加CDockDialog
 类的成员变量：CDockDialog m_TestDlg;
添加CMyDockablePane的WM_CREATE和WM_SIZE消息响应函数
在函数中添加以下代码

CDockDialog类中重载虚函数OnInitDialog()，添加以下代码初始化树控件

CDockDialog头文件中添加#include "resource.h"




最后即可编译成功
最后即可编译成功






在网上看见一个对3D建模介绍十分全面的博客，来自中国科技大学图形与几何计算实验室刘利刚老师，介绍的非常棒，膜拜一下。
此处注明转载博客网址：3D建模与处理软件简介-中国科技大学刘利刚
3D建模与处理软件简介
刘利刚
中国科技大学
http://staff.ustc.edu.cn/~lgliu
 
【前言】自半年前笔者发表博客“什么是计算机图形学”以来，时常有人来向笔者询问3D模型的构建方法与工具。
笔者的研究方向是以3D技术为主，具体包括3D建模，3D处理及3D打印三个方面，在3D建模与处理方面从事了
十多年的研究，接触过很多3D相关的软件，在这方面有些经验。因此，特撰写此文，以帮助我们的学生及关注3D
技术的人了解3D建模和3D技术。本文仅仅为笔者根据自己的经验对3D建模与处理软件浅薄的理解，不涉及对技术
的深入讨论，是非学术性的。因此，笔者尽量尝试用通俗的语言介绍一下各种3D建模的软件和工具，以帮助还未接
触3D技术的学生来了解这些工具，以便在今后的科研和工作中能够选择合适的3D工具。笔者对本文的有些内容的理
解也是很有限的，值得进一步的学习和交流。有不当之处，还请读者谅解指正。
 
 
一、           专业3D建模软件
 
1.       3DS
 Max
美国Autodesk公司的3D
 Studio Max（前身是Discreet公司的，后被Autodesk收购）是基于PC系统的三维建模、动画
、渲染的制作软件，为用户群最为广泛的3D建模软件之一。常用于建筑模型、工业模型、室内设计等行业。因为
其广泛性，它的插件也很多，有些很强大，基本上都能满足一般的3D建模的需求。我们的学生也需要经常用到3DS
Max来构建模型。网上关于3DS
 Max的教程和学习视频非常多，使用者众多。
 
2.       Maya
Maya也是Autodesk公司出品的世界顶级的3D软件，它集成了早年的两个3D软件Alias和Wavefront（这两个软件在我
读博时就非常有名，当时就代表了最先进的动画及数字技术，我曾用过Wavefront）。相比于3DS
 Max，Maya的专
业性更强，功能非常强大，渲染真实感极强，是电影级别的高端制作软件。在工业界，应用Maya的多是从事影视
广告，角色动画，电影特技等行业。我们的学生也经常用Maya来制作和渲染3D模型，生成漂亮的渲染结果放在论
文中。
 
3.       Softimage
Softimage曾经是加拿大Avid公司旗下的专业的3D动画设计软件，后被Autodesk收购。它在影视动画方面，特别是
角色功能非常强大。许多电影，比如《泰坦尼克号》、《失落的世界》、《第五元素》等，都曾使用Softimage来
制作大量的惊人的视觉效果。
 
4.       LightWave
LightWave是美国NewTek公司开发的一款3D动画制作软件，具有悠久的历史，我在读博时曾接触过。它的功能非
常强大，特别是在生物建模和角色动画方面功能异常强大，广泛应用在电影、电视、游戏、网页、广告、印刷、
动画等各领域。在电影《泰坦尼克号》中细致逼真的船体模型及其他众多游戏的场景和动画都曾使用LightWave
来制作的。
 
5.       Rhino（犀牛）
Rhino是美国Robert
 McNeel公司开发的专业3D造型软件，它对机器配置要求很低，安装文件才几十兆，但“麻雀虽
小，五脏俱全”，其设计和创建3D模型的能力是非常强大的，特别是在创建NURBS曲线曲面方面功能强大，也得到
很多建模专业人士的喜爱。在与上海造船厂研究所的合作项目中，我们用Rhino来进行船体曲面的NURBS建模和修
改，非常方便灵活。
 
6.       Cinema
 4D
Cinema 4D (C4D)是德国Maxon公司的3D创作软件，在苹果机上用得比较多，特别是在欧美日为最受欢迎的三维动
画制作工具。2009-2010年我在美国哈佛大学访问期间，经常看到学生用C4D在进行3D建模和动画的设计。
 
7.       Creator
MultiGen-Paradigm公司开发的Creator是专门创建用于大型3D虚拟仿真的实时三维模型的软件。其强大之处在于管
理3D模型数据的数据库，使得输入、结构化、修改、创建原型和优化模型数据库非常容易。前几年与一家从事数
字城市的公司合作时我们就用Creator快速创建大量的城市建筑模型，并且生成数据库来管理这些模型，还是相当
的方便。
 
注：从上述介绍可知，美国Autodesk公司当之无愧是当今3D建模和动画的“老大”，拥有3DS
 Max、Maya和Softimage等
3D建模和动画专业软件。3DS
 Max和Maya在3D建模方面各有特色，前者更为大众化些，相对容易掌握些，后者在专
业级的行业应用更为广泛，特别在制作动画和高质量渲染方面强于前者。我们的学生用Maya的相对多些，包括建模，
渲染和动画制作。Softimage和LightWave在3D动画方面表现强大。Rhino对NURBS曲面的支持更好。Creator适合于构
建大量的3D模型并构建数据库进行管理和修改。
 
 
二、           CAD建模和产品设计软件
 
1.       AutoCAD
AutoCAD (Auto Computer-Aided Design)是美国Autodesk公司出品的自动计算机辅助设计(CAD)软件，用于二维绘图
、文档规划和三维设计。适用于制作平面布置图、地材图、水电图、节点图及大样图等。广泛应用于土木建筑、装
饰装潢、城市规划、园林设计、电子电路、机械设计、航空航天、轻工化工等诸多领域。大家买房时看的房型图大
部分都是用AutoCAD来做的。
 
2.       CATIA
Catia由法国Dassault
 Systems公司开发的CAD/CAE/CAM一体化的三维软件，支持产品开发的整个过程，从概念(CAI
D)，到设计(CAD)，到分析(CAE)，到制造(CAM)的完整流程。可帮助制造厂商设计未来的产品，并支持从项目前阶
段、具体的设计、分析、模拟、组装到维护在内的全部工业设计流程，在机械行业，航空航天、汽车工业、造船工
业等应用广泛。其实体造型和曲面设计的功能非常强大。我读博期间曾接触过Catia，在它上面写过一个NURBS曲
面转换的插件程序。
 
3.       SolidWorks
SolidWorks是世界上第一个基于Windows开发的三维CAD系统，后被法国Dassault
 Systems公司(开发Catia的公司)所
收购。相对于其他同类产品，SolidWorks操作简单方便、易学易用，国内外的很多教育机构（大学）都把SolidWork
s列为制造专业的必修课。SolidWorks在杭州有专门的研发机构，我有个学生硕士毕业后在那里进行研发工作。
 
4.       UG
 NX
UG NX由美国Unigraphics
 Solutions (UGS)公司开发的CAD/CAE/CAM一体化的三维软件，后被德国西门子公司收购
。广泛用于通用机械，航空航天、汽车工业、医疗器械等领域。现在西门子公司在上海有专门的研发机构对UG
 NX
产品进行升级完善，我有2个学生博士毕业后在那里负责产品的开发和维护。
 
5.       Pro/E
Pro/Engineer是美国PTC公司(Parametric
 Technology Corporation)旗下的CAD/CAM/CAE一体化的三维软件。在参数化
设计，基于特征的建模方法具有独特的功能，在模具设计与制造方面功能强大，机械行业用的比较多。
 
注：除了上述所介绍的CAD/CAE
 /CAM系统软件（它们各有特色，在市场中都占有一定的份额）外，还有其他一些同
类产品，比如法国Missler公司的Topsolid和以色列Cimatron公司的Cimatron。一般在机械设计与产品研发相关的行业中
才会接触到这些软件，专业性比较强，在网上很容易能找到它们的相关资料。
 
 
三、           3D雕刻建模软件：笔刷式高精度建模软件
 
3D雕刻建模软件(Sculpturing
 modeling)，也称为笔刷式高精度建模软件，顾名思义，就是像艺术家那样用不同的“笔
刷”工具在模型表面上进行“雕刻”的自由创作。建模过程就像玩橡皮泥一样，利用拉，捏，推，扭等操作来对几何
进行编辑，生成任意的高度复杂和丰富的几何细节（如怪兽的复杂表面细节）。这些工具的出现颠覆了过去传统三
维设计工具的工作模式，解放了艺术家们的双手和思维，告别过去那种依靠鼠标和参数来笨拙创作的模式，完全尊
重设计师的创作灵感和传统工作习惯。
 
1.       ZBrush
美国Pixologic公司开发的ZBrush软件是世界上第一个让艺术家感到无约束自由创作的3D设计工具。 ZBrush能够雕刻
高达 10 亿多边形的模型，所以说限制只取决于的艺术家自身的想象力。
 
2.       MudBox
MudBox是Autodesk公司的3D雕刻建模软件，它和ZBrush相比各有千秋。在某些人看来，MudBox的功能甚至超过了
ZBrush，可谓ZBrush的超级杀手。
 
3.       MeshMixer
最近，Autodesk公司又开发出一款笔刷式3D建模工具MeshMixer，它能让用户通过笔刷式的交互来融合现有的模型
来创建3D模型（似乎是类似与Poisson融合或Laplacian融合的技术），比如类似“牛头马面”的混合3D模型。
值得注
意的是，最新版本的
MeshMixer
还添加
3D
打印支撑优化新算法，值得关注。我们
Siggraph
 Asia 2013
的论文“
Cost-effe
ctive
 Printing of 3D Objects with Skin-Frame Structures
”也给出了一种为
3D
打印加尽可能少的支撑材料的新算法（详
见我的博文“
经济节约型的3D打印技术
”），该算法也是具有较好的市场前景，我们也在努力进行产业转化。
 
4.       其他
其他还有一些同类的3D雕刻建模软件，比如3DCoat，Sculptris，Modo等。这里就不再详细介绍了。
 
注1：在工业界，人们更偏向于使用四边形网格(quad
 mesh)，而不是三角网格，一个很重要的原因就是这些雕刻建模
工具善于在四边形网格上进行细节的生成和编辑，因为四边形网格的边更能反应物体表面的流线方向(edge
 flow)。我
们Pacific Graphics 2010的一篇论文B-mesh，就是在建模过程中同时生成具有良好流线方向的四边形基网格(base
 mesh)，
然后直接可以导入到这些雕刻软件中进行进一步的细节雕刻建模。
 
注2：虽然这些笔刷式建模工具上手容易，给了用户便利的方式进行3D细节建模，但是，要想真正构建一个细节复杂
和逼真的3D模型还是不容易的，除了用户需要熟练掌握软件的各种工具及雕刻技巧外，还需要用户具有较好的艺术和
绘画功底。
 
 
四、           基于草图的3D建模软件
 
基于笔划或草图的交互方式由于其符合人类原有日常生活中的思考习惯，交互方式直观简单（就像在图纸上画画
一样来构建3D模型），是最近十多年来计算机图形学中研究的热点建模方法之一。这方面的研究论文有很多，比
如Siggraph 1999年的Teddy，到Siggraph
 2006年的SmoothSketch，Graphics
 Interface 2007的Magic Canvas，Siggraph 
2007年的FiberMesh，SigCHI
 2010年的ICanDraw等。最近，我们也提出一种基于阴影引导的草图交互的3D建模的
技术“Modeling
 by Drawing with Shadow Guidance”，从已知的模型数据库中提取信息来引导用户的笔划交互，能构
建更为精准的3D模型，该工作发表在Pacific
 Graphics 2013上。
虽然在科研上提出了很多基于草图的
3D
建模技术，
但是至今仍未能有比较成熟的商业化的软件出现，可能是因为要理解不同用户的划线和草图还是一件比较困难的
事情。对于一些比较规则的物体，比如建筑、家具等人造物体，这种方式相对可行些，比如
Google
的
SketchUp
（在
国内我们也称为“草图大师”）。
SketchUp
是一套面向普通用户的易于使用的
3D
建模软件。使用
SketchUp
，创建
3D
模型就像我们使用铅笔在图纸上作图一般，软件能自动识别你画的这些线条，加以自动捕捉。它的建模流程简单
明了，就是画线成面，而后拉伸成体，这也是建筑或室内场景建模最常用的方法。
SketchUp
还可以将你自己的制
作成果发布到
Google
 Earth
上和其他人共享，或者是提交到
Google
的
3D
 Warehouse
（
Google
的
3D
模型库）。当然你
也能从
Warehouse
那儿得到想要的素材，以此作为创作的基础。很有趣的是，在
2012
年
Google
公司的
SketchUp
被美
国
Trimble
公司收购了。去年出了个
Trimble
 SketchUp 2013
，网评似乎不太好。不知其是否能继续免费。
最近国内出
了一款叫做“
EasyToy
”的采用草图式的
3D
建模软件，适用于卡通动漫形象与玩具的设计。但我还没有试用过，不知
用户体验如何。另外，日本东京大学的
Takeo
 Igarashi
教授也发布了一些基于草图式的
3D
建模系统，比如
Teddy
，在
其主页上可以下载到。
另外，值得一提的是，基于草图的交互方式在现在正在兴起的
Web3D
建模领域会有新的广阔
空间。
Web3D
建模在稍后会介绍。
 
 
五、           基于照片的3D建模软件
 
从物体的照片来进行3D模型的构建，是计算机图形学和计算机视觉的一大研究方向，称为基于图像的几何建模(Ima
ge based modeling)。这种技术已逐渐成熟且走向实用阶段，最近有些软件能够让用户拿着普通相机或者手机对着要
建模的实物从不同视角拍摄若干照片，然后软件就能根据这些照片自动地生成相应的3D模型。这种基于
图片的建
模技术提供给了非专业建模人士来构建
3D
模型的工具。
 
1.       Autodesk
 123D
Autodesk公司最近发布了一套平民级的建模软件Autodesk
 123D，用户不需复杂的专业知识，只要为物体从不同的
视角拍摄几张照片，该软件就能自动地为其生成3D模型，而且软件是完全免费的。
(1)    Autodesk
 123D是一款免费的3D CAD 工具，用户可以使用一些简单的图形来设计、创建、编辑三维模型，或者
在一个已有的模型上进行修改。
(2)    Autodesk
 123D Catch是建模软件的重点，用户使用相机或手机来从不同角度拍摄物体、人物或场景，然后上传
到云，然后该软件利用云计算的强大计算能力，可将数码照片中几分钟的时间内转换为3D模型，而且还自动带上
纹理信息。我们试用过几次，感觉它的使用还是很方便的。但是其生成的3D几何的细节不多，主要是通过纹理信
息来表现真实感的。有时软件也会失败，生成的几何是不正确的。
(3)    Autodesk
 123D Make是将3D模型转换为2D的切割图案，用户可利用硬纸板、木料、金属或塑料等低成本材料
将这些图案迅速拼装成实物，从而再现原来的数字化模型。这让用户能够“制造”出所造的3D模型，有点像3D打印
的雏形。目前123D Make只有Mac版的。
(4)    Autodesk
 123D Sculpt是一款运行在iPad上的3D雕刻软件（前面已介绍过），通过绘画的方式在模型上雕刻
几何细节。
 
2.       3DSOM
 Pro
3DSOM Pro是一款从高质量的照片来生成3D建模的软件，它可以通过一个真实物体的照片来进行3D建模，并且制
作的模型可以在网络上以交互的方式呈现。
 
3.       PhotoSynth
微软开发了一款产品PhotoSynth，可将大量的照片做3D处理，但是它不是真正创建3D模型，而是根据照片之间的
相机参数及空间对应关系，建构一个虚拟的3D场景，使得用户能够在从不同角度和位置来查看该场景，而显示的
场景图像是由给定的照片所合成的。其基本原理来自于Siggraph 2006的论文“Photo
 Tourism: exploring photo colle
ctions in
 3D”及其他相关论文。
 
注：从多幅不同角度拍摄的照片来重建3D物体，从技术原理上来讲是可行的，但是由于算法的一些步骤，比如图像
中物体特征点的检测和匹配，相机参数的估计等，还会出现不太正确的结果，使得重建结果有时不够稳定，甚至不
正确。随着技术和计算能力的不断发展，相信这些会逐步得到解决。到时，从照片来重建3D模型的技术可能是最为
方便的3D建模技术了，因为人人都有手机，随时都可以拍照上传到云端来构建3D模型。如果有了大数据库的支持，
从单张照片来构建3D模型也是可能的，可以参看我们的Siggraph
 2011的论文。
 
 
六、           其他3D建模软件
 
1.       人体建模软件
关于构建人体模型及动画，首推Metacreations公司的Poser软件（俗称“人物造型大师”）和开源的MakeHuman软件
。这两款软件都是基于大量人类学形态特征数据，可以快速形成不同年龄段的男女脸部及肢体模型，并对局部体
形进行调整。可以轻松快捷地设计人体造型、动作和动画。我读博期间用过Poser构建人体模型来做morphing，
还是蛮方便的。
 
2.       城市建模软件
加拿大Esri公司的CityEngine是三维城市建模的首选软件，可以利用二维数据快速创建三维场景，并能高效的进行
规划设计。应用于数字城市、城市规划、轨道交通、管线、建筑、游戏开发和电影制作等领域。另外，CityEngine
对ArcGIS的完美支持，使很多已有的基础GIS数据不需转换即可迅速实现三维建模，缩短了三维GIS系统的建设周
期。该软件的核心技术是Siggraph 2001的论文“Procedural
 Modeling of Cities”及其他相关论文，早期是ETH Zurich
大学的Pascal Mueller研究小组创办的Procedural公司开发的，后被Esri公司收购。
 
3.       其他小巧的3D建模软件
下面的这个网页还介绍了一些其他3D建模相关的软件或程序：
http://tech.sina.com.cn/s/2008-10-20/08192519895.shtml
这些软件大部分都非常小巧，而且是开源且完全免费的。有很多媒体工作者和艺术家用这些小软件来制作3D作品
，其中Blender, K-3D, Art of Illusion, Seamless3d,
 Wings3D等软件的使用面稍微广泛些。有兴趣的读者可以到网上找
到相关资料去了解和学习，这里不作详细介绍。
 
4.       网页3D
 (Web3D)建模工具
最近，出现了一些基于网页(web)开发的3D模型设计软件，即基于WebGL，可以在浏览器中完成3D建模的工具。
比如3DTin，TinkerCAD（去年被Autodesk收购）等，它们的界面简单直观，有Chrome等浏览器插件插件，可以在
线生成3D模型，直接存在云端，并在社区分享模型。
在互联网的时代，
Web3D
技术将被越来越被广泛使用，建议
大家多关注。
 
 
七、           虚拟现实软件和平台
 
虚拟现实软件本质上不是用于3D建模的，而是用来对生成好的3D模型和场景提供关于视觉、听觉、触觉等虚拟的
模拟，让用户如同身历其境一般。相关软件也有很多，这不是本文的重点，只大致提及几个比较常见的。
 
1.       VirTools和Quest3D
法国VirTools公司的VirTools和美国Act-3D公司的Quest3D都是元老级的虚拟现实制作软件，简单来说，就是工业
或游戏用的实时图形渲染引擎，是3D虚拟和互动技术的集成工具。可以让没有程序基础的美术人员利用内置的行
为模块快速制作出许多不同用途的3D产品，如网际网络、计算机游戏、多媒体、建筑设计、交互式电视、教育训
练、仿真与产品展示等 。网上的学习资料比较多。
 
2.       Unity3D
 (U3D)
Unity Technologies开发的Unity3D
 (U3D)是最近几年冒出来的新秀，是一个全面整合的专业虚拟3D和游戏引擎。
它在制作虚拟现实及3D游戏方面上手非常容易，操作简单，互动性好，有强大的地形渲染器。我们的学生使用
U3D可以很快地制作一个3D游戏，因此也强烈推荐大家学习使用。
 
3.       Vega
Vega是MultiGen-Paradigm公司开发的用于实时视觉模拟和虚拟现实应用的开发引擎，提供很多的C/C++语言的应
用程序接口API，结合其应用程序的图形用户GUI界面软件LynX，可以迅速创建各种实时交互的3D环境。对于开
发3D游戏和3D场景漫游的项目非常方便。
 
4.       OSG
 (Open Scene Graph)
OSG (Open Scene Graph)是一套开源的基于C++平台的应用程序接口API，能够让开发者快速、便捷地创建高性能
、跨平台的交互式图形程序。它将3D场景定义为空间中一系列连续的对象，能够对3D场景进行有效的管理。由于
OSG是开源和完全免费的，很多3D应用的软件都选用OSG作为基础架构。几年前，我们与一个公司合作开发的义
齿软件就选用OSG作为管理3D数据的框架，使得开发非常方便。
 
5.       其他
其他的一些用于3D应用程序开发的软件开发包(SDK)或API还有GLUT(OpenGL
 Utility Toolkit), OpenGL Performer, 
CG2 VTree, Quamtum3D Mantis等。有兴趣的读者也可以去了解一下。
 
注：相比于十年前，由于有了上述开发平台和开发包，现在开发一个看起来还比较cool的3D应用程序或游戏不是那么
困难，随着技术的不断发展和3D应用不断渗入到各行各业，相信以后会更加方便。
 
 
八、           开源3D网格处理库
 
1.       PCL
 (Point Cloud Library)
Point Cloud Library (PCL)是一个独立的大型跨平台的处理二维/三维图像和点云数据的C++模板库，它基于许多第三
方库，比如Boost、Eigen、FLANN、VTK、CUDA、OpenNI、Qhull等，实现了大量点云相关的通用算法和高效数
据结构，涉及到点云获取、滤波、分割、配准、检索、特征提取、识别、追踪、曲面重建（包括Poisson重建算法
）、可视化等。早期的PCL是由Dr.
 Radu Bogdan Rusu在德国慕尼黑工业大学读博士期间开发的，目的是要为三维
点云数据处理的研究及应用，建立出一个共同的基础架构。另外，PCL利用OpenMP、GPU、CUDA等先进高性能
计算技术，通过并行化提高程序实时性。集成了Kinect Fusion重建算法。有人将其地位比喻为3D的OpenCV，足以
可见其对3D的开发和研究的重要性，我们的学生在科研过程中经常用到PCL。
 
2.       CGAL
 (Computational Geometry Algorithms Library)
CGAL是一套开源的C++算法库，提供了计算几何相关的数据结构和算法，诸如三角剖分（2D约束三角剖分及二维
和三维Delaunay三角剖分），Voronoi图（二维和三维的点，2D加权Voronoi图，分割Voronoi图等），多边形，多
面体（布尔运算），网格生成（二维Delaunay网格生成和三维表面和体积网格生成等），几何处理（表面网格简
化，细分和参数化等），凸壳算法，搜索结构（近邻搜索，kd树等），插值，形状分析，拟合等。CGAL功能强
大，是我们学生做科研的必备程序库之一。
 
3.       MeshLab
MeshLab是一个开源的处理三角形网格的C++算法库，提供了三角网格的数据结构和算法，诸如曲面重建、编辑
、修复、光顺、编辑等算法。MeshLab也是我们学生做科研的必备程序库之一。
 
4.       其他开源网格处理库
OpenMesh：由德国RWTH
 Aachen大学的Leif Kobbelt研究小组开发的C++网格处理库
Libigl: 由瑞士Ethz大学的Olga
 Sorkine研究小组开发的C++网格处理库
Trimesh：有美国Princeton大学的Thomas
 Funkhouser研究小组开发的C++网格处理库
 
5.       网格剖分(Delaunay)与生成库
Triangle, NetGen：平面三角网格生成库
TetGen, Stellar：空间四面体网格生成库
 
注：这里列出了几个主要的网格处理的C++代码库，我们的学生在学习和科研的过程中会经常用到它们。当然，网上
还有其他的各种算法库，对我们的科研和开发都是非常有用，我们有时也会用到，这里就不再详述。
 
 
九、           基于扫描（逆向设计）的3D建模软件
 
随着深度相机的普及及扫描仪的价格迅速下降，人们采集三维数据变得容易，从采集到的三维点云来重建三维
模型的工作在最近几年的Siggraph(Asia)上能常见到，比如我们Siggraph
 Asia 2010，Siggraph
 2013等的工作。最近
几年产生了许多基于点云数据的建模与处理（或逆向工程和设计）的软件，而且各种扫描设备的生产厂商也会发
布相应的点云重建的软件。
 
1.       Geomagic
Geomagic (俗称“杰魔”) 包括系列软件Geomagic
 Studio、Geomagic Qualify和Geomagic
 Piano。其中Geomagic Studio
是被广泛使用的逆向工程软件，具有下述所有特点：确保完美无缺的多边形和 NURBS 模型处理复杂形状或自由
曲面形状时，生产效率比传统 CAD软件提高数倍；可与主要的三维扫描设备和CAD/CAM软件进行集成；能够作
为一个独立的应用程序运用于快速制造，或者作为对CAD软件的补充。是我们学生科研的必备软件之一。
 
2.       RapidForm
RapidForm是韩国INUS公司出品的逆向工程软件，提供了新一代运算模式，可实时将点云数据运算出无接缝的多
边形曲面，使它成为 3D扫描数据的最佳化的接口，是很多3D扫描仪的OEM软件。我们购买的Konica
 Minolta的激
光扫描仪Range 7就是用RapidForm来进行逆向设计。我们SGP
 2010的ARAP参数化算法作为目前为止最好的参数化
算法之一，被集成到了RapidForm软件中。
 
3.       ReconstructMe
ProFactor公司开发的ReconstructMe是一个功能强大且易于使用的三维重建软件，能够使用微软的Kinect或华硕的
Xtion进行实时3D场景扫描（核心算法是Kinect
 Fusion），几分钟就可以完成一张全彩3D场景。我们尝试过，效果
还可以。ReconstructMeQt提供了一个实时三维重建利用ReconstructMe
 SDK（开源）的图形用户界面。
 
注：法国ManCTL公司开发的Skanect为Mac平台的第一款3D 扫描软件，也支持者华硕的Xtion或者微软的Kinect进行
实时3D 扫描。
 
4.       Artec
 Studio
Artec公司出品的Artec
 Eva, Artec Spider等手持式的结构光3D扫描仪，重量轻且易于使用，成为许多3D体验馆扫描
物体的首选产品。我试用过Artec Eva后感觉还是需要较多的技巧才能扫描好物体，而且后期需要用软件进行较多
的处理，比如数据的去噪、修复、光滑、补洞等。
同时，
Artec
公司还开发了一款软件
Artec
 Studio
，可以和微软的
Kinect
或华硕的
 
Xtion
以及其他厂商的体感周边外设配合使用，使其成为三维扫描仪。
Kinect
通过
Artec
 Studio
可以
完成模型扫描，然后进行后期处理，填补漏洞、清理数据、进行测量、导出数据等。不确定它是否也使用了
Kinect 
Fusion
算法。
 
5.       PolyWorks
PolyWorks是加拿大InnovMetric公司开发的点云处理软件，提供工程和制造业3D测量解决方案，包含点云扫描、
尺寸分析与比较、CAD和逆向工程等功能。
 
注1：全球四大逆向工程软件除了Geomagic
 Studio和RapidForm外，还包括ImageWare和CopyCAD，由于后两者我不
熟悉，在此就不介绍了，有兴趣的读者可以到网上去找相关资料了解。
 
注2：微软的Kinect作为快速获取3D数据的传感器，可以作为3D扫描仪来使用，我们曾使用3台Kinects来扫描人体全
身，论文发在2012年的IEEE
 TVCG期刊。现在有多款软件或者开发库（包括上面介绍的PCL，ReconstrutMe，Artec
Studio，Skanect），支持将单台Kinect作为手持式扫描仪来扫描物体，其核心都是Kinect
 Fusion算法。
 
 
十、           后记
 
最近，随着人们对3D建模的需求越来越大，出现了许多其他形式的3D建模软件和工具，比如Blokify, 基于块状化
3D建模软件，特别适合孩子们制作模型。这些新出现的工具我这里就不一一介绍了，大家可以关注网上的一些科
技新闻网站、论坛或博客等。
 
 
1.       3D模型数据浏览与转换软件
上面介绍的大部分的软件或库都支持查看不同格式的3D模型数据。如果仅仅是浏览或查看现有的3D模型数据，我
个人推荐3D Exploration软件（相当于查看图像的ACDSee软件），它是一个专门用来查看各种格式的3D模型文件，
包括3DS数据 (*.3ds,
 *.prj, *.asc)、LightWave Objects (*.lwo,*.lw)、 DirectX(*.x)、AutoCAD
 (*.dxf)、Object File Fo
rmat (*.off)、Wavefront
 (*.obj)等，还可以用鼠标交互从不同视角来查看。而且还能查看各种图像文件，包括bmp
、rle、dib、gif、jpg、png、tif、tga、pcx等。当然也能查看带纹理的3D模型。3D
 Exploration是我的机器必装软件
之一，强烈推荐。另一个我推荐的同类软件是Deep Exploration，它除了可以浏览3D数据外，还可以转换数据格式
（最新版本还支持Sketchup文件），同时它还可以对你的模型进行编辑及添加注释制作动画等，我也强烈推荐。
注：现在有很多3D数据格式，几乎每个3D建模软件都会定义自己的数据格式。几种比较公认的3D数据格式有VR
ML、obj、off、stl
 (用于3D打印的数据格式)等。现在有些组织在力推3D数据的标准。相信随着3D技术的发展，这
些格式都将越来越标准化和统一化。对各种数据格式需要更多了解的，可以到网上找找，比如：
http://www.cnblogs.com/sunliming/archive/2012/02/28/2372398.html
 
 
2.       3D模型渲染软件
本文介绍的各种3D建模软件一般都能渲染3D模型，但要得到更为逼真的真实感渲染效果，还可以使用专门的3D
模型渲染软件，比如Pixar Renderman、POV-Ray、 V-Ray、 Mental
 Ray、Final-Render等，这里就不详细介绍。一
般我们使用Maya进行渲染放在论文中，已经足够漂亮了，读者可以在我们的许多论文中看到利用Maya渲染的结果
图。
 
3.       其他相关的软件
本文以介绍3D建模的软件和库为主，另外，还有许多跟3D技术相关的软件和开发包我没有提及，比如图像处理、
可视化、处理医学图像、建筑设计、装潢设计及艺术设计等。读者可以根据各自的专业去网上寻找所需要的专业
软件。
 
4.       学习使用3D建模软件
相比于2D平面软件Adobe
 Photoshop，Illustrator，CorelDraw等，学习3D软件难度稍大些，需要了解和掌握一些3D
的概念、3D交互习惯和技巧。因此，想要在短期熟练掌握好一个3D建模软件，是不太可能的，需要多用、多摸索
、多体会。网上有许多教材和视频，您可以跟着去学习。总之，您要多去玩，就能玩熟了。如果您能有个确定的
目标来学习3D软件，比如完成项目或者论文中所需要的效果，您就能掌握得更快！因为，带有确定目标和任务的
学习，是最高效的学习。但您如果暂时用不到，暂可不必花太多时间去学习，学了但不去用，也容易忘。只要您
学习软件的速度快就可以，而这正是我们对学生的基本要求。
 
5.       3D时代的来临
最近两年3D打印机的兴起，引起人们的极大好奇与广泛关注，同时也有些争论。虽然还不清楚它是否能成为人们
生活中不可或缺的一项技术，但不可否认，3D打印技术确实已经给世界带来巨变，已逐渐在某些领域表现出巨大
的价值，比如，提高了制造行业的生产力，在医学领域得到了广泛应用（义齿，假肢，器官等），为艺术家提供
了有效的创作工具等等。个人认为，3D打印提供给了平民零技能制造的技术，会朝着“私人定制”（个性化需求）
的方向发展；随着大量草根参与到3D的设计和制造，3D打印将逐步颠覆人们创造东西的能力。正因人们对3D模型
有了巨大的需求，3D打印技术才使得计算机图形学“落地”，这也使得我们这个学科终于在人们生活中体现了巨大
的价值。关于3D打印技术将给大规模工业经济带来的巨大冲击以及给我们的生活将带来的巨大变化，这里不展开
讨论，我将以后抽空撰文加以详述。
我们再来看一下这几年的一些巨头科技公司的变化，
2011
年微软公司的
Kinect
让人们获取
3D
数据的硬件代价降低了许多，
2012
年
3D
打印的兴起造就了两家上市公司
Stratasys
和
3D
 Systems
，
2013
年苹果公司收购了
Kinect
的核心技术公司
PrimeSense
，谷歌公司收购了大名鼎鼎的机器人公司
Boston
 Dynamics
，这
些都说明，越来越多的高科技企业在快速发展
3D
科技，
3D
时代已经来临！
随着人们对
3D
技术有了越来越多的需求，本文所介绍的
3D
建模工具将会发挥出更为巨大的价值。随着科学和技术的发展，云计算与物联网的进一步发展，将会出现越来越便利的
3D
建模工具，比如
Autodesk
 123D
正在将
3D
技术从专业变成非专业，人们接触
3D
技术的门槛将越来越低，创造的
3D
模型越来越丰富。我坚信，日后
3D
技术将“飞入寻常百姓家”，会越来越平民化，且成为人们生活中重要的一部分。
当然，当前人们对3D技术的了解还远远不够，大部分的人对3D技术仍然很陌生。另一个我个人看好的市场就是3D
教育与培训，普及3D技术与培养3D技术人才已时不我待。
另外，现在也开始有了一些
3D
模型共享的网站在运营，
能够提供给全世界的用户下载、上传、分享
3D
数据；类似于十多年随着
Internet
发展而产生的图像共享网站，这些
3D
数据共享网站也将在不久的未来产生巨大的价值，
3D
模型数据也将逐步进入“大数据时代”。
我们很庆幸成为
3D
科技新时代的弄潮儿，有很多的机会和挑战在等待着我们！让我们一起努力！
Python的强大除了其简单的语法以及易用性，还有其不得不说的海量的第三库的支持。
但是，我们电脑上由于需要可能安装了多个版本的Python，如Python2.X和Python3.X,这时候我们除了在电脑上要解决多个Python版本共存的问题，还需要针对不同的版本安装支持不同版本的第三方库，而且在安装第三方库的时候在cmd.exe上可能会出现输入字符错误，或者其他的错误，简而言之，就是没有交互式的界面，不能让人像傻瓜一样简单的安装第三方包，但是Pycharm这个强大的pythonIDE（集成开发环境）给我们提供了这种便利，以下就介绍如何使用Pycharm安装不同Python版本的第三方库。
1.打开Pycharm,我的Pycharm版本为Pycharm4.5.4


2.打开File菜单下的Setting菜单，如下






3.选择Settings下Project:Python下的Project Interpreter，并选择Python的版本，点右侧+号进入第三方库的搜索界面


4.在第三方包的搜索界面输入要安装的第三方包的名字，点击左下角Install Package按钮，后会提示安装成功




到这里，第三步就安装完成了，快去试一试新的库的强大功能吧！
三维模型重建顾名思义就是从一些数据（点云，图片，三维轮廓线等）重建出物体的三维逼真的三维模型，在其重建的过程中针对不同的数据的的三维重建会有不同的处理算法，如针对点云数据的三维重建有很多种重建方法,如基于Delaunay三角化，Voronoi图，隐式曲面等方法，另外在三维模型的重建过程（MarchingCube，RayCast,网格构建等）以及三维模型生成后的后处理算法（三维网格简化，三维网格加密，三维模型表面光滑，三维模型的空洞修补等等）也是层出不穷，在这其中需要用到大量的三维图形学知识（从简单的画点画线算法到复杂的体绘制算法，以及光照计算，材质映射等）。在最后的实现方面致力于提高算法效率和运行性能，各种加快算法实现的三维数据结构（KD树，八叉树等）的提出和实现，以及压榨计算机和服务器性能的并行算法（OpenMP，MPI）等，减少算法实现过程中的内存占用以及运行时间（降低空间复杂度以及时间复杂度）。三维模型重建上的优秀算法或者是优秀实例我也只是管中窥豹，上面所提到的有些名词我也是大致了解，我尽自己最大的能力介绍下自己闲暇时间以前做过的相关三维模型重建的实例和其他相关的关于三维重建方面的知识，毕竟能力有限，知识面还有待拓展。
1.编程语言
是用的编程语言是C/C++，基本上相关的图形学方面的实现都是使用C/C++作为开发语言，不是说别的语言如Java，Python等语言不好，确实在效率方面以及内存处理方面C/C++有着比较大的优势，而且现在市面上的三维图形库其底层语言就是C/C++，所以使用起来更加方便。一门语言有其适用的场景和场合，正如Java在WEB和APP上面的天然优势一样，C/C++在图形处理，图像识别以及其他的图形处理领域也有着很大的优势。
2.我所使用的第三方库
（1）三维图形库OpenGL
OpenGL(Open Graphics Library)，OpenGL图形绘制库，有着优秀的二维和三维图形API，是一个功能强大的三维图形绘制的底层库，有着大量的调节三维模型视觉效果的函数，例如光照，模型材质，纹理等等。早期OpenGL包GLUT依然比较强劲，但是其不能用于64位平台的编译，而且GLUT官方已经不维护了，那么有一个新的FreeGlut横空出世，支持最新的OpenGL绘图标准，并且支持64位平台的编译，能够完全取代老化的GLUT库。


（2）三维图形库VTK
VTK（Visualization Tool Kit）同样也是一个优秀的三维图形库，近年来相当的火爆，它以OpenGL作为底层绘制语言进行封装，用户不需要考虑太多的光照以及材质影响到模型可视化效果的设置，这些VTK都已经帮你做好了，你需要考虑的是如何从原始数据绘制出你的图形。其内部封装了大量的三维图形处理函数，基本上你所能想到的算法都能找到影子，比如著名的面绘制方法MarchingCube，体绘制方法Raycast等等，往往你能在阅读他的帮助文档的时候看到一个意想不到的功能。


（3）计算机视觉库OpenCV
OpenCV（Open Source Computer Vision Library）今年来大热的计算机视觉库，同样以C/C++作为底层语言，封装了大量的图形处理和计算机视觉领域的算法，比如说图像识别领域，机器人，人类视觉仿真，好像现在大热的人工智能领域也开始使用OpenCV进行视觉领域方面的处理。


（4）矩阵运算库Eigen
在三维图形处理过程中通常需要大量的矩阵运算，而Eigen是一个轻量级的矩阵运算库，其函数API涵盖了几乎所有的矩阵运算，但是它的使用只需要包含一个头文件，不需要过于复杂的配置就可以使用已经封装好的各种矩阵运算函数。


（5）并行计算库OpenMP
OpenMP可以在你把项目代码构建好之后也仍然可以通过几行代码将你的程序自动的进行并行化计算，使用起来非常的简单，并行计算可以大幅度的提高你的程序的运行速度以及计算的效率。如果你的IDE是VS，那么你只需要简单的开启OpenMP就可以了，然后在VS中包含其头文件就可以使用OpenMP封装的函数进行并行程序设计。


其他的如CGAL（几何算法库），QT（图形界面库，不过本人更喜欢用老掉牙的MFC）等等。


3.我所接触到的三维重建类型
（1）点云三维重建（隐式曲面重建）
原始三维点云（三维点云以及法向量）-斯坦福兔子1889个点，采用OpenGL从底层写的径向基隐式曲面点云重建方法


采用径向基隐式曲面重建后的三维模型

（2）医学序列图片三维重建（使用VTK进行医学图片处理，模型构建采用MarchingCube算法）
重建结果

（3）OpenCV双目视觉重建（医学冠脉三维重建，VTK做可视化）
左视图A

右视图B

使用OpenCV做的三维冠脉重建，VTK做的显示

（4）基于轮廓线的三维模型重建
轮廓线


重建的三维模型




4.结语
万事开头难，作为一个刚刚入门三维重建领域的人写这篇文章心中的感觉简直是战战兢兢，三维模型重建方面的知识浩如沧海，我只不过是只窥得了寥寥数星。只不过自己想把自己学习到的一些知识与有缘人交流分享，共同进步。不知以后还不会不在三维领域工作与发展，不过之后的事情谁又知道呢。
后面我会详细介绍一些三维重建算法以及一些实例。



最近需要用到三维点云数据，但是网上大部分的数据资源的数据格式都是杂乱无章而且没有清晰的数据说明，为了方便，自己整理了常用的三维点云数据，格式都是按照X坐标空格Y坐标空格Z坐标这种数据格式排列，方便数据读取和进行三维点云的重建实验。
   其中的数据包含了著名的斯坦福兔子，大象，马，凳子，人头等三维点云数据，显示的效果如下：






















以下为三维点云的重建效果：
三维点云数据我已经上传到我的下载频道：常见的三维点云数据，已经整理数据格式 - 下载频道 - CSDN.NET  http://download.csdn.net/detail/hw140701/9852949
常见的三维点云数据，已经整理数据格式 - 下载频道 - CSDN.NET http://download.csdn.net/detail/hw140701/9852949



另外一些常见的三维模型的下载地址为：常见的三维模型下载地址：http://www.cc.gatech.edu/projects/large_models/
希望可以帮助到有缘人0.0




最近在项目中有一种结构体数据需要存储，数据结构体如下

现在需要根据在m_Vector中的每一个结构体的ID来获得其对应的pinwei值，所以就写了一个函数，如下
然后上程序上面测试，对于一个size大约15000的容器，大概每次循环需要进行20次FindpinweiValueInVector（）函数的调用，所以在Vector中查找值的最坏的情况是时间复杂度为O(n),即进行15000*20，这还是每次的循环，当一个菜单执行完毕整整花了大概6个半小时左右，程序运行效率低下。


所以，必须要有一种查找效率较高的容器，就想到的map,map为平衡二叉树，查找效率为对数级别，时间复杂度为O(logN)，查找相对来说较快，1000大小的数据最坏只需要3次就可以查找到，15000只需要4次多就可以查找到。
所以声明一个map<int,double>型的容器，用于建立mystruct的ID与pinwei之间的对应关系，然后将Vector存储的值插入到map中，然后在map中根据键值（ID）查找Value(pinwei)。
函数如下



总结：以前在项目中用惯了STL的Vector，因为其比数组来的方便，不需要定义数组长度，可以不断的pushback(),但是其在大数据量中的查找效率简直令人发指，所以以后在什么时候得根据特定的情况使用特定的容器，不要习惯性的使用Vector。
后来又测试了下，用hash_map更快。


MFC项目开发过程中需要获取某个树控件下某个树节点下所有的子节点的文本，添加到某个组合框上，网上的相关代码差不多是遍历整个树控件，所以自己就封装了一个函数，用于获取指定树节点下的所有的子节点的文本然后添加到某个组合框中，其中获取的文本被压入CString类型的容器保存。

1.OpenMP介绍
OpenMP 是 Open MultiProcessing 的缩写，用于共享内存并行系统的多处理器程序设计的一套指导性编译处理方案。在项目程序已经完成好的情况下不需要大幅度的修改源代码，只需要加上专用的pragma来指明自己的意图，由此编译器可以自动将程序进行并行化，并在必要之处加入同步互斥以及通信。当选择忽略这些pragma，或者编译器不支持OpenMp时，程序又可退化为通常的程序(一般为串行)，代码仍然可以正常运作，只是不能利用多线程来加速程序执行。OpenMP提供的这种对于并行描述的高层抽象降低了并行编程的难度和复杂度，这样程序员可以把更多的精力投入到并行算法本身，而非其具体实现细节。对基于数据分集的多线程程序设计，OpenMP是一个很好的选择。



2.VS2010中开启OpenMP
右键项目属性-配置属性-C/C++-语言-OpenMP支持-点击是。






3. OpenMP并行化测试
在已有源代码的基础上，要对此段代码进行并行化处理，只需要使用

程序结果




当我们修改为8个线程的时候，其结果为




可以看出4个线程和8个线程都执行了cout << "Thread  " << omp_get_thread_num() << endl; //omp_get_thread_num()是获取当前线程id号这句代码，而且先后顺序没有特定的从线程1到线程2执行，可以看出简单的实现了并行块的设计。


下面以一个较大的for循环来测试OpenMP并行程序与普通串行程序的速度问题。
需要对for程序代码段执行并行化需要添加#pragma omp parallel for
串行化程序：





并行化程序：





这个问题简单但是又容易犯错，当代码出现错误的时候让人非常的懊恼；
比如有两个类：CleftView和CImplicitModelView两个类，现在有这样的需求需要在两个类中都调用对方的函数，所以就在CleftView.h中加上#include "CImplicitModelView"，在CImplicitModelView.h中加上#include "CleftView.h"，
但是当我们兴高采烈地的去编译时，会出现缺少分号的错误，但是当我检查了很久的代码，发现并没有出现缺少分号，这个原因是因为类与类之间的头文件互相包含所导致的。
解决方法就是：
在两个类的头文件中进行类先导声明，然后在各自类的.cpp文件中进行头文件的包含
例如：
(1)在CleftView.h中进行CImplicitModelView的类先导声明class CImplicitModelView;(有分号),然后在CleftView.cpp文件中包含CImplicitModelView类的头文件，#include"CImplicitModelView.h"
(2)在CImplicitModelView.h中进行CIeftView的类先导声明class CleftView;(有分号),然后在CImplicitModelView.cpp文件中包含CIeftView类的头文件，#include"CIeftView.h"
在CImplicitModelView.h中进行CIeftView的类先导声明class CleftView;(有分号),然后在CImplicitModelView.cpp文件中包含CIeftView类的头文件，#include"CIeftView.h"
CImplicitModelView
CImplicitModelView
这样，就可以实现在两个类中进行互访问
这样，就可以实现在两个类中进行互访问
在我们建立三维模型的过程中，当用多边形网格或者是三角面片来近似的表示曲面的表面时，曲面被离散成许多的平面多边形，如果我们的网格较大，离散度较粗，在模型表面使用明暗处理后，两两相邻的多边形会出现凸起或者是凹陷的折痕，在连接处显得比周围处亮或者暗，这就是所谓的马赫夫效应，如下图所示
针对于出现的马赫夫效应，我们需要进行明暗处理，消除或者是减少三维模型的马赫夫效应，使其看上去更加的光滑美观，常用的明暗处理技术有双线性光强插值—Gouraud明暗处理技术和双线性法向插值-Phong明暗处理技术。以下展示经过明暗处理前后结果对比
OpenGL提供了两种着色模式
void glShadeModel ( GLenum mode)，恒定着色
GL_FLAT，光滑着色GL_SMOOTH，而GL_SMOOTH中则是使用了Gouraud明暗处理技术，对于Phong明暗处理技术可以参见http://blog.csdn.net/dalewzm/article/details/46291397
http://blog.csdn.net/silangquan/article/details/10011169

Gouraud明暗处理算法在处理亮度的不连续性方面很有效，但是在明暗强度函数的斜率急剧变化处仍然可以看到马赫夫效应，不能完全消除光强度的不连续性。而Phong明暗处理是对表面的法向量而不是亮度进行插值，大大改善了Gouraud模型对高亮度镜面反射光的处理，在每一点都是用法向量的一个近似值，所以一般法向量插值的结果要优于亮度插值，在很大程度上消除了马赫夫效应，但是会大大增加明暗处理的时间。


鉴于此，我在用MC算法建立三维模型的时候，由于我的网格设置较大，导致出现了马赫夫效应，即模型表面的可视化效果不光滑，如下：



于是使用OpenGL自带的Gouraud明暗处理技术，以一个MC算法生成的章鱼模型为例子，效果如下
相比未使用明暗处理的模型，使用了Gouraud处理的模型从可视化的角度上来看更加的光滑，效果更好。




转载地址：http://www.cnblogs.com/bluestorm/p/3168720.html
这三种类型各有各的优点，比如CString比较灵活，是基于MFC常用的类型，安全性也最高，但可移植性最差。string是使用STL时必不可少的类型，所以是做工程时必须熟练掌握的；char*是从学习C语言开始就已经和我们形影不离的了，有许多API都是以char*作为参数输入的。所以熟练掌握三者之间的转换十分必要。
MFC PictureControl控件上自适应显示图片，分图片失真或者图片不失真两种





图片不失真，但是没有铺满整个图片控件区域：


问题描述：给定两个非空的链表，表示两个非负整数。 数字以相反的顺序存储，每个节点包含一个数字。 添加两个数字并将其作为链表返回。
测试代码：

VS2010-MFC在状态栏上添加进度条比在VC6.0中更加简单，不需要再从CStatusBar类中派生子类。
仔细查看VS2010生成的MainFrm.h文件我们可以看出，m_wndStatusBar已经是CMFCStatusBar的对象了，而不是CStatusBar对象。
CStatusBar对象。
所以就去微软的官网查看CMFCStatusBar的帮助文档，有中文，太好了
CMFCStatusBar的帮助文档，有中文，太好了
微软提供的MFC的帮助文档，有中文

微软提供的MFC的帮助文档，有中文

CMFCStatusBar类的帮助文档
此类自带进度条，只需要调用就可以了






以下为如何在VS2010单文档程序中在进度栏上添加进度条
步骤1:如上图所示，将m_wndStatusBar从protected型变量改成public型变量；
m_wndStatusBar从protected型变量改成public型变量；
步骤2：在MainFrm.cpp中添加进度条的标识IDS_PROGRESS
步骤2：在MainFrm.cpp中添加进度条的标识IDS_PROGRESS




并在资源文件字符串表String Table中新增一个字符串IDS_PROGRESS，如下图
并在资源文件字符串表String Table中新增一个字符串IDS_PROGRESS，如下图








步骤3：在CMainFrame的OnCreate()函数中添加以下代码，用于初试化状态栏
步骤3：在CMainFrame的OnCreate()函数中添加以下代码，用于初试化状态栏




步骤4：在View中某个读取文件的响应函数，添加以下代码，即可在状态栏显示文件加载进度条，以及当前文件大小和百分比信息




当我们点击读取文件后，文件总长度可以通过FILE类的Ftell函数进行获取，然后就可以在状态栏查看当前文档的加载进度以及已经加载文件的大小




整个编写流程就完成了，比VC 里面简单太多了。
使用VTK生成分布在球内部或者表面的三维点云数据，可以设置球的中心，半径以及生成的三维点的个数并选择可以设置在球内部生成或者是球表面生成。

问题描述:将一个string型的字符转成int型的数字，需要处理字符串输入的各种情况，如字符串前面的空格，+号，-号等符号。
     测试代码：

在原先的博客VTK读取一个TXT文档中的三维点坐标绘制三维点云基础上，有小伙伴询问是否可以以点云中每一个三维点的坐标为中心绘制一个小的球体，用于标识特征点，这种就让我想到了化学里面的分子结构，所以就在原有博客的基础上进行了改写，实现了点云不是以点的方式而是以小球体形式显示出来，实现了大量球体的同时绘制。
不多说直接贴代码：

整体图：




局部的线框显示细节图：




局部表面显示细节图：


LeetCode第一题：
问题描述：给定一个整形的数组，在给定一个特定的整数值，要求返回这个整形数组中两个元素的和等于给定的整数的元素索引。
STL容器vector是新手入门STL最常用也是最好用的容器类，其不像array需要固定大小，而是可以动态的在容器尾部或者是中间插入元素，相当的好用，但是我们往往会在一个程序中向vector中压入了很多的元素，在使用完vector中的元素之后，只是会用clear去清理vector中的元素，有些小伙伴认为清空容器就等于释放了内存，其实真正的是这样的吗？我们不妨来做一个测试。
首先我们声明一个double型的容器，往里面压入了10000000个元素，然后用clear方法，看是否能真正的释放掉vector所占的内存，这里用SDK中的 GetProcessMemoryInfo方法来获取当前进程的所占用的内存。
代码如下：

程序运行结果：




我们可以看到使用clear方法虽然清空了vector中的元素，但是并没有释放掉vector所占用的内存，高效的管理内存是程序设计所要求的，C++ 11有了一个全新的shrink_to_fit()方法，该方法与clear()搭配使用，将vector所占用大小缩小到合适的范围，以下进行测试
代码如下：






我们可以看到，使用shrink_to_fit方法可以快速的释放掉vector所占用的内存。
MFC的界面太丑了，但是学会之后写一写简单的可交互的PC端程序还是可以的，但是用VS2010自己生成的MFC工程上的控件程序还是MFC经典风格，实在是看不下去，如下




要使其按钮带有Win7风格，带有Aero的美化效果，就需要在MFC工程的头文件Stdafx.h文件中，加入以下代码








但是如果想要有更加好的效果，还是自绘吧。
Python并不是我的主业，当初学Python主要是为了学爬虫，以为自己觉得能够从网上爬东西是一件非常神奇又是一件非常有用的事情，因为我们可以获取一些方面的数据或者其他的东西，反正各有用处。
这两天闲着没事，主要是让脑子放松一下就写着爬虫来玩，上一篇初略的使用BeautifulSoup去爬某个CSDN博客的基本统计信息（http://blog.csdn.net/hw140701/article/details/55048364），今天就想要不就直接根据某个CSDN博客的主页的地址爬取该博客的所有文章链接，进而提取每一篇文章中的元素，我这里是提取每一篇博客中的文字信息。
一、主要思路
通过分析CSDN博客的网站源码，我们发现当我们输入某博客主页网址时，如：http://blog.csdn.net/hw140701
在主页会有多篇文章，以及文章的链接，默认的是15篇。在主页博客的底部会有分页的链接，如下图


如图所示，一共65篇分5页，每一页中又包含了15篇文章的链接。
所以我们总体的思路是：
1.输入博客主页地址，先获取当前页所有文章的链接；
2.获取每个分页的链接地址
3.通过每个分页的链接地址获取每一个分页上所有文章的链接地址
4.根据每一篇文章的链接地址，获取每一篇文章的内容，直到该博客所有文章都爬取完毕


二、代码分析
2.1分页链接源码分析
用浏览器打开网页地址，使用开发者工具查看博客主页网站源码，发现分页链接地址隐藏在下列标签之中


所以我们通过下列代码所有分页链接进行匹配



2.2分页上每一篇文章链接源码分析
得到每一个分页的链接后，对每一个分页上的文章链接源码进行分析，其源码如下


通过分析，所以我们采取以下的方法进行匹配


通过对每一篇文章中的网站源码进行分析，发现其内容位于源码中的以下位置


所以通过下列代码进行匹配

现附上全部代码，注释部分可能有错，可以根据此代码自行修改，去爬取某CSDN博客中的任意元素

使用findContours（）查找图片轮廓线，并将轮廓线坐标点输出，访问二维vector，使用迭代器和下标两种方式


先说说题外话，OpenGL是一个跨平台优秀的三维可视化库，而在Windows中内部封装的OpenGL还是1.1版本，不吐槽，维护自身Direct3D的发展也是情有可原。如果你是Win32系统，编译环境也是Win32的话，对OpenGL只是练习，那么就用简单的GLUT来配置OpenGL环境就好了，但是如果你想用X64(64位)环境来编译的话，这个GLUT会编译不成功，因为它不提供64位下的使用环境，而且太老掉牙了，版本已经不更新了，那么这个时候你就需要freeglut这个包(国外推荐使用freeglut，摒弃glut),这个包提供了32位(x86)和64(x64)两种编译环境下可用的静态链接库和动态链接库。关于64位环境编译的程序与32环境编译的程序之间的区别就是32位程序在系统中最多能申请到2G内存（2的32次方字节），而64位程序在系统中最多能申请到（2的64次方字节）的内存，64位程序理论上可以使用当前PC机上所装载的全部的内存，极大的提高了程序的性能。下面介绍了Glut和FreeGlut的详细配置教程，以便在32位编译环境和64位编译环境都得心应手的使用OpenGL。
*我的VS2010的安装位置：D:\Program Files (x86)\Microsoft Visual Studio 10.0
1.关于Glut的配置
1.1. 下载GLUT。Windows环境下的GLUT下载地址：
http://www.opengl.org/resources/libraries/glut/glutdlls37beta.zip



1.2
1.3 
1.4 
1.5 

2.Freeglut的配置




我使用的环境具体是Win764位+VS2010+Freeglut2.8.1,而Freeglut2.8.1这个版本支持VS2010,可使用最高的版本3.0，同样支持各种VS版本。


2.1 Freeglut的下载
Freeglut2.8.1:http://download.csdn.net/detail/hw140701/9830604
Freeglut其他版本的下载地址：
Freeglut3.0版本：
http://www.transmissionzero.co.uk/software/freeglut-devel/

http://download.csdn.net/detail/hw140701/9830606



2.2 生成VS2010 64位编译环境下下可用的Freeglut的包含头文件，静态链接库lib,动态链接库dll。
解压缩包，打开解压后的压缩文件夹，里面会有一个VisualStduio的文件夹，如下


    打开VisualStudio文件夹，里面会有VS2008，VS2010，VS2012三个版本的


    选择VS2010，打开项目文件freeglut.sln。


    选择Release版本，x64平台编译，右键解决方案，点击全部生成


然后你会在解压的文件夹下发现两个新的文件夹inclue和lib文件夹




include文件夹下会有GL文件夹，里面包含了freeglut所需用到的头文件，freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h,注意这里的glut.h与Glut包的glut.h文件不相同。
lib文件夹下会有一个x64文件夹，里面包含了freeglut.lib和freeglut.dll文件。
2.3 具体配置
 Freeglut配置本质上与Glut的配置原理相同，不过，我们这里配置的是64位的freeglut，稍微有一些不同。这里也简单介绍一下freeglut32位的配置，如果你要生成freeglut32可用的包含文件，静态链接库以及动态链接库，请参见上节中64的生成方法，不要需要将编译平台改为Win32，此节不再赘述。
1.将\freeglut-2.8.1\freeglut-2.8.1\include\GL文件夹下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2.将freeglut.lib复制到D:\ProgramFiles (x86)\Microsoft Visual Studio 10.0\VC\lib下。
    3.将freeglut.dll复制到C:\Windows\System32下
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\SysWOW64下。
    1.将\freeglut-2.8.1\freeglut-2.8.1\include\GL文件夹下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2.将freeglut.lib复制到D:\ProgramFiles (x86)\Microsoft Visual Studio 10.0\VC\lib\amd64下，注意这里是放64位静态链接库的地方。
    3.将freeglut.dll复制到C:\Windows\SysWOW64下
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\ System32下。
 
最后在使用的时候只需添加#include<GL/freeglut.h>就可以了。
2.4 Freeglut3.0的配置
    类似于Freeglut2.8.1的配置
下载网址就是
http://www.transmissionzero.co.uk/software/freeglut-devel/
选择freeglut3.0.0 MSVC Package




解压缩文件，有include,bin,lib三个文件夹
2.4.1 Freeglut3.0 32位的配置
    1.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\include\GL下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\lib下的
freeglut.lib复制到D:\Program Files (x86)\Microsoft Visual Studio10.0\VC\lib。
    3.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\bin下的
freeglut.dll复制到C:\Windows\System32下。
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\SysWOW64下。
 
2.4.2 Freeglut3.0 64位配置
    1.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\include\GL下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2. \freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\lib\x64下的
freeglut.lib复制到D:\Program Files (x86)\Microsoft Visual Studio10.0\VC\lib\amd64下。
    3. \freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\bin\x64下的
freeglut.dll复制到C:\Windows\ SysWOW64下
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\ System32下。




3.Glew的配置
3.1 Glew的下载
http://www.cnblogs.com/Akunwjy/p/Freeglut.html













VTK生成指定圆心以及指定半径的三维球，并将其导出为obj三维模型格式



Meshlab中载入qiu.obj




可在meshlab中将其转换为其他的三维数据格式或者提取球体表面的三维点云。
显示文件夹窗口默认显示效果：


加上语句bi.ulFlags=BIF_BROWSEINCLUDEFILES;后不仅可以显示文件夹，还可以显示文件：

加上语句bi.ulFlags=BIF_BROWSEINCLUDEFILES;后不仅可以显示文件夹，还可以显示文件：




加上语句bi.ulFlags=BIF_NEWDIALOGSTYLE;后窗口可以调整大小，并有新建文件夹按钮：

加上语句bi.ulFlags=BIF_NEWDIALOGSTYLE;后窗口可以调整大小，并有新建文件夹按钮：

加上语句bi.ulFlags=BIF_NEWDIALOGSTYLE;后窗口可以调整大小，并有新建文件夹按钮：






加上语句bi.lpszTitle=L"指定要处理的文件夹";
 后在窗口内显示提示用户的语句：

加上语句bi.lpszTitle=L"指定要处理的文件夹";
 后在窗口内显示提示用户的语句：

加上语句bi.lpszTitle=L"指定要处理的文件夹";
 后在窗口内显示提示用户的语句：

加上语句bi.lpszTitle=L"指定要处理的文件夹";
 后在窗口内显示提示用户的语句：








一、创建状态栏的两种方法
CStatusBarCtrl和CStatusBar两个类来完成
CStatusBar两个类来完成
                  //设置状态栏文本
                  m_StatusBar.SetText("分栏一", 0, 0);
                  m_StatusBar.SetText("分栏二", 1, 0);
                  m_StatusBar.SetText("分栏三", 2, 0);
                  //下面是在状态栏中加入图标
                  m_StatusBar.SetIcon(1, 
                                SetIcon(AfxGetApp()->LoadIcon(IDR_MAINFRAME),
                 //----------------让这个状态栏最终显示在对话框中-------------
                  RepositionBars(AFX_IDW_CONTROLBAR_FIRST,AFX_IDW_CONTROLBAR_LAST,0);
二、实时显示系统时间信息
在程序中添加WM_TIMER消息响应函数，这里以基于对话框程序为例
第一种创建状态栏的方法
void CCJCZDlgDemoDlg::OnTimer(UINT_PTR nIDEvent)
{
// TODO: 在此添加消息处理程序代码和/或调用默认值
CTime t = CTime::GetCurrentTime();
CString str;
str.Format("%04d/%02d/%02d  %02d:%02d:%02d",t.GetYear(),t.GetMonth(),t.GetDay(),t.GetHour(),t.GetMinute(),t.GetSecond());
m_StatusBar.SetText(str, 2, 0);


CDialogEx::OnTimer(nIDEvent);
}

m_wndStatusBar.SetPaneText(2,str);
    冠脉三维重建就是从两幅不同角度拍摄的冠脉医学图片根据相机参数(角度)重建出原有的三维冠脉形态。
    具体文献可以参考：
      1.黄家祥. 冠状动脉树三维骨架重建方法的研究[D]. 天津大学, 2003.
      2.王国铸. 单臂冠脉造影三维重建与定量分析[D]. 华中科技大学, 2012.
      3.郝培远. 冠脉造影三维重建定量分析(QCA)及最佳投照角度的研究[D]. 南方医科大学, 2011.等文献





这里以黄家祥这篇文章的数据作为例子，具体的冠脉三维重建步骤可见这篇文章黄家祥. 冠状动脉树三维骨架重建方法的研究[D]. 天津大学, 2003。
以下为其中的一个实验所给出的数据，两幅不同角度的图片为。




         图A                               图B




图A和图B的相机参数分别为RAO 0，CAUD35和LAO 80，CRAN15。

图A和图B的相机参数分别为RAO 0，CAUD35和LAO 80，CRAN15。




















有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。

有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。

有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。






    匹配的结果如下：
匹配的结果如下：
















上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。

上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。

上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。












以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）

以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）

以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）

以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）












总体上来看，重建效果与论文中最后给出的结果类似，VTK封装了OpenGL底层的绘图命令，所以在光照与材质方面不需要我们去过多的设置就会有逼真的三维显示效果。
总体上来看，重建效果与论文中最后给出的结果类似，VTK封装了OpenGL底层的绘图命令，所以在光照与材质方面不需要我们去过多的设置就会有逼真的三维显示效果。









1.SkinMag MFC美化界面库
总所周知，MFC的皮肤比较呆板，有各种各样的MFC界面库可以供我们使用，来修改程序的外观。C++界面库可以参见：http://blog.csdn.net/witch_soya/article/details/10982451
在这里介绍一种配置比较简单的MFC界面库SkinMagic。
可从这里下载SkinMagic2.4破解版：http://download.csdn.net/download/wbxyzwh/9693071
下载解压后，文件夹文件如下：
2.SkinMagic在VS2010 MFC程序中的配置
2.1文件拷贝
将下列三个文件以及所有的*.smf皮肤文件拷贝至建立的MFC工程文件目录下




2.2
在stdafx.h中加入头文件和库的引用，如下：



皮肤的调用有两种方法，一是直接从皮肤文件中调用，另一种方法是从资源文件中调用，分别说明如下：




在CxxxApp::InitInstance()中的加入以下代码如下：

2.5 将皮肤应用到程序上
3. SkinMagic界面库各个皮肤效果
一个基于指针和重载操作符的数组类设计Array,可以进行数组范围检查，与平常看到的类而言，这个类的编写让人感觉逻辑十分清晰，以及更加可以理解面向对象程序设计理念。
Arry.h




当初学Python进一个Python学习群，不久之后群主大大就发了自己写的一个爬虫，就是爬取www.mzitu.com网站上的妹纸图片，看完之后，惊为天人，一脸懵逼，觉得群主大大好厉害，当初自己进群的初衷以及学Python的初衷就是为了做爬虫，然后慢慢的开始。所以说这次，就是为了实践一下，爬取这个网站上的所有的图片，别邪恶哦，虽然是隐藏福利，我只是为了写爬虫实践，我只是为了写爬虫实践，我只是为了写爬虫实践！！！


网络爬虫会给网站服务器造成巨大负荷，所以，本次实践的源码仅供参考交流，不宜用于商业应用，由此造成的任何法律责任本人不予承担。


为了得到这个网站上所有的妹子图片，就得分析网站的架构，通过分析发现http://www.mzitu.com/all这个网址下有2013-2017年网站上所有的相册的链接，所以准备通过以下步骤爬取网站上的所有图片。


第1步：在http://www.mzitu.com/all下获取所有的相册的链接以及相册的名字
第2步：根据每个相册的链接得到每个相册每一个图片页面的链接
第3步：根据每一个图片的链接得到每一张图片的名字以及图片链接


第一步：在http://www.mzitu.com/all下获取所有的相册的链接以及相册的名字
在
http://www.mzitu.com/all下获取所有的相册的链接以及相册的名字
分析网站源码，查看每一个相册链接以及名字的所处标签




由图上可以看出，每一个相册的链接以及名称都位于<a >标签下


第二步：根据每个相册的链接得到每个相册每一个图片页面的链接
根据每个相册的链接得到每个相册每一个图片页面的链接
通过分析网站源码，分析每一个相册下每一个图片页面的链接
通过分析网站源码，分析每一个相册下每一个图片页面的链接




通过分析，发现每一个图片页面链接都处于<div class="pagenavi">的<a herf>下，但是只有几个图片的页面的链接，如上图所示，分别只有2,3,4.......65，但是图片页面的规律是相册链接+"/"+页面编号，在这里我们得到最大的页面编号65，就可以通过循环得到每一个图片页面的链接，所以在这里通过字符选取将编号压入进一个list，然后通过max方法得到最大编号，得到每一个相册图片页面的链接。


第三步：根据每一个图片的链接得到每一张图片的名字以及图片链接
根据每一个图片的链接得到每一张图片的名字以及图片链接
根据以上得到的图片页面链接，在每个页面内爬取图片的下载链接以及图片的名称
根据以上得到的图片页面链接，在每个页面内爬取图片的下载链接以及图片的名称




通过分析，图片链接以及名称都位于<img>标签内


通过以上的分析，将整个流程写为Python代码，在其中使用了第三方包Beautifulsoup,现附上全部代码，如有错误，请指教







刚刚开始写的时候，会遇到服务器断开链接，以及主机在一定时间内无法连接的错误，在百度上，谷歌上看了半天，可能是由于网站的反爬虫机制，我自己的解决办法如下，不知道你们可不可行：
1、关闭windows防火墙，爬完再开
2、采用多headers，伪装不同的浏览器
3、每下载完，sleep一下，减缓访问网站的频率，如果过快，网站服务器会认为你是爬虫
4、设置全局超时时间，有时候因为网速的问题会出现这种情况
5、设置代理IP


刚刚开始不知道为什么这个网站不能用代理IP访问，一访问，网站服务器就强制断开连接，后来又可以了，尽量用代理IP，免得被封IP，代理ip网站可上http://ip.zdaye.com/查询


在这个代码中，没有采用多线程机制，所以爬起来比较慢，勿喷。
最好在晚上爬，网速快。
爬取结果（隐藏福利）：






easysize.h自行在CSDN下载频道进行下载。
步骤一：把easysize.h拷贝到CMyDlg项目文件夹中，同时在CMyDlg的.h文件和.cpp文件中加入#include "easysize.h"；
步骤二：在CMyDlg类的h文件中，加入DECLARE_EASYSIZE，注意结尾处不要加“；”。
步骤三：在CMyDlg类的OnInitDialog()函数的结尾处加入INIT_EASYSIZE, 注意此处结尾处要加“；”。
步骤四：增加WM_SIZE消息响应函数OnSize()，在函数中加入UPDATE_EASYSIZE，注意此处结尾处要加“；”。
步骤五：在CMyDlg的cpp文件中添加EASYSIZE 的宏映射
EASYSIZE(control,left,top,right,bottom,options)
Control---控件的ID，需要设置的控件
left top right bottom---矩形框的位置，可以设置的参数：ES_BORDER、ES_KEEPSIZE、其他control的ID。
        ES_BORDER代表控件与边框的距离保持不变
        ES_KEEPSIZE代表控件的宽度和高度保持不变，left/right只能设置其中一个为ES_KEEPSIZE,top/bottom亦然。
Control  ID代表以另一个空间为参照
        具体注释如下，待设置控件记为ID1，参照控件记为ID2
        i left=ID2  ID1左边到ID2右边的距离保持不变（不管ID2如何变化）
        ii right=ID2 ID1右边到ID2左边的距离保持不变（不管ID2如何变化）
iii top=ID2  ID1上边到ID2下边的距离保持不变（不管ID2如何变化）
iv bottom=ID2 ID1下边到ID2上边的距离保持不变（不管ID2如何变化）
options---特别操作ES_HCENTER, ES_VCENTER and 0的结合。
0代表没有任何操作；
ES_HCENTER代表控件在left/right之间水平居中，此时left/right都不能设置成ES_KEEPSIZE，控件的宽度保持不变；
ES_VCENTER同理ES_HCENTER
注意： 布局风格的设置将很大程序影响控件在对话框上的布局，不同设置布局会有天壤之别！！！！


1.显示一个地球各大洲板块的轮廓线

2. 地图指北针图例



由于最近的需要在任意两个三维点直接绘制三维圆柱体管道，OpenGL太底层了，以至于什么东西都要自己写
在网上参考了如下的博客:
http://blog.csdn.net/ryfdizuo/article/details/6548257

http://blog.sina.com.cn/s/blog_5cd804e70100oxca.html

http://blog.sina.com.cn/s/blog_3d2759c90100rpnf.html

在上述博客中有详细的原理介绍，而我只是将代码改成自己可以用的形式，以便调用。
代码如下：









增大其传进去的两个参数：段数Slices，以及递归次数stacks，可以获得更加光滑的圆柱体绘制效果：
由于有这个需求，就是当在对话框设置一些数值的时候，可以在对话框上预览三维图像。
（1）生成一个基于对话框的程序，或者直接在单文档或者多文档上插入一个对话框，生成一个新的对话框类CGridingDlg,名字可以任取。
（2）配置好工程的OpenGL环境，不知道可以百度。
（3）在CGridingDlg的头文件中添加以下变量:
CGridingDlg的头文件中添加以下变量:






(4)重载对话框类CGridingDlg的虚函数OnInitDialog(),添加WM_TIMER消息，
(4)重载对话框类CGridingDlg的虚函数OnInitDialog(),添加WM_TIMER消息，
CGridingDlg的虚函数OnInitDialog(),添加WM_TIMER消息，
添加函数SetupPixelFormat(HDC hDC)---->用于设置OpenGL的像素格式
添加函数SetupPixelFormat(HDC hDC)---->用于设置OpenGL的像素格式
添加函数SetupPixelFormat(HDC hDC)---->用于设置OpenGL的像素格式



在对话框上面添加一个Picture控件，用于显示图形，设置其ID为IDC_STATIC_PictureRender
在对话框上面添加一个Picture控件，用于显示图形，设置其ID为IDC_STATIC_PictureRender
在对话框上面添加一个Picture控件，用于显示图形，设置其ID为IDC_STATIC_PictureRender






添加InitializeOpenGL()函数用于在对话框中初始化OpenGL。
添加InitializeOpenGL()函数用于在对话框中初始化OpenGL。
添加InitializeOpenGL()函数用于在对话框中初始化OpenGL。















RenderScene()函数添加进去，每隔多少毫秒就调用RenderScene()，时间间隔设置的越少就可以形成连续绘制的效果
RenderScene()，时间间隔设置的越少就可以形成连续绘制的效果






RenderScene()函数中封装一个函数，将该函数放置于RenderScene()函数的绘图代码区就好了。
RenderScene()函数的绘图代码区就好了。
绘制的效果如下
绘制的效果如下
绘制的效果如下
绘制的效果如下
绘制的效果如下




















但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。


























































































由于需要在三维空间中进行三维模型的碰撞与相交，为了加快检测的效率，考虑用三维物体包围盒。AABB与OOBB包围盒比起来原理简单，容易实现，为了更好的在三维空间中使用AABB包围盒，所以自己写了一个关于三维的AABB包围盒类AABB类，写了不同参数的构造函数，以及关于AABB包围盒的各种成员方法，虽然不是很全，但是可以满足日常的需要。
下面贴代码：
AABB.h


原文地址：Graphics Software  http://www.dgp.toronto.edu/~rms/links.htmlGraphics Software
贴出来贴出来贴出来，防止自己忘掉。。。。

Shape Modeling
Texturing
突发奇想，想写一个轰炸自己QQ好友的聊天轰炸机，哈哈哈，看了半天自己就写了一个Low的聊天轰炸机，纯粹依靠剪切板往聊天窗口复制文字，然后模拟回车按钮完成发送，写了一个简单的MFC对话框Demo，大牛自动跳出，无需再看。
主要代码如下：



1.单独拉出你想轰炸的QQ好友的聊天窗口，不要合在一起；
2.设置你想轰炸的QQ好友的昵称，就是你前面拉出来的单独的会话窗口好友的昵称；
3.选择你的BOOM.txt文件，里面是你想轰炸别人的话；
4.设置轰炸的次数。
截图如下：






源码链接：源码链接，Debug和Release版本，里面自带了我自己写的BOOM.txt




主要用到OpenCV自带的CascadeClassifier这个类下的detectMultiScale函数，其检测效果并不是很好
    

（1）静态图片上的人脸检测





可以看出，有些人脸没有检测出来，或者是检测出来有位置错误。
（2）摄像头人脸检测

问题描述：判断一个数是不是回文数。
回文数：就是从左往右念和从右往左念都是一样的，对称的一个数，如121,789987等。
注意：负数不是回文数，如-121。
解题思路一：如果一个数倒序输出后还等于原始的值，那么该数为回文数。
解题思路2：如果一个数最左边的数等于最右边的数，然后再去除这两个数，然后再判断最左边的数依然等于最右边的数，直到最后一个数，那么该数为回文数。


在leetcode里面提交的结果是第一种方法貌似比第二种要快。
用惯了AfxMessageBox（），总感觉这个东西不那么顺手，就想在状态显示当前程序的提示信息。
想要在任何类中都设置状态栏的信息，必须获取到m_wndStatusBar的指针。
所以第一步，将CMainFrame中的m_wndStatusBar的保护类型从保护改为public
m_wndStatusBar的保护类型从保护改为public




第二步：在任意类中添加下列代码，改变状态栏的提示信息



BeautifulSoup的find()和findAll()这两个函数在某些方面十分的相似，我们可以使用它们过滤HTML页面，并查找需要的标签组和单个的标签。
    这两个函数非常的相似：
    findAll(tag,attributes,recursive,text,limit,keywords)
    find(tag,attributes,recursive,text,keywords)
    
    
标签参数tag:可以传递一个标签的名称或多个标签名称组成的Python列表做标签参数。
    如：findAll({"tag1","tag2","tag3","tag4"})
    
    
属性参数attributes是用一个Python字典封装一个标签的若干属性和对应的属性值。
    如：返回HTML文档中attribute1和attribute2属性的tag标签
    findAll("tag",{"classs":{"attribute1","attribute2"}})
   
    
递归参数recursive是一个布尔变量。如果你想知道所抓取的HTML文档标签结构中有多少层的信息，如果recursive设置为True，findAll就会根据你的要求去查找标签参数的所有子标签以及子标签的子标签。如果recursive设置为False，findAll就只会查找文档的以及标签。findAll默认支持递归查找（recursive的默认值是True）,一般情况下不需要设置该参数。只是当你真正了解自己需要哪些信息，而且抓取速度非常重要时，就可以视情况设置递归参数。


    
文本参数text是使用标签中的文本内容去进行匹配，而不是标签的属性。
    如果我们需要查询某个网页中包含"the text"内容的文本数量，我们可以使用以下语句
    namelist=bsObj.findAll(text="the text")
    print(len(namelist))
    


    
范围限制参数limit，只能用于findAll方法。find()方法等价与findAll()方法limit参数等于1时的情形。如果你只对网页中获取的前x项感兴趣，就可以设置它。但是要注意的是这个参数设置之后获取的前几项结果是按照网页上的顺序排序的，也有可能不是你想要的结果。
  
    
关键词参数keyword，可以让你选择那些具有指定属性的标签。
   如：
alltext=bsObj.findAll(id="text")
        print(allText[0].get_text())
       
    .get_text()会把你正在处理的HTML文档中的所有标签都清除，然后只返回一个只包含文字的字符串。如果你正在处理一个包含许多超链接、段落以及标签的大段源代码，那么get_text()会把这些超链接、段落、以及标签全都清除，剩下不带标签的文字。
   通常在你准备打印，存储以及操作数据时，应该在最后再使用.get_text()去提取你想要的文本信息，在一般的情况下，应该尽可能的保留HTML文档的标签的结构。
参考书籍：数据结构（C++版）陈宝平主编
参考链接：http://www.cnblogs.com/charley_yang/archive/2010/12/08/1900256.html
二叉树类封装以及代码

题目描述：反转整数输出，注意的是输入被假定为一个32位有符号整数。当反整数溢出时，函数应返回0。
  今年的华为的实习生招聘笔试的第一个题与这个有点类似，不过华为的是输入两个整数，反转，然后输出两个整数反转后两个数的和。
  测试代码：

我们在进行爬虫时有的时候不可能只是在一个网站上进行内容上的爬取，理想中的爬虫应该是顺着一个链接从一个页面到另外一个页面，这需要获取页面上的所有的外链，同时收集每个页面上的内链。网站首页上不一定会发现外链，为了防止程序出错，就要递归深入到一个网站直到找到一个外链为止。
但在爬取的过程中出现了TimeoutError: [WinError 10060] 由于连接方在一段时间后没有正确答复或连接的主机没有反应，连接尝试失败。这个错误。
可能是由于访问网站频率过快，或者是我处于校园网，访问过快，被学校的服务的给限制了，或者是网速不好。所以在网上百度了下，设置了代理IP，结果完美运行，没有出现这个原因，最新的代理IP，自行百度即可。
最近有小伙伴在问，我想显示一个求得的三维点云中的每一个点的法向量的指向，怎么获得这种逼真的三维显示效果呢？当然是OpenGL啦，也是我自己用的比较习惯，所以就花了十几分钟帮助上面提问的小伙伴解决问题，然后也提供给大家一个查看三维点云法向量的工具，稍后我会在我的ＣＳＤＮ的下载频道上传该软件的Ｒｅｌｅａｓｅ版本供大家使用，主要的显示效果是三维点云中的每一个点使用实心球体表示，法向量用一个方向箭头和圆锥体表示，类似于坐标轴的指向。主要用到三个函数，Render3DCylinder（在任意两个三维点间画圆柱体），Render3DSphere（以任意三维点为中心画球体），Render3DCone（在任意两个三维点之间画圆锥体）。
其三个函数的主要代码如下：






整个程序的源码由于项目的关系不能给出，只能给出发布版本，不过主要的核心的功能是利用上述的三个函数实现的。相应的程序的Realease版本的下载地址：[免费]OpenGL+MFC显示三维点云中每一个点的法向量，Release版本-CSDN下载  http://download.csdn.net/download/hw140701/9970732http://download.csdn.net/download/hw140701/9970732



自己封装的三维向量类Vector.h,包含一些常见的三维向量类的操作符重载和一些基本运算，可以直接复制粘贴作为头文件包含在项目文件中。

Win32编译环境下，用ADO数据库连接Access数据库一般都不会报错，但是最近由于项目上的需要，程序需要编译成64位以便申请到更多的使用内存空间，当把编译方式从Win32改为x64的时候，突然出现了数据库连接出现未知错误，这时候就猜到了应该是编译环境的改变导致了数据库连接出错，在参考了其他大神的解决方案之后，终于解决了这个问题,我的环境为Win7
 64+MFC(VS2010)+ADO+Access2007。
    参考链接如下：
    http://blog.csdn.net/sundacheng1989/article/details/17925431
    http://www.cnblogs.com/bluedoctor/p/3925871.html
    http://blog.csdn.net/kirawoo/article/details/39032387
    http://blog.csdn.net/u010891996/article/details/12522911


解决方法：
步骤1：去官网下载AccessDatabaseEngine_64.exe,下载链接
https://www.microsoft.com/zh-cn/download/details.aspx?id=13255
或者直接去我的下载频道进行下载
http://download.csdn.net/detail/hw140701/9830665





步骤2:这一个步骤是强制安装刚刚下载的AccessDatabaseEngine_64.exe，如果不强制安装的话，它会要求你卸载你所安装的全部的Office软件，那多麻烦！！！，所以选择忽略提醒，强制安装，
AccessDatabaseEngine_64.exe，如果不强制安装的话，它会要求你卸载你所安装的全部的Office软件，那多麻烦！！！，所以选择忽略提醒，强制安装，
打开cmd.exe,在命令行输入“你的AccessDatabaseEngine_64.exe的存放路径” /passive，比如我的就是"F:\软件\我下载的\Windows数据库编程\AccessDatabaseEngine_64.exe"
 /passive强制安装，输完这个命令就等待安装完成。
打开cmd.exe,在命令行输入“你的AccessDatabaseEngine_64.exe的存放路径” /passive，比如我的就是"F:\软件\我下载的\Windows数据库编程\AccessDatabaseEngine_64.exe"
 /passive强制安装，输完这个命令就等待安装完成。
AccessDatabaseEngine_64.exe的存放路径
AccessDatabaseEngine_64.exe
步骤3：在安装完上述引擎之后，你需要修改一下你的代码，在win32编译环境下我们的数据库的链接字符串是
步骤3：在安装完上述引擎之后，你需要修改一下你的代码，在win32编译环境下我们的数据库的链接字符串是
m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%s",databaseName);

如果你需要在x64的编译环境环境下连接Access数据库你需要修改为
如果你需要在x64的编译环境环境下连接Access数据库你需要修改为
m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

为了更好的适配不同的编译环境，我将我的代码修改为
为了更好的适配不同的编译环境，我将我的代码修改为


m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);
当是32位程序的时候就为
当是32位程序的时候就为
当是32位程序的时候就为
m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);








然后重启一下PC，应该就可以编译成功了。
然后重启一下PC，应该就可以编译成功了。
然后重启一下PC，应该就可以编译成功了。
然后重启一下PC，应该就可以编译成功了。




这两天有个筒子叫我帮他爬这个网站http://bbs.baobeihuijia.com/forum-191-1.html上的失踪儿童信息，准备根据失踪儿童的失踪时的地理位置来更好的寻找失踪儿童，这种事情本就应该义不容辞,如果对网站服务器造成负荷，还请谅解。


这次依然是用第三方爬虫包BeautifulSoup，还有Selenium+Chrome，Selenium+PhantomJS来爬取信息。
通过分析网站的框架，依然分三步来进行。
第一步：获取http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接
http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接
第二步：获取每一个分页链接上所发的帖子的链接
第二步：获取每一个分页链接上所发的帖子的链接
第三步：获取每一个帖子链接上要爬取的信息，编号，姓名，性别，出生日期，失踪时身高，失踪时间，失踪地点，以及是否报案
第三步：获取每一个帖子链接上要爬取的信息，编号，姓名，性别，出生日期，失踪时身高，失踪时间，失踪地点，以及是否报案
起先用的BeautifulSoup，但是被管理员设置了网站重定向，然后就采用selenium的方式，在这里还是对网站管理员说一声抱歉。
1、获取http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接
获取
http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接




通过分析：发现分页的页面链接处于<div class="pg">下，所以写了以下的代码
通过分析：发现分页的页面链接处于<div class="pg">下，所以写了以下的代码
BeautifulSoup形式：


2.获取每一个分页链接上所发的帖子的链接
2.获取每一个分页链接上所发的帖子的链接
获取每一个分页链接上所发的帖子的链接






每个帖子的链接都位于href下
每个帖子的链接都位于href下
每个帖子的链接都位于href下
所以写了以下的代码：
所以写了以下的代码：
所以写了以下的代码：
BeautifulSoup形式：
BeautifulSoup形式：
BeautifulSoup形式：



获取每一个帖子链接上要爬取的信息，编号，姓名，性别，出生日期，失踪时身高，失踪时间，失踪地点，以及是否报案，并写入CSV中








通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
BeautifulSoup形式：
BeautifulSoup形式：
BeautifulSoup形式：
BeautifulSoup形式：




现附上所有代码，此代码仅供参考，不能用于商业用途，网络爬虫易给网站服务器造成巨大负荷，任何人使用本代码所引起的任何后果，本人不予承担法律责任。贴出代码的初衷是供大家学习爬虫，大家只是研究下网络框架即可，不要使用此代码去加重网站负荷，本人由于不当使用，已被封IP，前车之鉴，爬取失踪人口信息只是为了从空间上分析人口失踪的规律，由此给网站造成的什么不便，请见谅。








附上所有代码：
附上所有代码：
附上所有代码：
附上所有代码：




































配置步骤
1.在pycharm编译其中按上一篇文章简单粗暴：使用pycharm安装对应的Python版本第三方包，在包的搜索窗口输入Selenium，然后点击Install Package即可。




2.下载最新版本的Chrome浏览器安装


3.下载最新版本ChromeDrive.exe
可进入以下网址进行下载
http://chromedriver.storage.googleapis.com/index.html

下载下来为一个压缩包文件，解压缩，得到chromedrive.exe
chromedrive.exe


4.将下载的最新版本的chromedrive.exe拷贝到你的python3.x的安装目录，或者是C:Windows目录下
整个Selenium+Chrome的环境配置就完成了
我的python3.x安装路劲为：C:\Users\Administrator\AppData\Local\Programs\Python\Python35\




到这里整个Selenium+Chrome环境配置就完成了，快使用下列代码打开你的浏览器吧

5.上面代码每次都会打开一次Chrome浏览器，但是假如我们循环次数较多时，每次都打开一次浏览器会干扰我们在桌面上的其他工作，所以这里介绍一个无界面的浏览器包PhantomJS
首先在官网下载地址：http://phantomjs.org/download.html
或者CSDN下载频道以往版本：http://download.csdn.net/detail/tylanbin/7211747
然后得到压缩包，解压，将里面的PhantomJS.exe文件复制到你的python安装路径或者C:windows下，只要是系统的环境path目录都行
PhantomJS.exe文件复制到你的python安装路径或者C:windows下，只要是系统的环境path目录都行
然后只需要把上面driver=webdriver.Chrome()改成driver=webdriver.PhantomJS()即可


driver=webdriver.PhantomJS()即可
PhantomJS


Meshlab是一个强大的三维模型处理的软件，在三维点云的处理方面也十分强大，不仅仅可以用三维点云重构出三维模型，还可以计算出三维点云每个点的法向量，这在逆向工程和基于三维点云的隐式曲面重建中非常有用。
   我的Meshlab的版本是3.3，可以在网上自行下载破解版。
1.Meshlab读取三维点云
第一步：打开Meshlab软件
第二步：点击File菜单下的ImportMesh导入txt文档，需要选择你的txt文档中XYZ坐标之间的分隔符，导入成功后会显示你的三维点云数据
2.三维点云重建
点击下图图标，弹出右侧图层侧边栏
然后点击Fiter菜单下Normals，Curtavures and Oreientation下的Smooths normals on a point set计算三维点云的法向量，如下图
然后设置计算点云法向量的参数，默认就好，如有需要可以自行设置，点击Apply等计算完成然后点击Close关闭对话框
计算完点击法向量之后，点击Filter菜单下Remeshing Simplication and Reconstruction下的Surface Reconstruction：Ball Pivoting进行三维点云重建
然后设置三维点云重建参数，默认就好，也可以自行设置，点击Apply等重建完成，点击close关闭对话框
然后点击下列图标显示重建的三维模型，也可以设置光照等其他参数
以下为三维重建结果
3.法向量的导出与计算
三维点云的法向量的导出与计算有两种方式，一种是在上一节三维重建中我们已经得到了重建后的三维模型，那么每个点都带有法向量，可以直接导出即可，还有一种就是从杂乱的三维点中计算每一个三维点的法向量
3.1从三维模型中导出三维点云中每个点的法向量
接着第二节的步骤，点击File菜单下Export Mesh as 
然后在接下来的对话框中选择xyz格式
然后在 接下来的对话框中勾选Normal就可以生成文本格式的三维点以及三维点法向量
以下为文本格式的三维点坐标以及三维点法向量的结果
3.2 直接从三维散乱点云中生成三维点的法向量
然后点击Filter菜单下Normals，Curtavures and Oreientation下的Compute normals for point set计算三维点云的法向量，如下图
在弹出来的对话框可以自行设置参数，先Apply然后再Close
法向量的导出与3.1中的一样，可以自行参考。


以下为三维点云以及点云的法向量的可视化结果，点云表示为红色的点，法向量表示为绿色的线段
在程序开发中我们经常看见有一些软件左侧有目录树或者是图层树，点击之后就可以右侧View窗口显示相关的内容，其实实现这种机制有两种方法，第一种就是对MFC的View窗口进行窗口分割，左侧的窗口view类派生于CTreeView，其中CTreeView自带一个变量用于View中的树控件的控制。第二种方法就是用一个可停靠的面板嵌套一个对话框，再在对话框中添加树控件，同样可以达到相同的目的。
以下详解搭建步骤：
第一步：在VS2010中生成一个MFC经典风格的单文档程序，命名为CMyTestMFCDlg，编译下保证没有出错。

第二步：为该工程添加一个新类CMyDockablePane，派生于CDockablePane。



第三步：新建上述类完成后，在CMainFrame头文件中包含该类的头文件#include
 "MyDockablePane.h"
   声明该类的对象：



编译运行：


第四步：插入一个新的对话框，命名为IDD_DIALOG_DOCKDIALOG，在对话框属性中将Style设为Child，Border设为None。
为该对话框新建类：CDockDialog，基类为CDialogEx。
添加一个树控件，IDC_TREE_Test，为树控件关联一个控件变量m_TreeControl
在MyDockablePane.h中包含头文件#include
 "DockDialog.h"
添加CDockDialog
 类的成员变量：CDockDialog m_TestDlg;
添加CMyDockablePane的WM_CREATE和WM_SIZE消息响应函数
在函数中添加以下代码

CDockDialog类中重载虚函数OnInitDialog()，添加以下代码初始化树控件

CDockDialog头文件中添加#include "resource.h"




最后即可编译成功
最后即可编译成功






在网上看见一个对3D建模介绍十分全面的博客，来自中国科技大学图形与几何计算实验室刘利刚老师，介绍的非常棒，膜拜一下。
此处注明转载博客网址：3D建模与处理软件简介-中国科技大学刘利刚
3D建模与处理软件简介
刘利刚
中国科技大学
http://staff.ustc.edu.cn/~lgliu
 
【前言】自半年前笔者发表博客“什么是计算机图形学”以来，时常有人来向笔者询问3D模型的构建方法与工具。
笔者的研究方向是以3D技术为主，具体包括3D建模，3D处理及3D打印三个方面，在3D建模与处理方面从事了
十多年的研究，接触过很多3D相关的软件，在这方面有些经验。因此，特撰写此文，以帮助我们的学生及关注3D
技术的人了解3D建模和3D技术。本文仅仅为笔者根据自己的经验对3D建模与处理软件浅薄的理解，不涉及对技术
的深入讨论，是非学术性的。因此，笔者尽量尝试用通俗的语言介绍一下各种3D建模的软件和工具，以帮助还未接
触3D技术的学生来了解这些工具，以便在今后的科研和工作中能够选择合适的3D工具。笔者对本文的有些内容的理
解也是很有限的，值得进一步的学习和交流。有不当之处，还请读者谅解指正。
 
 
一、           专业3D建模软件
 
1.       3DS
 Max
美国Autodesk公司的3D
 Studio Max（前身是Discreet公司的，后被Autodesk收购）是基于PC系统的三维建模、动画
、渲染的制作软件，为用户群最为广泛的3D建模软件之一。常用于建筑模型、工业模型、室内设计等行业。因为
其广泛性，它的插件也很多，有些很强大，基本上都能满足一般的3D建模的需求。我们的学生也需要经常用到3DS
Max来构建模型。网上关于3DS
 Max的教程和学习视频非常多，使用者众多。
 
2.       Maya
Maya也是Autodesk公司出品的世界顶级的3D软件，它集成了早年的两个3D软件Alias和Wavefront（这两个软件在我
读博时就非常有名，当时就代表了最先进的动画及数字技术，我曾用过Wavefront）。相比于3DS
 Max，Maya的专
业性更强，功能非常强大，渲染真实感极强，是电影级别的高端制作软件。在工业界，应用Maya的多是从事影视
广告，角色动画，电影特技等行业。我们的学生也经常用Maya来制作和渲染3D模型，生成漂亮的渲染结果放在论
文中。
 
3.       Softimage
Softimage曾经是加拿大Avid公司旗下的专业的3D动画设计软件，后被Autodesk收购。它在影视动画方面，特别是
角色功能非常强大。许多电影，比如《泰坦尼克号》、《失落的世界》、《第五元素》等，都曾使用Softimage来
制作大量的惊人的视觉效果。
 
4.       LightWave
LightWave是美国NewTek公司开发的一款3D动画制作软件，具有悠久的历史，我在读博时曾接触过。它的功能非
常强大，特别是在生物建模和角色动画方面功能异常强大，广泛应用在电影、电视、游戏、网页、广告、印刷、
动画等各领域。在电影《泰坦尼克号》中细致逼真的船体模型及其他众多游戏的场景和动画都曾使用LightWave
来制作的。
 
5.       Rhino（犀牛）
Rhino是美国Robert
 McNeel公司开发的专业3D造型软件，它对机器配置要求很低，安装文件才几十兆，但“麻雀虽
小，五脏俱全”，其设计和创建3D模型的能力是非常强大的，特别是在创建NURBS曲线曲面方面功能强大，也得到
很多建模专业人士的喜爱。在与上海造船厂研究所的合作项目中，我们用Rhino来进行船体曲面的NURBS建模和修
改，非常方便灵活。
 
6.       Cinema
 4D
Cinema 4D (C4D)是德国Maxon公司的3D创作软件，在苹果机上用得比较多，特别是在欧美日为最受欢迎的三维动
画制作工具。2009-2010年我在美国哈佛大学访问期间，经常看到学生用C4D在进行3D建模和动画的设计。
 
7.       Creator
MultiGen-Paradigm公司开发的Creator是专门创建用于大型3D虚拟仿真的实时三维模型的软件。其强大之处在于管
理3D模型数据的数据库，使得输入、结构化、修改、创建原型和优化模型数据库非常容易。前几年与一家从事数
字城市的公司合作时我们就用Creator快速创建大量的城市建筑模型，并且生成数据库来管理这些模型，还是相当
的方便。
 
注：从上述介绍可知，美国Autodesk公司当之无愧是当今3D建模和动画的“老大”，拥有3DS
 Max、Maya和Softimage等
3D建模和动画专业软件。3DS
 Max和Maya在3D建模方面各有特色，前者更为大众化些，相对容易掌握些，后者在专
业级的行业应用更为广泛，特别在制作动画和高质量渲染方面强于前者。我们的学生用Maya的相对多些，包括建模，
渲染和动画制作。Softimage和LightWave在3D动画方面表现强大。Rhino对NURBS曲面的支持更好。Creator适合于构
建大量的3D模型并构建数据库进行管理和修改。
 
 
二、           CAD建模和产品设计软件
 
1.       AutoCAD
AutoCAD (Auto Computer-Aided Design)是美国Autodesk公司出品的自动计算机辅助设计(CAD)软件，用于二维绘图
、文档规划和三维设计。适用于制作平面布置图、地材图、水电图、节点图及大样图等。广泛应用于土木建筑、装
饰装潢、城市规划、园林设计、电子电路、机械设计、航空航天、轻工化工等诸多领域。大家买房时看的房型图大
部分都是用AutoCAD来做的。
 
2.       CATIA
Catia由法国Dassault
 Systems公司开发的CAD/CAE/CAM一体化的三维软件，支持产品开发的整个过程，从概念(CAI
D)，到设计(CAD)，到分析(CAE)，到制造(CAM)的完整流程。可帮助制造厂商设计未来的产品，并支持从项目前阶
段、具体的设计、分析、模拟、组装到维护在内的全部工业设计流程，在机械行业，航空航天、汽车工业、造船工
业等应用广泛。其实体造型和曲面设计的功能非常强大。我读博期间曾接触过Catia，在它上面写过一个NURBS曲
面转换的插件程序。
 
3.       SolidWorks
SolidWorks是世界上第一个基于Windows开发的三维CAD系统，后被法国Dassault
 Systems公司(开发Catia的公司)所
收购。相对于其他同类产品，SolidWorks操作简单方便、易学易用，国内外的很多教育机构（大学）都把SolidWork
s列为制造专业的必修课。SolidWorks在杭州有专门的研发机构，我有个学生硕士毕业后在那里进行研发工作。
 
4.       UG
 NX
UG NX由美国Unigraphics
 Solutions (UGS)公司开发的CAD/CAE/CAM一体化的三维软件，后被德国西门子公司收购
。广泛用于通用机械，航空航天、汽车工业、医疗器械等领域。现在西门子公司在上海有专门的研发机构对UG
 NX
产品进行升级完善，我有2个学生博士毕业后在那里负责产品的开发和维护。
 
5.       Pro/E
Pro/Engineer是美国PTC公司(Parametric
 Technology Corporation)旗下的CAD/CAM/CAE一体化的三维软件。在参数化
设计，基于特征的建模方法具有独特的功能，在模具设计与制造方面功能强大，机械行业用的比较多。
 
注：除了上述所介绍的CAD/CAE
 /CAM系统软件（它们各有特色，在市场中都占有一定的份额）外，还有其他一些同
类产品，比如法国Missler公司的Topsolid和以色列Cimatron公司的Cimatron。一般在机械设计与产品研发相关的行业中
才会接触到这些软件，专业性比较强，在网上很容易能找到它们的相关资料。
 
 
三、           3D雕刻建模软件：笔刷式高精度建模软件
 
3D雕刻建模软件(Sculpturing
 modeling)，也称为笔刷式高精度建模软件，顾名思义，就是像艺术家那样用不同的“笔
刷”工具在模型表面上进行“雕刻”的自由创作。建模过程就像玩橡皮泥一样，利用拉，捏，推，扭等操作来对几何
进行编辑，生成任意的高度复杂和丰富的几何细节（如怪兽的复杂表面细节）。这些工具的出现颠覆了过去传统三
维设计工具的工作模式，解放了艺术家们的双手和思维，告别过去那种依靠鼠标和参数来笨拙创作的模式，完全尊
重设计师的创作灵感和传统工作习惯。
 
1.       ZBrush
美国Pixologic公司开发的ZBrush软件是世界上第一个让艺术家感到无约束自由创作的3D设计工具。 ZBrush能够雕刻
高达 10 亿多边形的模型，所以说限制只取决于的艺术家自身的想象力。
 
2.       MudBox
MudBox是Autodesk公司的3D雕刻建模软件，它和ZBrush相比各有千秋。在某些人看来，MudBox的功能甚至超过了
ZBrush，可谓ZBrush的超级杀手。
 
3.       MeshMixer
最近，Autodesk公司又开发出一款笔刷式3D建模工具MeshMixer，它能让用户通过笔刷式的交互来融合现有的模型
来创建3D模型（似乎是类似与Poisson融合或Laplacian融合的技术），比如类似“牛头马面”的混合3D模型。
值得注
意的是，最新版本的
MeshMixer
还添加
3D
打印支撑优化新算法，值得关注。我们
Siggraph
 Asia 2013
的论文“
Cost-effe
ctive
 Printing of 3D Objects with Skin-Frame Structures
”也给出了一种为
3D
打印加尽可能少的支撑材料的新算法（详
见我的博文“
经济节约型的3D打印技术
”），该算法也是具有较好的市场前景，我们也在努力进行产业转化。
 
4.       其他
其他还有一些同类的3D雕刻建模软件，比如3DCoat，Sculptris，Modo等。这里就不再详细介绍了。
 
注1：在工业界，人们更偏向于使用四边形网格(quad
 mesh)，而不是三角网格，一个很重要的原因就是这些雕刻建模
工具善于在四边形网格上进行细节的生成和编辑，因为四边形网格的边更能反应物体表面的流线方向(edge
 flow)。我
们Pacific Graphics 2010的一篇论文B-mesh，就是在建模过程中同时生成具有良好流线方向的四边形基网格(base
 mesh)，
然后直接可以导入到这些雕刻软件中进行进一步的细节雕刻建模。
 
注2：虽然这些笔刷式建模工具上手容易，给了用户便利的方式进行3D细节建模，但是，要想真正构建一个细节复杂
和逼真的3D模型还是不容易的，除了用户需要熟练掌握软件的各种工具及雕刻技巧外，还需要用户具有较好的艺术和
绘画功底。
 
 
四、           基于草图的3D建模软件
 
基于笔划或草图的交互方式由于其符合人类原有日常生活中的思考习惯，交互方式直观简单（就像在图纸上画画
一样来构建3D模型），是最近十多年来计算机图形学中研究的热点建模方法之一。这方面的研究论文有很多，比
如Siggraph 1999年的Teddy，到Siggraph
 2006年的SmoothSketch，Graphics
 Interface 2007的Magic Canvas，Siggraph 
2007年的FiberMesh，SigCHI
 2010年的ICanDraw等。最近，我们也提出一种基于阴影引导的草图交互的3D建模的
技术“Modeling
 by Drawing with Shadow Guidance”，从已知的模型数据库中提取信息来引导用户的笔划交互，能构
建更为精准的3D模型，该工作发表在Pacific
 Graphics 2013上。
虽然在科研上提出了很多基于草图的
3D
建模技术，
但是至今仍未能有比较成熟的商业化的软件出现，可能是因为要理解不同用户的划线和草图还是一件比较困难的
事情。对于一些比较规则的物体，比如建筑、家具等人造物体，这种方式相对可行些，比如
Google
的
SketchUp
（在
国内我们也称为“草图大师”）。
SketchUp
是一套面向普通用户的易于使用的
3D
建模软件。使用
SketchUp
，创建
3D
模型就像我们使用铅笔在图纸上作图一般，软件能自动识别你画的这些线条，加以自动捕捉。它的建模流程简单
明了，就是画线成面，而后拉伸成体，这也是建筑或室内场景建模最常用的方法。
SketchUp
还可以将你自己的制
作成果发布到
Google
 Earth
上和其他人共享，或者是提交到
Google
的
3D
 Warehouse
（
Google
的
3D
模型库）。当然你
也能从
Warehouse
那儿得到想要的素材，以此作为创作的基础。很有趣的是，在
2012
年
Google
公司的
SketchUp
被美
国
Trimble
公司收购了。去年出了个
Trimble
 SketchUp 2013
，网评似乎不太好。不知其是否能继续免费。
最近国内出
了一款叫做“
EasyToy
”的采用草图式的
3D
建模软件，适用于卡通动漫形象与玩具的设计。但我还没有试用过，不知
用户体验如何。另外，日本东京大学的
Takeo
 Igarashi
教授也发布了一些基于草图式的
3D
建模系统，比如
Teddy
，在
其主页上可以下载到。
另外，值得一提的是，基于草图的交互方式在现在正在兴起的
Web3D
建模领域会有新的广阔
空间。
Web3D
建模在稍后会介绍。
 
 
五、           基于照片的3D建模软件
 
从物体的照片来进行3D模型的构建，是计算机图形学和计算机视觉的一大研究方向，称为基于图像的几何建模(Ima
ge based modeling)。这种技术已逐渐成熟且走向实用阶段，最近有些软件能够让用户拿着普通相机或者手机对着要
建模的实物从不同视角拍摄若干照片，然后软件就能根据这些照片自动地生成相应的3D模型。这种基于
图片的建
模技术提供给了非专业建模人士来构建
3D
模型的工具。
 
1.       Autodesk
 123D
Autodesk公司最近发布了一套平民级的建模软件Autodesk
 123D，用户不需复杂的专业知识，只要为物体从不同的
视角拍摄几张照片，该软件就能自动地为其生成3D模型，而且软件是完全免费的。
(1)    Autodesk
 123D是一款免费的3D CAD 工具，用户可以使用一些简单的图形来设计、创建、编辑三维模型，或者
在一个已有的模型上进行修改。
(2)    Autodesk
 123D Catch是建模软件的重点，用户使用相机或手机来从不同角度拍摄物体、人物或场景，然后上传
到云，然后该软件利用云计算的强大计算能力，可将数码照片中几分钟的时间内转换为3D模型，而且还自动带上
纹理信息。我们试用过几次，感觉它的使用还是很方便的。但是其生成的3D几何的细节不多，主要是通过纹理信
息来表现真实感的。有时软件也会失败，生成的几何是不正确的。
(3)    Autodesk
 123D Make是将3D模型转换为2D的切割图案，用户可利用硬纸板、木料、金属或塑料等低成本材料
将这些图案迅速拼装成实物，从而再现原来的数字化模型。这让用户能够“制造”出所造的3D模型，有点像3D打印
的雏形。目前123D Make只有Mac版的。
(4)    Autodesk
 123D Sculpt是一款运行在iPad上的3D雕刻软件（前面已介绍过），通过绘画的方式在模型上雕刻
几何细节。
 
2.       3DSOM
 Pro
3DSOM Pro是一款从高质量的照片来生成3D建模的软件，它可以通过一个真实物体的照片来进行3D建模，并且制
作的模型可以在网络上以交互的方式呈现。
 
3.       PhotoSynth
微软开发了一款产品PhotoSynth，可将大量的照片做3D处理，但是它不是真正创建3D模型，而是根据照片之间的
相机参数及空间对应关系，建构一个虚拟的3D场景，使得用户能够在从不同角度和位置来查看该场景，而显示的
场景图像是由给定的照片所合成的。其基本原理来自于Siggraph 2006的论文“Photo
 Tourism: exploring photo colle
ctions in
 3D”及其他相关论文。
 
注：从多幅不同角度拍摄的照片来重建3D物体，从技术原理上来讲是可行的，但是由于算法的一些步骤，比如图像
中物体特征点的检测和匹配，相机参数的估计等，还会出现不太正确的结果，使得重建结果有时不够稳定，甚至不
正确。随着技术和计算能力的不断发展，相信这些会逐步得到解决。到时，从照片来重建3D模型的技术可能是最为
方便的3D建模技术了，因为人人都有手机，随时都可以拍照上传到云端来构建3D模型。如果有了大数据库的支持，
从单张照片来构建3D模型也是可能的，可以参看我们的Siggraph
 2011的论文。
 
 
六、           其他3D建模软件
 
1.       人体建模软件
关于构建人体模型及动画，首推Metacreations公司的Poser软件（俗称“人物造型大师”）和开源的MakeHuman软件
。这两款软件都是基于大量人类学形态特征数据，可以快速形成不同年龄段的男女脸部及肢体模型，并对局部体
形进行调整。可以轻松快捷地设计人体造型、动作和动画。我读博期间用过Poser构建人体模型来做morphing，
还是蛮方便的。
 
2.       城市建模软件
加拿大Esri公司的CityEngine是三维城市建模的首选软件，可以利用二维数据快速创建三维场景，并能高效的进行
规划设计。应用于数字城市、城市规划、轨道交通、管线、建筑、游戏开发和电影制作等领域。另外，CityEngine
对ArcGIS的完美支持，使很多已有的基础GIS数据不需转换即可迅速实现三维建模，缩短了三维GIS系统的建设周
期。该软件的核心技术是Siggraph 2001的论文“Procedural
 Modeling of Cities”及其他相关论文，早期是ETH Zurich
大学的Pascal Mueller研究小组创办的Procedural公司开发的，后被Esri公司收购。
 
3.       其他小巧的3D建模软件
下面的这个网页还介绍了一些其他3D建模相关的软件或程序：
http://tech.sina.com.cn/s/2008-10-20/08192519895.shtml
这些软件大部分都非常小巧，而且是开源且完全免费的。有很多媒体工作者和艺术家用这些小软件来制作3D作品
，其中Blender, K-3D, Art of Illusion, Seamless3d,
 Wings3D等软件的使用面稍微广泛些。有兴趣的读者可以到网上找
到相关资料去了解和学习，这里不作详细介绍。
 
4.       网页3D
 (Web3D)建模工具
最近，出现了一些基于网页(web)开发的3D模型设计软件，即基于WebGL，可以在浏览器中完成3D建模的工具。
比如3DTin，TinkerCAD（去年被Autodesk收购）等，它们的界面简单直观，有Chrome等浏览器插件插件，可以在
线生成3D模型，直接存在云端，并在社区分享模型。
在互联网的时代，
Web3D
技术将被越来越被广泛使用，建议
大家多关注。
 
 
七、           虚拟现实软件和平台
 
虚拟现实软件本质上不是用于3D建模的，而是用来对生成好的3D模型和场景提供关于视觉、听觉、触觉等虚拟的
模拟，让用户如同身历其境一般。相关软件也有很多，这不是本文的重点，只大致提及几个比较常见的。
 
1.       VirTools和Quest3D
法国VirTools公司的VirTools和美国Act-3D公司的Quest3D都是元老级的虚拟现实制作软件，简单来说，就是工业
或游戏用的实时图形渲染引擎，是3D虚拟和互动技术的集成工具。可以让没有程序基础的美术人员利用内置的行
为模块快速制作出许多不同用途的3D产品，如网际网络、计算机游戏、多媒体、建筑设计、交互式电视、教育训
练、仿真与产品展示等 。网上的学习资料比较多。
 
2.       Unity3D
 (U3D)
Unity Technologies开发的Unity3D
 (U3D)是最近几年冒出来的新秀，是一个全面整合的专业虚拟3D和游戏引擎。
它在制作虚拟现实及3D游戏方面上手非常容易，操作简单，互动性好，有强大的地形渲染器。我们的学生使用
U3D可以很快地制作一个3D游戏，因此也强烈推荐大家学习使用。
 
3.       Vega
Vega是MultiGen-Paradigm公司开发的用于实时视觉模拟和虚拟现实应用的开发引擎，提供很多的C/C++语言的应
用程序接口API，结合其应用程序的图形用户GUI界面软件LynX，可以迅速创建各种实时交互的3D环境。对于开
发3D游戏和3D场景漫游的项目非常方便。
 
4.       OSG
 (Open Scene Graph)
OSG (Open Scene Graph)是一套开源的基于C++平台的应用程序接口API，能够让开发者快速、便捷地创建高性能
、跨平台的交互式图形程序。它将3D场景定义为空间中一系列连续的对象，能够对3D场景进行有效的管理。由于
OSG是开源和完全免费的，很多3D应用的软件都选用OSG作为基础架构。几年前，我们与一个公司合作开发的义
齿软件就选用OSG作为管理3D数据的框架，使得开发非常方便。
 
5.       其他
其他的一些用于3D应用程序开发的软件开发包(SDK)或API还有GLUT(OpenGL
 Utility Toolkit), OpenGL Performer, 
CG2 VTree, Quamtum3D Mantis等。有兴趣的读者也可以去了解一下。
 
注：相比于十年前，由于有了上述开发平台和开发包，现在开发一个看起来还比较cool的3D应用程序或游戏不是那么
困难，随着技术的不断发展和3D应用不断渗入到各行各业，相信以后会更加方便。
 
 
八、           开源3D网格处理库
 
1.       PCL
 (Point Cloud Library)
Point Cloud Library (PCL)是一个独立的大型跨平台的处理二维/三维图像和点云数据的C++模板库，它基于许多第三
方库，比如Boost、Eigen、FLANN、VTK、CUDA、OpenNI、Qhull等，实现了大量点云相关的通用算法和高效数
据结构，涉及到点云获取、滤波、分割、配准、检索、特征提取、识别、追踪、曲面重建（包括Poisson重建算法
）、可视化等。早期的PCL是由Dr.
 Radu Bogdan Rusu在德国慕尼黑工业大学读博士期间开发的，目的是要为三维
点云数据处理的研究及应用，建立出一个共同的基础架构。另外，PCL利用OpenMP、GPU、CUDA等先进高性能
计算技术，通过并行化提高程序实时性。集成了Kinect Fusion重建算法。有人将其地位比喻为3D的OpenCV，足以
可见其对3D的开发和研究的重要性，我们的学生在科研过程中经常用到PCL。
 
2.       CGAL
 (Computational Geometry Algorithms Library)
CGAL是一套开源的C++算法库，提供了计算几何相关的数据结构和算法，诸如三角剖分（2D约束三角剖分及二维
和三维Delaunay三角剖分），Voronoi图（二维和三维的点，2D加权Voronoi图，分割Voronoi图等），多边形，多
面体（布尔运算），网格生成（二维Delaunay网格生成和三维表面和体积网格生成等），几何处理（表面网格简
化，细分和参数化等），凸壳算法，搜索结构（近邻搜索，kd树等），插值，形状分析，拟合等。CGAL功能强
大，是我们学生做科研的必备程序库之一。
 
3.       MeshLab
MeshLab是一个开源的处理三角形网格的C++算法库，提供了三角网格的数据结构和算法，诸如曲面重建、编辑
、修复、光顺、编辑等算法。MeshLab也是我们学生做科研的必备程序库之一。
 
4.       其他开源网格处理库
OpenMesh：由德国RWTH
 Aachen大学的Leif Kobbelt研究小组开发的C++网格处理库
Libigl: 由瑞士Ethz大学的Olga
 Sorkine研究小组开发的C++网格处理库
Trimesh：有美国Princeton大学的Thomas
 Funkhouser研究小组开发的C++网格处理库
 
5.       网格剖分(Delaunay)与生成库
Triangle, NetGen：平面三角网格生成库
TetGen, Stellar：空间四面体网格生成库
 
注：这里列出了几个主要的网格处理的C++代码库，我们的学生在学习和科研的过程中会经常用到它们。当然，网上
还有其他的各种算法库，对我们的科研和开发都是非常有用，我们有时也会用到，这里就不再详述。
 
 
九、           基于扫描（逆向设计）的3D建模软件
 
随着深度相机的普及及扫描仪的价格迅速下降，人们采集三维数据变得容易，从采集到的三维点云来重建三维
模型的工作在最近几年的Siggraph(Asia)上能常见到，比如我们Siggraph
 Asia 2010，Siggraph
 2013等的工作。最近
几年产生了许多基于点云数据的建模与处理（或逆向工程和设计）的软件，而且各种扫描设备的生产厂商也会发
布相应的点云重建的软件。
 
1.       Geomagic
Geomagic (俗称“杰魔”) 包括系列软件Geomagic
 Studio、Geomagic Qualify和Geomagic
 Piano。其中Geomagic Studio
是被广泛使用的逆向工程软件，具有下述所有特点：确保完美无缺的多边形和 NURBS 模型处理复杂形状或自由
曲面形状时，生产效率比传统 CAD软件提高数倍；可与主要的三维扫描设备和CAD/CAM软件进行集成；能够作
为一个独立的应用程序运用于快速制造，或者作为对CAD软件的补充。是我们学生科研的必备软件之一。
 
2.       RapidForm
RapidForm是韩国INUS公司出品的逆向工程软件，提供了新一代运算模式，可实时将点云数据运算出无接缝的多
边形曲面，使它成为 3D扫描数据的最佳化的接口，是很多3D扫描仪的OEM软件。我们购买的Konica
 Minolta的激
光扫描仪Range 7就是用RapidForm来进行逆向设计。我们SGP
 2010的ARAP参数化算法作为目前为止最好的参数化
算法之一，被集成到了RapidForm软件中。
 
3.       ReconstructMe
ProFactor公司开发的ReconstructMe是一个功能强大且易于使用的三维重建软件，能够使用微软的Kinect或华硕的
Xtion进行实时3D场景扫描（核心算法是Kinect
 Fusion），几分钟就可以完成一张全彩3D场景。我们尝试过，效果
还可以。ReconstructMeQt提供了一个实时三维重建利用ReconstructMe
 SDK（开源）的图形用户界面。
 
注：法国ManCTL公司开发的Skanect为Mac平台的第一款3D 扫描软件，也支持者华硕的Xtion或者微软的Kinect进行
实时3D 扫描。
 
4.       Artec
 Studio
Artec公司出品的Artec
 Eva, Artec Spider等手持式的结构光3D扫描仪，重量轻且易于使用，成为许多3D体验馆扫描
物体的首选产品。我试用过Artec Eva后感觉还是需要较多的技巧才能扫描好物体，而且后期需要用软件进行较多
的处理，比如数据的去噪、修复、光滑、补洞等。
同时，
Artec
公司还开发了一款软件
Artec
 Studio
，可以和微软的
Kinect
或华硕的
 
Xtion
以及其他厂商的体感周边外设配合使用，使其成为三维扫描仪。
Kinect
通过
Artec
 Studio
可以
完成模型扫描，然后进行后期处理，填补漏洞、清理数据、进行测量、导出数据等。不确定它是否也使用了
Kinect 
Fusion
算法。
 
5.       PolyWorks
PolyWorks是加拿大InnovMetric公司开发的点云处理软件，提供工程和制造业3D测量解决方案，包含点云扫描、
尺寸分析与比较、CAD和逆向工程等功能。
 
注1：全球四大逆向工程软件除了Geomagic
 Studio和RapidForm外，还包括ImageWare和CopyCAD，由于后两者我不
熟悉，在此就不介绍了，有兴趣的读者可以到网上去找相关资料了解。
 
注2：微软的Kinect作为快速获取3D数据的传感器，可以作为3D扫描仪来使用，我们曾使用3台Kinects来扫描人体全
身，论文发在2012年的IEEE
 TVCG期刊。现在有多款软件或者开发库（包括上面介绍的PCL，ReconstrutMe，Artec
Studio，Skanect），支持将单台Kinect作为手持式扫描仪来扫描物体，其核心都是Kinect
 Fusion算法。
 
 
十、           后记
 
最近，随着人们对3D建模的需求越来越大，出现了许多其他形式的3D建模软件和工具，比如Blokify, 基于块状化
3D建模软件，特别适合孩子们制作模型。这些新出现的工具我这里就不一一介绍了，大家可以关注网上的一些科
技新闻网站、论坛或博客等。
 
 
1.       3D模型数据浏览与转换软件
上面介绍的大部分的软件或库都支持查看不同格式的3D模型数据。如果仅仅是浏览或查看现有的3D模型数据，我
个人推荐3D Exploration软件（相当于查看图像的ACDSee软件），它是一个专门用来查看各种格式的3D模型文件，
包括3DS数据 (*.3ds,
 *.prj, *.asc)、LightWave Objects (*.lwo,*.lw)、 DirectX(*.x)、AutoCAD
 (*.dxf)、Object File Fo
rmat (*.off)、Wavefront
 (*.obj)等，还可以用鼠标交互从不同视角来查看。而且还能查看各种图像文件，包括bmp
、rle、dib、gif、jpg、png、tif、tga、pcx等。当然也能查看带纹理的3D模型。3D
 Exploration是我的机器必装软件
之一，强烈推荐。另一个我推荐的同类软件是Deep Exploration，它除了可以浏览3D数据外，还可以转换数据格式
（最新版本还支持Sketchup文件），同时它还可以对你的模型进行编辑及添加注释制作动画等，我也强烈推荐。
注：现在有很多3D数据格式，几乎每个3D建模软件都会定义自己的数据格式。几种比较公认的3D数据格式有VR
ML、obj、off、stl
 (用于3D打印的数据格式)等。现在有些组织在力推3D数据的标准。相信随着3D技术的发展，这
些格式都将越来越标准化和统一化。对各种数据格式需要更多了解的，可以到网上找找，比如：
http://www.cnblogs.com/sunliming/archive/2012/02/28/2372398.html
 
 
2.       3D模型渲染软件
本文介绍的各种3D建模软件一般都能渲染3D模型，但要得到更为逼真的真实感渲染效果，还可以使用专门的3D
模型渲染软件，比如Pixar Renderman、POV-Ray、 V-Ray、 Mental
 Ray、Final-Render等，这里就不详细介绍。一
般我们使用Maya进行渲染放在论文中，已经足够漂亮了，读者可以在我们的许多论文中看到利用Maya渲染的结果
图。
 
3.       其他相关的软件
本文以介绍3D建模的软件和库为主，另外，还有许多跟3D技术相关的软件和开发包我没有提及，比如图像处理、
可视化、处理医学图像、建筑设计、装潢设计及艺术设计等。读者可以根据各自的专业去网上寻找所需要的专业
软件。
 
4.       学习使用3D建模软件
相比于2D平面软件Adobe
 Photoshop，Illustrator，CorelDraw等，学习3D软件难度稍大些，需要了解和掌握一些3D
的概念、3D交互习惯和技巧。因此，想要在短期熟练掌握好一个3D建模软件，是不太可能的，需要多用、多摸索
、多体会。网上有许多教材和视频，您可以跟着去学习。总之，您要多去玩，就能玩熟了。如果您能有个确定的
目标来学习3D软件，比如完成项目或者论文中所需要的效果，您就能掌握得更快！因为，带有确定目标和任务的
学习，是最高效的学习。但您如果暂时用不到，暂可不必花太多时间去学习，学了但不去用，也容易忘。只要您
学习软件的速度快就可以，而这正是我们对学生的基本要求。
 
5.       3D时代的来临
最近两年3D打印机的兴起，引起人们的极大好奇与广泛关注，同时也有些争论。虽然还不清楚它是否能成为人们
生活中不可或缺的一项技术，但不可否认，3D打印技术确实已经给世界带来巨变，已逐渐在某些领域表现出巨大
的价值，比如，提高了制造行业的生产力，在医学领域得到了广泛应用（义齿，假肢，器官等），为艺术家提供
了有效的创作工具等等。个人认为，3D打印提供给了平民零技能制造的技术，会朝着“私人定制”（个性化需求）
的方向发展；随着大量草根参与到3D的设计和制造，3D打印将逐步颠覆人们创造东西的能力。正因人们对3D模型
有了巨大的需求，3D打印技术才使得计算机图形学“落地”，这也使得我们这个学科终于在人们生活中体现了巨大
的价值。关于3D打印技术将给大规模工业经济带来的巨大冲击以及给我们的生活将带来的巨大变化，这里不展开
讨论，我将以后抽空撰文加以详述。
我们再来看一下这几年的一些巨头科技公司的变化，
2011
年微软公司的
Kinect
让人们获取
3D
数据的硬件代价降低了许多，
2012
年
3D
打印的兴起造就了两家上市公司
Stratasys
和
3D
 Systems
，
2013
年苹果公司收购了
Kinect
的核心技术公司
PrimeSense
，谷歌公司收购了大名鼎鼎的机器人公司
Boston
 Dynamics
，这
些都说明，越来越多的高科技企业在快速发展
3D
科技，
3D
时代已经来临！
随着人们对
3D
技术有了越来越多的需求，本文所介绍的
3D
建模工具将会发挥出更为巨大的价值。随着科学和技术的发展，云计算与物联网的进一步发展，将会出现越来越便利的
3D
建模工具，比如
Autodesk
 123D
正在将
3D
技术从专业变成非专业，人们接触
3D
技术的门槛将越来越低，创造的
3D
模型越来越丰富。我坚信，日后
3D
技术将“飞入寻常百姓家”，会越来越平民化，且成为人们生活中重要的一部分。
当然，当前人们对3D技术的了解还远远不够，大部分的人对3D技术仍然很陌生。另一个我个人看好的市场就是3D
教育与培训，普及3D技术与培养3D技术人才已时不我待。
另外，现在也开始有了一些
3D
模型共享的网站在运营，
能够提供给全世界的用户下载、上传、分享
3D
数据；类似于十多年随着
Internet
发展而产生的图像共享网站，这些
3D
数据共享网站也将在不久的未来产生巨大的价值，
3D
模型数据也将逐步进入“大数据时代”。
我们很庆幸成为
3D
科技新时代的弄潮儿，有很多的机会和挑战在等待着我们！让我们一起努力！
Python的强大除了其简单的语法以及易用性，还有其不得不说的海量的第三库的支持。
但是，我们电脑上由于需要可能安装了多个版本的Python，如Python2.X和Python3.X,这时候我们除了在电脑上要解决多个Python版本共存的问题，还需要针对不同的版本安装支持不同版本的第三方库，而且在安装第三方库的时候在cmd.exe上可能会出现输入字符错误，或者其他的错误，简而言之，就是没有交互式的界面，不能让人像傻瓜一样简单的安装第三方包，但是Pycharm这个强大的pythonIDE（集成开发环境）给我们提供了这种便利，以下就介绍如何使用Pycharm安装不同Python版本的第三方库。
1.打开Pycharm,我的Pycharm版本为Pycharm4.5.4


2.打开File菜单下的Setting菜单，如下






3.选择Settings下Project:Python下的Project Interpreter，并选择Python的版本，点右侧+号进入第三方库的搜索界面


4.在第三方包的搜索界面输入要安装的第三方包的名字，点击左下角Install Package按钮，后会提示安装成功




到这里，第三步就安装完成了，快去试一试新的库的强大功能吧！
三维模型重建顾名思义就是从一些数据（点云，图片，三维轮廓线等）重建出物体的三维逼真的三维模型，在其重建的过程中针对不同的数据的的三维重建会有不同的处理算法，如针对点云数据的三维重建有很多种重建方法,如基于Delaunay三角化，Voronoi图，隐式曲面等方法，另外在三维模型的重建过程（MarchingCube，RayCast,网格构建等）以及三维模型生成后的后处理算法（三维网格简化，三维网格加密，三维模型表面光滑，三维模型的空洞修补等等）也是层出不穷，在这其中需要用到大量的三维图形学知识（从简单的画点画线算法到复杂的体绘制算法，以及光照计算，材质映射等）。在最后的实现方面致力于提高算法效率和运行性能，各种加快算法实现的三维数据结构（KD树，八叉树等）的提出和实现，以及压榨计算机和服务器性能的并行算法（OpenMP，MPI）等，减少算法实现过程中的内存占用以及运行时间（降低空间复杂度以及时间复杂度）。三维模型重建上的优秀算法或者是优秀实例我也只是管中窥豹，上面所提到的有些名词我也是大致了解，我尽自己最大的能力介绍下自己闲暇时间以前做过的相关三维模型重建的实例和其他相关的关于三维重建方面的知识，毕竟能力有限，知识面还有待拓展。
1.编程语言
是用的编程语言是C/C++，基本上相关的图形学方面的实现都是使用C/C++作为开发语言，不是说别的语言如Java，Python等语言不好，确实在效率方面以及内存处理方面C/C++有着比较大的优势，而且现在市面上的三维图形库其底层语言就是C/C++，所以使用起来更加方便。一门语言有其适用的场景和场合，正如Java在WEB和APP上面的天然优势一样，C/C++在图形处理，图像识别以及其他的图形处理领域也有着很大的优势。
2.我所使用的第三方库
（1）三维图形库OpenGL
OpenGL(Open Graphics Library)，OpenGL图形绘制库，有着优秀的二维和三维图形API，是一个功能强大的三维图形绘制的底层库，有着大量的调节三维模型视觉效果的函数，例如光照，模型材质，纹理等等。早期OpenGL包GLUT依然比较强劲，但是其不能用于64位平台的编译，而且GLUT官方已经不维护了，那么有一个新的FreeGlut横空出世，支持最新的OpenGL绘图标准，并且支持64位平台的编译，能够完全取代老化的GLUT库。


（2）三维图形库VTK
VTK（Visualization Tool Kit）同样也是一个优秀的三维图形库，近年来相当的火爆，它以OpenGL作为底层绘制语言进行封装，用户不需要考虑太多的光照以及材质影响到模型可视化效果的设置，这些VTK都已经帮你做好了，你需要考虑的是如何从原始数据绘制出你的图形。其内部封装了大量的三维图形处理函数，基本上你所能想到的算法都能找到影子，比如著名的面绘制方法MarchingCube，体绘制方法Raycast等等，往往你能在阅读他的帮助文档的时候看到一个意想不到的功能。


（3）计算机视觉库OpenCV
OpenCV（Open Source Computer Vision Library）今年来大热的计算机视觉库，同样以C/C++作为底层语言，封装了大量的图形处理和计算机视觉领域的算法，比如说图像识别领域，机器人，人类视觉仿真，好像现在大热的人工智能领域也开始使用OpenCV进行视觉领域方面的处理。


（4）矩阵运算库Eigen
在三维图形处理过程中通常需要大量的矩阵运算，而Eigen是一个轻量级的矩阵运算库，其函数API涵盖了几乎所有的矩阵运算，但是它的使用只需要包含一个头文件，不需要过于复杂的配置就可以使用已经封装好的各种矩阵运算函数。


（5）并行计算库OpenMP
OpenMP可以在你把项目代码构建好之后也仍然可以通过几行代码将你的程序自动的进行并行化计算，使用起来非常的简单，并行计算可以大幅度的提高你的程序的运行速度以及计算的效率。如果你的IDE是VS，那么你只需要简单的开启OpenMP就可以了，然后在VS中包含其头文件就可以使用OpenMP封装的函数进行并行程序设计。


其他的如CGAL（几何算法库），QT（图形界面库，不过本人更喜欢用老掉牙的MFC）等等。


3.我所接触到的三维重建类型
（1）点云三维重建（隐式曲面重建）
原始三维点云（三维点云以及法向量）-斯坦福兔子1889个点，采用OpenGL从底层写的径向基隐式曲面点云重建方法


采用径向基隐式曲面重建后的三维模型

（2）医学序列图片三维重建（使用VTK进行医学图片处理，模型构建采用MarchingCube算法）
重建结果

（3）OpenCV双目视觉重建（医学冠脉三维重建，VTK做可视化）
左视图A

右视图B

使用OpenCV做的三维冠脉重建，VTK做的显示

（4）基于轮廓线的三维模型重建
轮廓线


重建的三维模型




4.结语
万事开头难，作为一个刚刚入门三维重建领域的人写这篇文章心中的感觉简直是战战兢兢，三维模型重建方面的知识浩如沧海，我只不过是只窥得了寥寥数星。只不过自己想把自己学习到的一些知识与有缘人交流分享，共同进步。不知以后还不会不在三维领域工作与发展，不过之后的事情谁又知道呢。
后面我会详细介绍一些三维重建算法以及一些实例。



好久都没有动Python了，自从在网上买了《Python网络数据采集》这本书之后一直没有时间写自己的小的Demo,今天再网络上无意中看见
http://www.cnblogs.com/mfryf/p/3695844.html：

这篇博客，自己想要不花一个小时复习下BeutifulSoup，然后实现与上面的那个博客一模一样的功能，其实自己以前就想写这样的一个东西，像上面博主一样，也只是想每天看一下博客的访问量有没有上涨，哈哈哈哈哈。
最近需要用到三维点云数据，但是网上大部分的数据资源的数据格式都是杂乱无章而且没有清晰的数据说明，为了方便，自己整理了常用的三维点云数据，格式都是按照X坐标空格Y坐标空格Z坐标这种数据格式排列，方便数据读取和进行三维点云的重建实验。
   其中的数据包含了著名的斯坦福兔子，大象，马，凳子，人头等三维点云数据，显示的效果如下：






















以下为三维点云的重建效果：
三维点云数据我已经上传到我的下载频道：常见的三维点云数据，已经整理数据格式 - 下载频道 - CSDN.NET  http://download.csdn.net/detail/hw140701/9852949
常见的三维点云数据，已经整理数据格式 - 下载频道 - CSDN.NET http://download.csdn.net/detail/hw140701/9852949



另外一些常见的三维模型的下载地址为：常见的三维模型下载地址：http://www.cc.gatech.edu/projects/large_models/
希望可以帮助到有缘人0.0




VTK根据几个点插值成样条曲线，然后以样条曲线为中心线，生成圆柱体管道
最近在项目中有一种结构体数据需要存储，数据结构体如下

现在需要根据在m_Vector中的每一个结构体的ID来获得其对应的pinwei值，所以就写了一个函数，如下
然后上程序上面测试，对于一个size大约15000的容器，大概每次循环需要进行20次FindpinweiValueInVector（）函数的调用，所以在Vector中查找值的最坏的情况是时间复杂度为O(n),即进行15000*20，这还是每次的循环，当一个菜单执行完毕整整花了大概6个半小时左右，程序运行效率低下。


所以，必须要有一种查找效率较高的容器，就想到的map,map为平衡二叉树，查找效率为对数级别，时间复杂度为O(logN)，查找相对来说较快，1000大小的数据最坏只需要3次就可以查找到，15000只需要4次多就可以查找到。
所以声明一个map<int,double>型的容器，用于建立mystruct的ID与pinwei之间的对应关系，然后将Vector存储的值插入到map中，然后在map中根据键值（ID）查找Value(pinwei)。
函数如下



总结：以前在项目中用惯了STL的Vector，因为其比数组来的方便，不需要定义数组长度，可以不断的pushback(),但是其在大数据量中的查找效率简直令人发指，所以以后在什么时候得根据特定的情况使用特定的容器，不要习惯性的使用Vector。
后来又测试了下，用hash_map更快。


MFC项目开发过程中需要获取某个树控件下某个树节点下所有的子节点的文本，添加到某个组合框上，网上的相关代码差不多是遍历整个树控件，所以自己就封装了一个函数，用于获取指定树节点下的所有的子节点的文本然后添加到某个组合框中，其中获取的文本被压入CString类型的容器保存。

1.OpenMP介绍
OpenMP 是 Open MultiProcessing 的缩写，用于共享内存并行系统的多处理器程序设计的一套指导性编译处理方案。在项目程序已经完成好的情况下不需要大幅度的修改源代码，只需要加上专用的pragma来指明自己的意图，由此编译器可以自动将程序进行并行化，并在必要之处加入同步互斥以及通信。当选择忽略这些pragma，或者编译器不支持OpenMp时，程序又可退化为通常的程序(一般为串行)，代码仍然可以正常运作，只是不能利用多线程来加速程序执行。OpenMP提供的这种对于并行描述的高层抽象降低了并行编程的难度和复杂度，这样程序员可以把更多的精力投入到并行算法本身，而非其具体实现细节。对基于数据分集的多线程程序设计，OpenMP是一个很好的选择。



2.VS2010中开启OpenMP
右键项目属性-配置属性-C/C++-语言-OpenMP支持-点击是。






3. OpenMP并行化测试
在已有源代码的基础上，要对此段代码进行并行化处理，只需要使用

程序结果




当我们修改为8个线程的时候，其结果为




可以看出4个线程和8个线程都执行了cout << "Thread  " << omp_get_thread_num() << endl; //omp_get_thread_num()是获取当前线程id号这句代码，而且先后顺序没有特定的从线程1到线程2执行，可以看出简单的实现了并行块的设计。


下面以一个较大的for循环来测试OpenMP并行程序与普通串行程序的速度问题。
需要对for程序代码段执行并行化需要添加#pragma omp parallel for
串行化程序：





并行化程序：





这个问题简单但是又容易犯错，当代码出现错误的时候让人非常的懊恼；
比如有两个类：CleftView和CImplicitModelView两个类，现在有这样的需求需要在两个类中都调用对方的函数，所以就在CleftView.h中加上#include "CImplicitModelView"，在CImplicitModelView.h中加上#include "CleftView.h"，
但是当我们兴高采烈地的去编译时，会出现缺少分号的错误，但是当我检查了很久的代码，发现并没有出现缺少分号，这个原因是因为类与类之间的头文件互相包含所导致的。
解决方法就是：
在两个类的头文件中进行类先导声明，然后在各自类的.cpp文件中进行头文件的包含
例如：
(1)在CleftView.h中进行CImplicitModelView的类先导声明class CImplicitModelView;(有分号),然后在CleftView.cpp文件中包含CImplicitModelView类的头文件，#include"CImplicitModelView.h"
(2)在CImplicitModelView.h中进行CIeftView的类先导声明class CleftView;(有分号),然后在CImplicitModelView.cpp文件中包含CIeftView类的头文件，#include"CIeftView.h"
在CImplicitModelView.h中进行CIeftView的类先导声明class CleftView;(有分号),然后在CImplicitModelView.cpp文件中包含CIeftView类的头文件，#include"CIeftView.h"
CImplicitModelView
CImplicitModelView
这样，就可以实现在两个类中进行互访问
这样，就可以实现在两个类中进行互访问
vtk中没有可以直接在三维空间中绘制三维空间圆的类以及函数，在这里，编写了以函数以任意的三维点为中心，任意半径，绘制平行于Z=0平面的圆，
可以用于批量绘制三维空间的圆。也可改写为平行为X=0或者Y=0的平面。

参考代码为：在三维空间中Z=给定值平面绘制半径为给定值的圆，圆内部填充
在我们建立三维模型的过程中，当用多边形网格或者是三角面片来近似的表示曲面的表面时，曲面被离散成许多的平面多边形，如果我们的网格较大，离散度较粗，在模型表面使用明暗处理后，两两相邻的多边形会出现凸起或者是凹陷的折痕，在连接处显得比周围处亮或者暗，这就是所谓的马赫夫效应，如下图所示
针对于出现的马赫夫效应，我们需要进行明暗处理，消除或者是减少三维模型的马赫夫效应，使其看上去更加的光滑美观，常用的明暗处理技术有双线性光强插值—Gouraud明暗处理技术和双线性法向插值-Phong明暗处理技术。以下展示经过明暗处理前后结果对比
OpenGL提供了两种着色模式
void glShadeModel ( GLenum mode)，恒定着色
GL_FLAT，光滑着色GL_SMOOTH，而GL_SMOOTH中则是使用了Gouraud明暗处理技术，对于Phong明暗处理技术可以参见http://blog.csdn.net/dalewzm/article/details/46291397
http://blog.csdn.net/silangquan/article/details/10011169

Gouraud明暗处理算法在处理亮度的不连续性方面很有效，但是在明暗强度函数的斜率急剧变化处仍然可以看到马赫夫效应，不能完全消除光强度的不连续性。而Phong明暗处理是对表面的法向量而不是亮度进行插值，大大改善了Gouraud模型对高亮度镜面反射光的处理，在每一点都是用法向量的一个近似值，所以一般法向量插值的结果要优于亮度插值，在很大程度上消除了马赫夫效应，但是会大大增加明暗处理的时间。


鉴于此，我在用MC算法建立三维模型的时候，由于我的网格设置较大，导致出现了马赫夫效应，即模型表面的可视化效果不光滑，如下：



于是使用OpenGL自带的Gouraud明暗处理技术，以一个MC算法生成的章鱼模型为例子，效果如下
相比未使用明暗处理的模型，使用了Gouraud处理的模型从可视化的角度上来看更加的光滑，效果更好。




转载地址：http://www.cnblogs.com/bluestorm/p/3168720.html
这三种类型各有各的优点，比如CString比较灵活，是基于MFC常用的类型，安全性也最高，但可移植性最差。string是使用STL时必不可少的类型，所以是做工程时必须熟练掌握的；char*是从学习C语言开始就已经和我们形影不离的了，有许多API都是以char*作为参数输入的。所以熟练掌握三者之间的转换十分必要。
MFC PictureControl控件上自适应显示图片，分图片失真或者图片不失真两种





图片不失真，但是没有铺满整个图片控件区域：


问题描述：给定两个非空的链表，表示两个非负整数。 数字以相反的顺序存储，每个节点包含一个数字。 添加两个数字并将其作为链表返回。
测试代码：

医学raw文件下载地址（自己的下载频道）:1:http://download.csdn.net/detail/hw140701/9832153
2:http://download.csdn.net/detail/hw140701/9832151
没有积分的可私信我。
VS2010-MFC在状态栏上添加进度条比在VC6.0中更加简单，不需要再从CStatusBar类中派生子类。
仔细查看VS2010生成的MainFrm.h文件我们可以看出，m_wndStatusBar已经是CMFCStatusBar的对象了，而不是CStatusBar对象。
CStatusBar对象。
所以就去微软的官网查看CMFCStatusBar的帮助文档，有中文，太好了
CMFCStatusBar的帮助文档，有中文，太好了
微软提供的MFC的帮助文档，有中文

微软提供的MFC的帮助文档，有中文

CMFCStatusBar类的帮助文档
此类自带进度条，只需要调用就可以了






以下为如何在VS2010单文档程序中在进度栏上添加进度条
步骤1:如上图所示，将m_wndStatusBar从protected型变量改成public型变量；
m_wndStatusBar从protected型变量改成public型变量；
步骤2：在MainFrm.cpp中添加进度条的标识IDS_PROGRESS
步骤2：在MainFrm.cpp中添加进度条的标识IDS_PROGRESS




并在资源文件字符串表String Table中新增一个字符串IDS_PROGRESS，如下图
并在资源文件字符串表String Table中新增一个字符串IDS_PROGRESS，如下图








步骤3：在CMainFrame的OnCreate()函数中添加以下代码，用于初试化状态栏
步骤3：在CMainFrame的OnCreate()函数中添加以下代码，用于初试化状态栏




步骤4：在View中某个读取文件的响应函数，添加以下代码，即可在状态栏显示文件加载进度条，以及当前文件大小和百分比信息




当我们点击读取文件后，文件总长度可以通过FILE类的Ftell函数进行获取，然后就可以在状态栏查看当前文档的加载进度以及已经加载文件的大小




整个编写流程就完成了，比VC 里面简单太多了。
使用VTK生成分布在球内部或者表面的三维点云数据，可以设置球的中心，半径以及生成的三维点的个数并选择可以设置在球内部生成或者是球表面生成。

问题描述:将一个string型的字符转成int型的数字，需要处理字符串输入的各种情况，如字符串前面的空格，+号，-号等符号。
     测试代码：

在原先的博客VTK读取一个TXT文档中的三维点坐标绘制三维点云基础上，有小伙伴询问是否可以以点云中每一个三维点的坐标为中心绘制一个小的球体，用于标识特征点，这种就让我想到了化学里面的分子结构，所以就在原有博客的基础上进行了改写，实现了点云不是以点的方式而是以小球体形式显示出来，实现了大量球体的同时绘制。
不多说直接贴代码：

整体图：




局部的线框显示细节图：




局部表面显示细节图：


LeetCode第一题：
问题描述：给定一个整形的数组，在给定一个特定的整数值，要求返回这个整形数组中两个元素的和等于给定的整数的元素索引。
STL容器vector是新手入门STL最常用也是最好用的容器类，其不像array需要固定大小，而是可以动态的在容器尾部或者是中间插入元素，相当的好用，但是我们往往会在一个程序中向vector中压入了很多的元素，在使用完vector中的元素之后，只是会用clear去清理vector中的元素，有些小伙伴认为清空容器就等于释放了内存，其实真正的是这样的吗？我们不妨来做一个测试。
首先我们声明一个double型的容器，往里面压入了10000000个元素，然后用clear方法，看是否能真正的释放掉vector所占的内存，这里用SDK中的 GetProcessMemoryInfo方法来获取当前进程的所占用的内存。
代码如下：

程序运行结果：




我们可以看到使用clear方法虽然清空了vector中的元素，但是并没有释放掉vector所占用的内存，高效的管理内存是程序设计所要求的，C++ 11有了一个全新的shrink_to_fit()方法，该方法与clear()搭配使用，将vector所占用大小缩小到合适的范围，以下进行测试
代码如下：






我们可以看到，使用shrink_to_fit方法可以快速的释放掉vector所占用的内存。
MFC的界面太丑了，但是学会之后写一写简单的可交互的PC端程序还是可以的，但是用VS2010自己生成的MFC工程上的控件程序还是MFC经典风格，实在是看不下去，如下




要使其按钮带有Win7风格，带有Aero的美化效果，就需要在MFC工程的头文件Stdafx.h文件中，加入以下代码








但是如果想要有更加好的效果，还是自绘吧。
Python并不是我的主业，当初学Python主要是为了学爬虫，以为自己觉得能够从网上爬东西是一件非常神奇又是一件非常有用的事情，因为我们可以获取一些方面的数据或者其他的东西，反正各有用处。
这两天闲着没事，主要是让脑子放松一下就写着爬虫来玩，上一篇初略的使用BeautifulSoup去爬某个CSDN博客的基本统计信息（http://blog.csdn.net/hw140701/article/details/55048364），今天就想要不就直接根据某个CSDN博客的主页的地址爬取该博客的所有文章链接，进而提取每一篇文章中的元素，我这里是提取每一篇博客中的文字信息。
一、主要思路
通过分析CSDN博客的网站源码，我们发现当我们输入某博客主页网址时，如：http://blog.csdn.net/hw140701
在主页会有多篇文章，以及文章的链接，默认的是15篇。在主页博客的底部会有分页的链接，如下图


如图所示，一共65篇分5页，每一页中又包含了15篇文章的链接。
所以我们总体的思路是：
1.输入博客主页地址，先获取当前页所有文章的链接；
2.获取每个分页的链接地址
3.通过每个分页的链接地址获取每一个分页上所有文章的链接地址
4.根据每一篇文章的链接地址，获取每一篇文章的内容，直到该博客所有文章都爬取完毕


二、代码分析
2.1分页链接源码分析
用浏览器打开网页地址，使用开发者工具查看博客主页网站源码，发现分页链接地址隐藏在下列标签之中


所以我们通过下列代码所有分页链接进行匹配



2.2分页上每一篇文章链接源码分析
得到每一个分页的链接后，对每一个分页上的文章链接源码进行分析，其源码如下


通过分析，所以我们采取以下的方法进行匹配


通过对每一篇文章中的网站源码进行分析，发现其内容位于源码中的以下位置


所以通过下列代码进行匹配

现附上全部代码，注释部分可能有错，可以根据此代码自行修改，去爬取某CSDN博客中的任意元素

使用findContours（）查找图片轮廓线，并将轮廓线坐标点输出，访问二维vector，使用迭代器和下标两种方式


先说说题外话，OpenGL是一个跨平台优秀的三维可视化库，而在Windows中内部封装的OpenGL还是1.1版本，不吐槽，维护自身Direct3D的发展也是情有可原。如果你是Win32系统，编译环境也是Win32的话，对OpenGL只是练习，那么就用简单的GLUT来配置OpenGL环境就好了，但是如果你想用X64(64位)环境来编译的话，这个GLUT会编译不成功，因为它不提供64位下的使用环境，而且太老掉牙了，版本已经不更新了，那么这个时候你就需要freeglut这个包(国外推荐使用freeglut，摒弃glut),这个包提供了32位(x86)和64(x64)两种编译环境下可用的静态链接库和动态链接库。关于64位环境编译的程序与32环境编译的程序之间的区别就是32位程序在系统中最多能申请到2G内存（2的32次方字节），而64位程序在系统中最多能申请到（2的64次方字节）的内存，64位程序理论上可以使用当前PC机上所装载的全部的内存，极大的提高了程序的性能。下面介绍了Glut和FreeGlut的详细配置教程，以便在32位编译环境和64位编译环境都得心应手的使用OpenGL。
*我的VS2010的安装位置：D:\Program Files (x86)\Microsoft Visual Studio 10.0
1.关于Glut的配置
1.1. 下载GLUT。Windows环境下的GLUT下载地址：
http://www.opengl.org/resources/libraries/glut/glutdlls37beta.zip



1.2
1.3 
1.4 
1.5 

2.Freeglut的配置




我使用的环境具体是Win764位+VS2010+Freeglut2.8.1,而Freeglut2.8.1这个版本支持VS2010,可使用最高的版本3.0，同样支持各种VS版本。


2.1 Freeglut的下载
Freeglut2.8.1:http://download.csdn.net/detail/hw140701/9830604
Freeglut其他版本的下载地址：
Freeglut3.0版本：
http://www.transmissionzero.co.uk/software/freeglut-devel/

http://download.csdn.net/detail/hw140701/9830606



2.2 生成VS2010 64位编译环境下下可用的Freeglut的包含头文件，静态链接库lib,动态链接库dll。
解压缩包，打开解压后的压缩文件夹，里面会有一个VisualStduio的文件夹，如下


    打开VisualStudio文件夹，里面会有VS2008，VS2010，VS2012三个版本的


    选择VS2010，打开项目文件freeglut.sln。


    选择Release版本，x64平台编译，右键解决方案，点击全部生成


然后你会在解压的文件夹下发现两个新的文件夹inclue和lib文件夹




include文件夹下会有GL文件夹，里面包含了freeglut所需用到的头文件，freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h,注意这里的glut.h与Glut包的glut.h文件不相同。
lib文件夹下会有一个x64文件夹，里面包含了freeglut.lib和freeglut.dll文件。
2.3 具体配置
 Freeglut配置本质上与Glut的配置原理相同，不过，我们这里配置的是64位的freeglut，稍微有一些不同。这里也简单介绍一下freeglut32位的配置，如果你要生成freeglut32可用的包含文件，静态链接库以及动态链接库，请参见上节中64的生成方法，不要需要将编译平台改为Win32，此节不再赘述。
1.将\freeglut-2.8.1\freeglut-2.8.1\include\GL文件夹下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2.将freeglut.lib复制到D:\ProgramFiles (x86)\Microsoft Visual Studio 10.0\VC\lib下。
    3.将freeglut.dll复制到C:\Windows\System32下
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\SysWOW64下。
    1.将\freeglut-2.8.1\freeglut-2.8.1\include\GL文件夹下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2.将freeglut.lib复制到D:\ProgramFiles (x86)\Microsoft Visual Studio 10.0\VC\lib\amd64下，注意这里是放64位静态链接库的地方。
    3.将freeglut.dll复制到C:\Windows\SysWOW64下
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\ System32下。
 
最后在使用的时候只需添加#include<GL/freeglut.h>就可以了。
2.4 Freeglut3.0的配置
    类似于Freeglut2.8.1的配置
下载网址就是
http://www.transmissionzero.co.uk/software/freeglut-devel/
选择freeglut3.0.0 MSVC Package




解压缩文件，有include,bin,lib三个文件夹
2.4.1 Freeglut3.0 32位的配置
    1.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\include\GL下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\lib下的
freeglut.lib复制到D:\Program Files (x86)\Microsoft Visual Studio10.0\VC\lib。
    3.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\bin下的
freeglut.dll复制到C:\Windows\System32下。
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\SysWOW64下。
 
2.4.2 Freeglut3.0 64位配置
    1.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\include\GL下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2. \freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\lib\x64下的
freeglut.lib复制到D:\Program Files (x86)\Microsoft Visual Studio10.0\VC\lib\amd64下。
    3. \freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\bin\x64下的
freeglut.dll复制到C:\Windows\ SysWOW64下
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\ System32下。




3.Glew的配置
3.1 Glew的下载
http://www.cnblogs.com/Akunwjy/p/Freeglut.html













VTK生成指定圆心以及指定半径的三维球，并将其导出为obj三维模型格式



Meshlab中载入qiu.obj




可在meshlab中将其转换为其他的三维数据格式或者提取球体表面的三维点云。
显示文件夹窗口默认显示效果：


加上语句bi.ulFlags=BIF_BROWSEINCLUDEFILES;后不仅可以显示文件夹，还可以显示文件：

加上语句bi.ulFlags=BIF_BROWSEINCLUDEFILES;后不仅可以显示文件夹，还可以显示文件：




加上语句bi.ulFlags=BIF_NEWDIALOGSTYLE;后窗口可以调整大小，并有新建文件夹按钮：

加上语句bi.ulFlags=BIF_NEWDIALOGSTYLE;后窗口可以调整大小，并有新建文件夹按钮：

加上语句bi.ulFlags=BIF_NEWDIALOGSTYLE;后窗口可以调整大小，并有新建文件夹按钮：






加上语句bi.lpszTitle=L"指定要处理的文件夹";
 后在窗口内显示提示用户的语句：

加上语句bi.lpszTitle=L"指定要处理的文件夹";
 后在窗口内显示提示用户的语句：

加上语句bi.lpszTitle=L"指定要处理的文件夹";
 后在窗口内显示提示用户的语句：

加上语句bi.lpszTitle=L"指定要处理的文件夹";
 后在窗口内显示提示用户的语句：








一、创建状态栏的两种方法
CStatusBarCtrl和CStatusBar两个类来完成
CStatusBar两个类来完成
                  //设置状态栏文本
                  m_StatusBar.SetText("分栏一", 0, 0);
                  m_StatusBar.SetText("分栏二", 1, 0);
                  m_StatusBar.SetText("分栏三", 2, 0);
                  //下面是在状态栏中加入图标
                  m_StatusBar.SetIcon(1, 
                                SetIcon(AfxGetApp()->LoadIcon(IDR_MAINFRAME),
                 //----------------让这个状态栏最终显示在对话框中-------------
                  RepositionBars(AFX_IDW_CONTROLBAR_FIRST,AFX_IDW_CONTROLBAR_LAST,0);
二、实时显示系统时间信息
在程序中添加WM_TIMER消息响应函数，这里以基于对话框程序为例
第一种创建状态栏的方法
void CCJCZDlgDemoDlg::OnTimer(UINT_PTR nIDEvent)
{
// TODO: 在此添加消息处理程序代码和/或调用默认值
CTime t = CTime::GetCurrentTime();
CString str;
str.Format("%04d/%02d/%02d  %02d:%02d:%02d",t.GetYear(),t.GetMonth(),t.GetDay(),t.GetHour(),t.GetMinute(),t.GetSecond());
m_StatusBar.SetText(str, 2, 0);


CDialogEx::OnTimer(nIDEvent);
}

m_wndStatusBar.SetPaneText(2,str);
    冠脉三维重建就是从两幅不同角度拍摄的冠脉医学图片根据相机参数(角度)重建出原有的三维冠脉形态。
    具体文献可以参考：
      1.黄家祥. 冠状动脉树三维骨架重建方法的研究[D]. 天津大学, 2003.
      2.王国铸. 单臂冠脉造影三维重建与定量分析[D]. 华中科技大学, 2012.
      3.郝培远. 冠脉造影三维重建定量分析(QCA)及最佳投照角度的研究[D]. 南方医科大学, 2011.等文献





这里以黄家祥这篇文章的数据作为例子，具体的冠脉三维重建步骤可见这篇文章黄家祥. 冠状动脉树三维骨架重建方法的研究[D]. 天津大学, 2003。
以下为其中的一个实验所给出的数据，两幅不同角度的图片为。




         图A                               图B




图A和图B的相机参数分别为RAO 0，CAUD35和LAO 80，CRAN15。

图A和图B的相机参数分别为RAO 0，CAUD35和LAO 80，CRAN15。




















有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。

有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。

有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。






    匹配的结果如下：
匹配的结果如下：
















上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。

上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。

上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。












以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）

以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）

以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）

以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）












总体上来看，重建效果与论文中最后给出的结果类似，VTK封装了OpenGL底层的绘图命令，所以在光照与材质方面不需要我们去过多的设置就会有逼真的三维显示效果。
总体上来看，重建效果与论文中最后给出的结果类似，VTK封装了OpenGL底层的绘图命令，所以在光照与材质方面不需要我们去过多的设置就会有逼真的三维显示效果。









1.SkinMag MFC美化界面库
总所周知，MFC的皮肤比较呆板，有各种各样的MFC界面库可以供我们使用，来修改程序的外观。C++界面库可以参见：http://blog.csdn.net/witch_soya/article/details/10982451
在这里介绍一种配置比较简单的MFC界面库SkinMagic。
可从这里下载SkinMagic2.4破解版：http://download.csdn.net/download/wbxyzwh/9693071
下载解压后，文件夹文件如下：
2.SkinMagic在VS2010 MFC程序中的配置
2.1文件拷贝
将下列三个文件以及所有的*.smf皮肤文件拷贝至建立的MFC工程文件目录下




2.2
在stdafx.h中加入头文件和库的引用，如下：



皮肤的调用有两种方法，一是直接从皮肤文件中调用，另一种方法是从资源文件中调用，分别说明如下：




在CxxxApp::InitInstance()中的加入以下代码如下：

2.5 将皮肤应用到程序上
3. SkinMagic界面库各个皮肤效果
一个基于指针和重载操作符的数组类设计Array,可以进行数组范围检查，与平常看到的类而言，这个类的编写让人感觉逻辑十分清晰，以及更加可以理解面向对象程序设计理念。
Arry.h




当初学Python进一个Python学习群，不久之后群主大大就发了自己写的一个爬虫，就是爬取www.mzitu.com网站上的妹纸图片，看完之后，惊为天人，一脸懵逼，觉得群主大大好厉害，当初自己进群的初衷以及学Python的初衷就是为了做爬虫，然后慢慢的开始。所以说这次，就是为了实践一下，爬取这个网站上的所有的图片，别邪恶哦，虽然是隐藏福利，我只是为了写爬虫实践，我只是为了写爬虫实践，我只是为了写爬虫实践！！！


网络爬虫会给网站服务器造成巨大负荷，所以，本次实践的源码仅供参考交流，不宜用于商业应用，由此造成的任何法律责任本人不予承担。


为了得到这个网站上所有的妹子图片，就得分析网站的架构，通过分析发现http://www.mzitu.com/all这个网址下有2013-2017年网站上所有的相册的链接，所以准备通过以下步骤爬取网站上的所有图片。


第1步：在http://www.mzitu.com/all下获取所有的相册的链接以及相册的名字
第2步：根据每个相册的链接得到每个相册每一个图片页面的链接
第3步：根据每一个图片的链接得到每一张图片的名字以及图片链接


第一步：在http://www.mzitu.com/all下获取所有的相册的链接以及相册的名字
在
http://www.mzitu.com/all下获取所有的相册的链接以及相册的名字
分析网站源码，查看每一个相册链接以及名字的所处标签




由图上可以看出，每一个相册的链接以及名称都位于<a >标签下


第二步：根据每个相册的链接得到每个相册每一个图片页面的链接
根据每个相册的链接得到每个相册每一个图片页面的链接
通过分析网站源码，分析每一个相册下每一个图片页面的链接
通过分析网站源码，分析每一个相册下每一个图片页面的链接




通过分析，发现每一个图片页面链接都处于<div class="pagenavi">的<a herf>下，但是只有几个图片的页面的链接，如上图所示，分别只有2,3,4.......65，但是图片页面的规律是相册链接+"/"+页面编号，在这里我们得到最大的页面编号65，就可以通过循环得到每一个图片页面的链接，所以在这里通过字符选取将编号压入进一个list，然后通过max方法得到最大编号，得到每一个相册图片页面的链接。


第三步：根据每一个图片的链接得到每一张图片的名字以及图片链接
根据每一个图片的链接得到每一张图片的名字以及图片链接
根据以上得到的图片页面链接，在每个页面内爬取图片的下载链接以及图片的名称
根据以上得到的图片页面链接，在每个页面内爬取图片的下载链接以及图片的名称




通过分析，图片链接以及名称都位于<img>标签内


通过以上的分析，将整个流程写为Python代码，在其中使用了第三方包Beautifulsoup,现附上全部代码，如有错误，请指教







刚刚开始写的时候，会遇到服务器断开链接，以及主机在一定时间内无法连接的错误，在百度上，谷歌上看了半天，可能是由于网站的反爬虫机制，我自己的解决办法如下，不知道你们可不可行：
1、关闭windows防火墙，爬完再开
2、采用多headers，伪装不同的浏览器
3、每下载完，sleep一下，减缓访问网站的频率，如果过快，网站服务器会认为你是爬虫
4、设置全局超时时间，有时候因为网速的问题会出现这种情况
5、设置代理IP


刚刚开始不知道为什么这个网站不能用代理IP访问，一访问，网站服务器就强制断开连接，后来又可以了，尽量用代理IP，免得被封IP，代理ip网站可上http://ip.zdaye.com/查询


在这个代码中，没有采用多线程机制，所以爬起来比较慢，勿喷。
最好在晚上爬，网速快。
爬取结果（隐藏福利）：






easysize.h自行在CSDN下载频道进行下载。
步骤一：把easysize.h拷贝到CMyDlg项目文件夹中，同时在CMyDlg的.h文件和.cpp文件中加入#include "easysize.h"；
步骤二：在CMyDlg类的h文件中，加入DECLARE_EASYSIZE，注意结尾处不要加“；”。
步骤三：在CMyDlg类的OnInitDialog()函数的结尾处加入INIT_EASYSIZE, 注意此处结尾处要加“；”。
步骤四：增加WM_SIZE消息响应函数OnSize()，在函数中加入UPDATE_EASYSIZE，注意此处结尾处要加“；”。
步骤五：在CMyDlg的cpp文件中添加EASYSIZE 的宏映射
EASYSIZE(control,left,top,right,bottom,options)
Control---控件的ID，需要设置的控件
left top right bottom---矩形框的位置，可以设置的参数：ES_BORDER、ES_KEEPSIZE、其他control的ID。
        ES_BORDER代表控件与边框的距离保持不变
        ES_KEEPSIZE代表控件的宽度和高度保持不变，left/right只能设置其中一个为ES_KEEPSIZE,top/bottom亦然。
Control  ID代表以另一个空间为参照
        具体注释如下，待设置控件记为ID1，参照控件记为ID2
        i left=ID2  ID1左边到ID2右边的距离保持不变（不管ID2如何变化）
        ii right=ID2 ID1右边到ID2左边的距离保持不变（不管ID2如何变化）
iii top=ID2  ID1上边到ID2下边的距离保持不变（不管ID2如何变化）
iv bottom=ID2 ID1下边到ID2上边的距离保持不变（不管ID2如何变化）
options---特别操作ES_HCENTER, ES_VCENTER and 0的结合。
0代表没有任何操作；
ES_HCENTER代表控件在left/right之间水平居中，此时left/right都不能设置成ES_KEEPSIZE，控件的宽度保持不变；
ES_VCENTER同理ES_HCENTER
注意： 布局风格的设置将很大程序影响控件在对话框上的布局，不同设置布局会有天壤之别！！！！


1.显示一个地球各大洲板块的轮廓线

2. 地图指北针图例



由于最近的需要在任意两个三维点直接绘制三维圆柱体管道，OpenGL太底层了，以至于什么东西都要自己写
在网上参考了如下的博客:
http://blog.csdn.net/ryfdizuo/article/details/6548257

http://blog.sina.com.cn/s/blog_5cd804e70100oxca.html

http://blog.sina.com.cn/s/blog_3d2759c90100rpnf.html

在上述博客中有详细的原理介绍，而我只是将代码改成自己可以用的形式，以便调用。
代码如下：









增大其传进去的两个参数：段数Slices，以及递归次数stacks，可以获得更加光滑的圆柱体绘制效果：
由于有这个需求，就是当在对话框设置一些数值的时候，可以在对话框上预览三维图像。
（1）生成一个基于对话框的程序，或者直接在单文档或者多文档上插入一个对话框，生成一个新的对话框类CGridingDlg,名字可以任取。
（2）配置好工程的OpenGL环境，不知道可以百度。
（3）在CGridingDlg的头文件中添加以下变量:
CGridingDlg的头文件中添加以下变量:






(4)重载对话框类CGridingDlg的虚函数OnInitDialog(),添加WM_TIMER消息，
(4)重载对话框类CGridingDlg的虚函数OnInitDialog(),添加WM_TIMER消息，
CGridingDlg的虚函数OnInitDialog(),添加WM_TIMER消息，
添加函数SetupPixelFormat(HDC hDC)---->用于设置OpenGL的像素格式
添加函数SetupPixelFormat(HDC hDC)---->用于设置OpenGL的像素格式
添加函数SetupPixelFormat(HDC hDC)---->用于设置OpenGL的像素格式



在对话框上面添加一个Picture控件，用于显示图形，设置其ID为IDC_STATIC_PictureRender
在对话框上面添加一个Picture控件，用于显示图形，设置其ID为IDC_STATIC_PictureRender
在对话框上面添加一个Picture控件，用于显示图形，设置其ID为IDC_STATIC_PictureRender






添加InitializeOpenGL()函数用于在对话框中初始化OpenGL。
添加InitializeOpenGL()函数用于在对话框中初始化OpenGL。
添加InitializeOpenGL()函数用于在对话框中初始化OpenGL。















RenderScene()函数添加进去，每隔多少毫秒就调用RenderScene()，时间间隔设置的越少就可以形成连续绘制的效果
RenderScene()，时间间隔设置的越少就可以形成连续绘制的效果






RenderScene()函数中封装一个函数，将该函数放置于RenderScene()函数的绘图代码区就好了。
RenderScene()函数的绘图代码区就好了。
绘制的效果如下
绘制的效果如下
绘制的效果如下
绘制的效果如下
绘制的效果如下




















但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。


























































































由于需要在三维空间中进行三维模型的碰撞与相交，为了加快检测的效率，考虑用三维物体包围盒。AABB与OOBB包围盒比起来原理简单，容易实现，为了更好的在三维空间中使用AABB包围盒，所以自己写了一个关于三维的AABB包围盒类AABB类，写了不同参数的构造函数，以及关于AABB包围盒的各种成员方法，虽然不是很全，但是可以满足日常的需要。
下面贴代码：
AABB.h


原文地址：Graphics Software  http://www.dgp.toronto.edu/~rms/links.htmlGraphics Software
贴出来贴出来贴出来，防止自己忘掉。。。。

Shape Modeling
Texturing
突发奇想，想写一个轰炸自己QQ好友的聊天轰炸机，哈哈哈，看了半天自己就写了一个Low的聊天轰炸机，纯粹依靠剪切板往聊天窗口复制文字，然后模拟回车按钮完成发送，写了一个简单的MFC对话框Demo，大牛自动跳出，无需再看。
主要代码如下：



1.单独拉出你想轰炸的QQ好友的聊天窗口，不要合在一起；
2.设置你想轰炸的QQ好友的昵称，就是你前面拉出来的单独的会话窗口好友的昵称；
3.选择你的BOOM.txt文件，里面是你想轰炸别人的话；
4.设置轰炸的次数。
截图如下：






源码链接：源码链接，Debug和Release版本，里面自带了我自己写的BOOM.txt




主要用到OpenCV自带的CascadeClassifier这个类下的detectMultiScale函数，其检测效果并不是很好
    

（1）静态图片上的人脸检测





可以看出，有些人脸没有检测出来，或者是检测出来有位置错误。
（2）摄像头人脸检测

OpenCV2中新增了方便的Mat类，但是OpenCV中仍然支持C语言的lplImage和CvMat结构，但是在有些时候，出于兼容性的考虑，需要进行Mat与IpIImage和CvMat的转换。
1.Mat转为lplImage和CvMat格式
1.1 Mat转为IplImage结构
Mat img(Size(400,400),CV_8UC3);
lplImage iplimg=img;//转为IplImage结构
1.2 Mat转为CvMat类型
CvMat cvimg=img;//转为CvMat结构
类型转换后，IplImage和CvMat与Mat共用同一矩阵数据，IplImage和CvMat没有引用技术功能，如果img中的数据被释放，那么iplimg和cvimg也同时失去数据。
2.IplImage和CvMat格式转为Mat
Mat类有两个构造函数，可以实现IplImage和CvMat到Mat的转换。这两个函数都有一个参数copyData,如果copyData的值为false,那么Mat将于IplImage或CvMat共用同一矩阵数据，如果值是True,Mat会申请新的内存，然后将IplImage或CvMat的数据复制到Mat的数据区。如果共用数据，Mat不会使用计数器来管理内存，需要自己来管理。建议将参数设置为True.
构造函数如下：
Mat::Mat(const CvMat *m,bool copyData=false)
Mat::Mat(const IplImage * Img,bool copyData=false)
例子：
IplImage *iplimg=cvLoadImage("LOL.jpg");
Mat im(iplimg,true);
CvMat类似上例。
问题描述：判断一个数是不是回文数。
回文数：就是从左往右念和从右往左念都是一样的，对称的一个数，如121,789987等。
注意：负数不是回文数，如-121。
解题思路一：如果一个数倒序输出后还等于原始的值，那么该数为回文数。
解题思路2：如果一个数最左边的数等于最右边的数，然后再去除这两个数，然后再判断最左边的数依然等于最右边的数，直到最后一个数，那么该数为回文数。


在leetcode里面提交的结果是第一种方法貌似比第二种要快。
用惯了AfxMessageBox（），总感觉这个东西不那么顺手，就想在状态显示当前程序的提示信息。
想要在任何类中都设置状态栏的信息，必须获取到m_wndStatusBar的指针。
所以第一步，将CMainFrame中的m_wndStatusBar的保护类型从保护改为public
m_wndStatusBar的保护类型从保护改为public




第二步：在任意类中添加下列代码，改变状态栏的提示信息



BeautifulSoup的find()和findAll()这两个函数在某些方面十分的相似，我们可以使用它们过滤HTML页面，并查找需要的标签组和单个的标签。
    这两个函数非常的相似：
    findAll(tag,attributes,recursive,text,limit,keywords)
    find(tag,attributes,recursive,text,keywords)
    
    
标签参数tag:可以传递一个标签的名称或多个标签名称组成的Python列表做标签参数。
    如：findAll({"tag1","tag2","tag3","tag4"})
    
    
属性参数attributes是用一个Python字典封装一个标签的若干属性和对应的属性值。
    如：返回HTML文档中attribute1和attribute2属性的tag标签
    findAll("tag",{"classs":{"attribute1","attribute2"}})
   
    
递归参数recursive是一个布尔变量。如果你想知道所抓取的HTML文档标签结构中有多少层的信息，如果recursive设置为True，findAll就会根据你的要求去查找标签参数的所有子标签以及子标签的子标签。如果recursive设置为False，findAll就只会查找文档的以及标签。findAll默认支持递归查找（recursive的默认值是True）,一般情况下不需要设置该参数。只是当你真正了解自己需要哪些信息，而且抓取速度非常重要时，就可以视情况设置递归参数。


    
文本参数text是使用标签中的文本内容去进行匹配，而不是标签的属性。
    如果我们需要查询某个网页中包含"the text"内容的文本数量，我们可以使用以下语句
    namelist=bsObj.findAll(text="the text")
    print(len(namelist))
    


    
范围限制参数limit，只能用于findAll方法。find()方法等价与findAll()方法limit参数等于1时的情形。如果你只对网页中获取的前x项感兴趣，就可以设置它。但是要注意的是这个参数设置之后获取的前几项结果是按照网页上的顺序排序的，也有可能不是你想要的结果。
  
    
关键词参数keyword，可以让你选择那些具有指定属性的标签。
   如：
alltext=bsObj.findAll(id="text")
        print(allText[0].get_text())
       
    .get_text()会把你正在处理的HTML文档中的所有标签都清除，然后只返回一个只包含文字的字符串。如果你正在处理一个包含许多超链接、段落以及标签的大段源代码，那么get_text()会把这些超链接、段落、以及标签全都清除，剩下不带标签的文字。
   通常在你准备打印，存储以及操作数据时，应该在最后再使用.get_text()去提取你想要的文本信息，在一般的情况下，应该尽可能的保留HTML文档的标签的结构。
参考书籍：数据结构（C++版）陈宝平主编
参考链接：http://www.cnblogs.com/charley_yang/archive/2010/12/08/1900256.html
二叉树类封装以及代码

题目描述：反转整数输出，注意的是输入被假定为一个32位有符号整数。当反整数溢出时，函数应返回0。
  今年的华为的实习生招聘笔试的第一个题与这个有点类似，不过华为的是输入两个整数，反转，然后输出两个整数反转后两个数的和。
  测试代码：

我们在进行爬虫时有的时候不可能只是在一个网站上进行内容上的爬取，理想中的爬虫应该是顺着一个链接从一个页面到另外一个页面，这需要获取页面上的所有的外链，同时收集每个页面上的内链。网站首页上不一定会发现外链，为了防止程序出错，就要递归深入到一个网站直到找到一个外链为止。
但在爬取的过程中出现了TimeoutError: [WinError 10060] 由于连接方在一段时间后没有正确答复或连接的主机没有反应，连接尝试失败。这个错误。
可能是由于访问网站频率过快，或者是我处于校园网，访问过快，被学校的服务的给限制了，或者是网速不好。所以在网上百度了下，设置了代理IP，结果完美运行，没有出现这个原因，最新的代理IP，自行百度即可。
最近有小伙伴在问，我想显示一个求得的三维点云中的每一个点的法向量的指向，怎么获得这种逼真的三维显示效果呢？当然是OpenGL啦，也是我自己用的比较习惯，所以就花了十几分钟帮助上面提问的小伙伴解决问题，然后也提供给大家一个查看三维点云法向量的工具，稍后我会在我的ＣＳＤＮ的下载频道上传该软件的Ｒｅｌｅａｓｅ版本供大家使用，主要的显示效果是三维点云中的每一个点使用实心球体表示，法向量用一个方向箭头和圆锥体表示，类似于坐标轴的指向。主要用到三个函数，Render3DCylinder（在任意两个三维点间画圆柱体），Render3DSphere（以任意三维点为中心画球体），Render3DCone（在任意两个三维点之间画圆锥体）。
其三个函数的主要代码如下：






整个程序的源码由于项目的关系不能给出，只能给出发布版本，不过主要的核心的功能是利用上述的三个函数实现的。相应的程序的Realease版本的下载地址：[免费]OpenGL+MFC显示三维点云中每一个点的法向量，Release版本-CSDN下载  http://download.csdn.net/download/hw140701/9970732http://download.csdn.net/download/hw140701/9970732



自己封装的三维向量类Vector.h,包含一些常见的三维向量类的操作符重载和一些基本运算，可以直接复制粘贴作为头文件包含在项目文件中。

Win32编译环境下，用ADO数据库连接Access数据库一般都不会报错，但是最近由于项目上的需要，程序需要编译成64位以便申请到更多的使用内存空间，当把编译方式从Win32改为x64的时候，突然出现了数据库连接出现未知错误，这时候就猜到了应该是编译环境的改变导致了数据库连接出错，在参考了其他大神的解决方案之后，终于解决了这个问题,我的环境为Win7
 64+MFC(VS2010)+ADO+Access2007。
    参考链接如下：
    http://blog.csdn.net/sundacheng1989/article/details/17925431
    http://www.cnblogs.com/bluedoctor/p/3925871.html
    http://blog.csdn.net/kirawoo/article/details/39032387
    http://blog.csdn.net/u010891996/article/details/12522911


解决方法：
步骤1：去官网下载AccessDatabaseEngine_64.exe,下载链接
https://www.microsoft.com/zh-cn/download/details.aspx?id=13255
或者直接去我的下载频道进行下载
http://download.csdn.net/detail/hw140701/9830665





步骤2:这一个步骤是强制安装刚刚下载的AccessDatabaseEngine_64.exe，如果不强制安装的话，它会要求你卸载你所安装的全部的Office软件，那多麻烦！！！，所以选择忽略提醒，强制安装，
AccessDatabaseEngine_64.exe，如果不强制安装的话，它会要求你卸载你所安装的全部的Office软件，那多麻烦！！！，所以选择忽略提醒，强制安装，
打开cmd.exe,在命令行输入“你的AccessDatabaseEngine_64.exe的存放路径” /passive，比如我的就是"F:\软件\我下载的\Windows数据库编程\AccessDatabaseEngine_64.exe"
 /passive强制安装，输完这个命令就等待安装完成。
打开cmd.exe,在命令行输入“你的AccessDatabaseEngine_64.exe的存放路径” /passive，比如我的就是"F:\软件\我下载的\Windows数据库编程\AccessDatabaseEngine_64.exe"
 /passive强制安装，输完这个命令就等待安装完成。
AccessDatabaseEngine_64.exe的存放路径
AccessDatabaseEngine_64.exe
步骤3：在安装完上述引擎之后，你需要修改一下你的代码，在win32编译环境下我们的数据库的链接字符串是
步骤3：在安装完上述引擎之后，你需要修改一下你的代码，在win32编译环境下我们的数据库的链接字符串是
m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%s",databaseName);

如果你需要在x64的编译环境环境下连接Access数据库你需要修改为
如果你需要在x64的编译环境环境下连接Access数据库你需要修改为
m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

为了更好的适配不同的编译环境，我将我的代码修改为
为了更好的适配不同的编译环境，我将我的代码修改为


m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);
当是32位程序的时候就为
当是32位程序的时候就为
当是32位程序的时候就为
m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);








然后重启一下PC，应该就可以编译成功了。
然后重启一下PC，应该就可以编译成功了。
然后重启一下PC，应该就可以编译成功了。
然后重启一下PC，应该就可以编译成功了。




这两天有个筒子叫我帮他爬这个网站http://bbs.baobeihuijia.com/forum-191-1.html上的失踪儿童信息，准备根据失踪儿童的失踪时的地理位置来更好的寻找失踪儿童，这种事情本就应该义不容辞,如果对网站服务器造成负荷，还请谅解。


这次依然是用第三方爬虫包BeautifulSoup，还有Selenium+Chrome，Selenium+PhantomJS来爬取信息。
通过分析网站的框架，依然分三步来进行。
第一步：获取http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接
http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接
第二步：获取每一个分页链接上所发的帖子的链接
第二步：获取每一个分页链接上所发的帖子的链接
第三步：获取每一个帖子链接上要爬取的信息，编号，姓名，性别，出生日期，失踪时身高，失踪时间，失踪地点，以及是否报案
第三步：获取每一个帖子链接上要爬取的信息，编号，姓名，性别，出生日期，失踪时身高，失踪时间，失踪地点，以及是否报案
起先用的BeautifulSoup，但是被管理员设置了网站重定向，然后就采用selenium的方式，在这里还是对网站管理员说一声抱歉。
1、获取http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接
获取
http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接




通过分析：发现分页的页面链接处于<div class="pg">下，所以写了以下的代码
通过分析：发现分页的页面链接处于<div class="pg">下，所以写了以下的代码
BeautifulSoup形式：


2.获取每一个分页链接上所发的帖子的链接
2.获取每一个分页链接上所发的帖子的链接
获取每一个分页链接上所发的帖子的链接






每个帖子的链接都位于href下
每个帖子的链接都位于href下
每个帖子的链接都位于href下
所以写了以下的代码：
所以写了以下的代码：
所以写了以下的代码：
BeautifulSoup形式：
BeautifulSoup形式：
BeautifulSoup形式：



获取每一个帖子链接上要爬取的信息，编号，姓名，性别，出生日期，失踪时身高，失踪时间，失踪地点，以及是否报案，并写入CSV中








通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
BeautifulSoup形式：
BeautifulSoup形式：
BeautifulSoup形式：
BeautifulSoup形式：




现附上所有代码，此代码仅供参考，不能用于商业用途，网络爬虫易给网站服务器造成巨大负荷，任何人使用本代码所引起的任何后果，本人不予承担法律责任。贴出代码的初衷是供大家学习爬虫，大家只是研究下网络框架即可，不要使用此代码去加重网站负荷，本人由于不当使用，已被封IP，前车之鉴，爬取失踪人口信息只是为了从空间上分析人口失踪的规律，由此给网站造成的什么不便，请见谅。








附上所有代码：
附上所有代码：
附上所有代码：
附上所有代码：




































配置步骤
1.在pycharm编译其中按上一篇文章简单粗暴：使用pycharm安装对应的Python版本第三方包，在包的搜索窗口输入Selenium，然后点击Install Package即可。




2.下载最新版本的Chrome浏览器安装


3.下载最新版本ChromeDrive.exe
可进入以下网址进行下载
http://chromedriver.storage.googleapis.com/index.html

下载下来为一个压缩包文件，解压缩，得到chromedrive.exe
chromedrive.exe


4.将下载的最新版本的chromedrive.exe拷贝到你的python3.x的安装目录，或者是C:Windows目录下
整个Selenium+Chrome的环境配置就完成了
我的python3.x安装路劲为：C:\Users\Administrator\AppData\Local\Programs\Python\Python35\




到这里整个Selenium+Chrome环境配置就完成了，快使用下列代码打开你的浏览器吧

5.上面代码每次都会打开一次Chrome浏览器，但是假如我们循环次数较多时，每次都打开一次浏览器会干扰我们在桌面上的其他工作，所以这里介绍一个无界面的浏览器包PhantomJS
首先在官网下载地址：http://phantomjs.org/download.html
或者CSDN下载频道以往版本：http://download.csdn.net/detail/tylanbin/7211747
然后得到压缩包，解压，将里面的PhantomJS.exe文件复制到你的python安装路径或者C:windows下，只要是系统的环境path目录都行
PhantomJS.exe文件复制到你的python安装路径或者C:windows下，只要是系统的环境path目录都行
然后只需要把上面driver=webdriver.Chrome()改成driver=webdriver.PhantomJS()即可


driver=webdriver.PhantomJS()即可
PhantomJS


1.新建一个编辑框控件（Edit Control）,将其多行（Multiline）前面打勾（属性设置为True）,Auto HScroll（自动水平滚动）前面的勾去掉（属性设置False）,这样就可以实现每一行填满后自动换行了。
2.再将垂直滚动条（Vetrical Scroll）前面打勾（属性设置为True），自动垂直滚动打钩，设置成true，当输入或显示超过编辑框的大小后就会出现垂直滚动条。
3.如果是输入，滚动条会自动移动跟随到当前输入行，但是如果是设置将很多内容一次性让编辑框显示，滚动条就会一直处于最上方，需要手动拉到最下面才能看见最后一行的内容，在很多时候这是我们不需要的，而是想要滚动条处于最下方，如下的代码将实现这一功能：
this->SetDlgItemText(IDC_EDIT_RECV,str);//将字符串str中内容显示到ID为IDC_EDIT_RECV的编辑框
m_recvshw.LineScroll(m_recvshw.GetLineCount());//m_recvshw为该编辑框的成员变量（也就是control类型的变量）
//使用控件变量的一些成员函数设置滚动条的位置




Meshlab是一个强大的三维模型处理的软件，在三维点云的处理方面也十分强大，不仅仅可以用三维点云重构出三维模型，还可以计算出三维点云每个点的法向量，这在逆向工程和基于三维点云的隐式曲面重建中非常有用。
   我的Meshlab的版本是3.3，可以在网上自行下载破解版。
1.Meshlab读取三维点云
第一步：打开Meshlab软件
第二步：点击File菜单下的ImportMesh导入txt文档，需要选择你的txt文档中XYZ坐标之间的分隔符，导入成功后会显示你的三维点云数据
2.三维点云重建
点击下图图标，弹出右侧图层侧边栏
然后点击Fiter菜单下Normals，Curtavures and Oreientation下的Smooths normals on a point set计算三维点云的法向量，如下图
然后设置计算点云法向量的参数，默认就好，如有需要可以自行设置，点击Apply等计算完成然后点击Close关闭对话框
计算完点击法向量之后，点击Filter菜单下Remeshing Simplication and Reconstruction下的Surface Reconstruction：Ball Pivoting进行三维点云重建
然后设置三维点云重建参数，默认就好，也可以自行设置，点击Apply等重建完成，点击close关闭对话框
然后点击下列图标显示重建的三维模型，也可以设置光照等其他参数
以下为三维重建结果
3.法向量的导出与计算
三维点云的法向量的导出与计算有两种方式，一种是在上一节三维重建中我们已经得到了重建后的三维模型，那么每个点都带有法向量，可以直接导出即可，还有一种就是从杂乱的三维点中计算每一个三维点的法向量
3.1从三维模型中导出三维点云中每个点的法向量
接着第二节的步骤，点击File菜单下Export Mesh as 
然后在接下来的对话框中选择xyz格式
然后在 接下来的对话框中勾选Normal就可以生成文本格式的三维点以及三维点法向量
以下为文本格式的三维点坐标以及三维点法向量的结果
3.2 直接从三维散乱点云中生成三维点的法向量
然后点击Filter菜单下Normals，Curtavures and Oreientation下的Compute normals for point set计算三维点云的法向量，如下图
在弹出来的对话框可以自行设置参数，先Apply然后再Close
法向量的导出与3.1中的一样，可以自行参考。


以下为三维点云以及点云的法向量的可视化结果，点云表示为红色的点，法向量表示为绿色的线段
在程序开发中我们经常看见有一些软件左侧有目录树或者是图层树，点击之后就可以右侧View窗口显示相关的内容，其实实现这种机制有两种方法，第一种就是对MFC的View窗口进行窗口分割，左侧的窗口view类派生于CTreeView，其中CTreeView自带一个变量用于View中的树控件的控制。第二种方法就是用一个可停靠的面板嵌套一个对话框，再在对话框中添加树控件，同样可以达到相同的目的。
以下详解搭建步骤：
第一步：在VS2010中生成一个MFC经典风格的单文档程序，命名为CMyTestMFCDlg，编译下保证没有出错。

第二步：为该工程添加一个新类CMyDockablePane，派生于CDockablePane。



第三步：新建上述类完成后，在CMainFrame头文件中包含该类的头文件#include
 "MyDockablePane.h"
   声明该类的对象：



编译运行：


第四步：插入一个新的对话框，命名为IDD_DIALOG_DOCKDIALOG，在对话框属性中将Style设为Child，Border设为None。
为该对话框新建类：CDockDialog，基类为CDialogEx。
添加一个树控件，IDC_TREE_Test，为树控件关联一个控件变量m_TreeControl
在MyDockablePane.h中包含头文件#include
 "DockDialog.h"
添加CDockDialog
 类的成员变量：CDockDialog m_TestDlg;
添加CMyDockablePane的WM_CREATE和WM_SIZE消息响应函数
在函数中添加以下代码

CDockDialog类中重载虚函数OnInitDialog()，添加以下代码初始化树控件

CDockDialog头文件中添加#include "resource.h"




最后即可编译成功
最后即可编译成功






在网上看见一个对3D建模介绍十分全面的博客，来自中国科技大学图形与几何计算实验室刘利刚老师，介绍的非常棒，膜拜一下。
此处注明转载博客网址：3D建模与处理软件简介-中国科技大学刘利刚
3D建模与处理软件简介
刘利刚
中国科技大学
http://staff.ustc.edu.cn/~lgliu
 
【前言】自半年前笔者发表博客“什么是计算机图形学”以来，时常有人来向笔者询问3D模型的构建方法与工具。
笔者的研究方向是以3D技术为主，具体包括3D建模，3D处理及3D打印三个方面，在3D建模与处理方面从事了
十多年的研究，接触过很多3D相关的软件，在这方面有些经验。因此，特撰写此文，以帮助我们的学生及关注3D
技术的人了解3D建模和3D技术。本文仅仅为笔者根据自己的经验对3D建模与处理软件浅薄的理解，不涉及对技术
的深入讨论，是非学术性的。因此，笔者尽量尝试用通俗的语言介绍一下各种3D建模的软件和工具，以帮助还未接
触3D技术的学生来了解这些工具，以便在今后的科研和工作中能够选择合适的3D工具。笔者对本文的有些内容的理
解也是很有限的，值得进一步的学习和交流。有不当之处，还请读者谅解指正。
 
 
一、           专业3D建模软件
 
1.       3DS
 Max
美国Autodesk公司的3D
 Studio Max（前身是Discreet公司的，后被Autodesk收购）是基于PC系统的三维建模、动画
、渲染的制作软件，为用户群最为广泛的3D建模软件之一。常用于建筑模型、工业模型、室内设计等行业。因为
其广泛性，它的插件也很多，有些很强大，基本上都能满足一般的3D建模的需求。我们的学生也需要经常用到3DS
Max来构建模型。网上关于3DS
 Max的教程和学习视频非常多，使用者众多。
 
2.       Maya
Maya也是Autodesk公司出品的世界顶级的3D软件，它集成了早年的两个3D软件Alias和Wavefront（这两个软件在我
读博时就非常有名，当时就代表了最先进的动画及数字技术，我曾用过Wavefront）。相比于3DS
 Max，Maya的专
业性更强，功能非常强大，渲染真实感极强，是电影级别的高端制作软件。在工业界，应用Maya的多是从事影视
广告，角色动画，电影特技等行业。我们的学生也经常用Maya来制作和渲染3D模型，生成漂亮的渲染结果放在论
文中。
 
3.       Softimage
Softimage曾经是加拿大Avid公司旗下的专业的3D动画设计软件，后被Autodesk收购。它在影视动画方面，特别是
角色功能非常强大。许多电影，比如《泰坦尼克号》、《失落的世界》、《第五元素》等，都曾使用Softimage来
制作大量的惊人的视觉效果。
 
4.       LightWave
LightWave是美国NewTek公司开发的一款3D动画制作软件，具有悠久的历史，我在读博时曾接触过。它的功能非
常强大，特别是在生物建模和角色动画方面功能异常强大，广泛应用在电影、电视、游戏、网页、广告、印刷、
动画等各领域。在电影《泰坦尼克号》中细致逼真的船体模型及其他众多游戏的场景和动画都曾使用LightWave
来制作的。
 
5.       Rhino（犀牛）
Rhino是美国Robert
 McNeel公司开发的专业3D造型软件，它对机器配置要求很低，安装文件才几十兆，但“麻雀虽
小，五脏俱全”，其设计和创建3D模型的能力是非常强大的，特别是在创建NURBS曲线曲面方面功能强大，也得到
很多建模专业人士的喜爱。在与上海造船厂研究所的合作项目中，我们用Rhino来进行船体曲面的NURBS建模和修
改，非常方便灵活。
 
6.       Cinema
 4D
Cinema 4D (C4D)是德国Maxon公司的3D创作软件，在苹果机上用得比较多，特别是在欧美日为最受欢迎的三维动
画制作工具。2009-2010年我在美国哈佛大学访问期间，经常看到学生用C4D在进行3D建模和动画的设计。
 
7.       Creator
MultiGen-Paradigm公司开发的Creator是专门创建用于大型3D虚拟仿真的实时三维模型的软件。其强大之处在于管
理3D模型数据的数据库，使得输入、结构化、修改、创建原型和优化模型数据库非常容易。前几年与一家从事数
字城市的公司合作时我们就用Creator快速创建大量的城市建筑模型，并且生成数据库来管理这些模型，还是相当
的方便。
 
注：从上述介绍可知，美国Autodesk公司当之无愧是当今3D建模和动画的“老大”，拥有3DS
 Max、Maya和Softimage等
3D建模和动画专业软件。3DS
 Max和Maya在3D建模方面各有特色，前者更为大众化些，相对容易掌握些，后者在专
业级的行业应用更为广泛，特别在制作动画和高质量渲染方面强于前者。我们的学生用Maya的相对多些，包括建模，
渲染和动画制作。Softimage和LightWave在3D动画方面表现强大。Rhino对NURBS曲面的支持更好。Creator适合于构
建大量的3D模型并构建数据库进行管理和修改。
 
 
二、           CAD建模和产品设计软件
 
1.       AutoCAD
AutoCAD (Auto Computer-Aided Design)是美国Autodesk公司出品的自动计算机辅助设计(CAD)软件，用于二维绘图
、文档规划和三维设计。适用于制作平面布置图、地材图、水电图、节点图及大样图等。广泛应用于土木建筑、装
饰装潢、城市规划、园林设计、电子电路、机械设计、航空航天、轻工化工等诸多领域。大家买房时看的房型图大
部分都是用AutoCAD来做的。
 
2.       CATIA
Catia由法国Dassault
 Systems公司开发的CAD/CAE/CAM一体化的三维软件，支持产品开发的整个过程，从概念(CAI
D)，到设计(CAD)，到分析(CAE)，到制造(CAM)的完整流程。可帮助制造厂商设计未来的产品，并支持从项目前阶
段、具体的设计、分析、模拟、组装到维护在内的全部工业设计流程，在机械行业，航空航天、汽车工业、造船工
业等应用广泛。其实体造型和曲面设计的功能非常强大。我读博期间曾接触过Catia，在它上面写过一个NURBS曲
面转换的插件程序。
 
3.       SolidWorks
SolidWorks是世界上第一个基于Windows开发的三维CAD系统，后被法国Dassault
 Systems公司(开发Catia的公司)所
收购。相对于其他同类产品，SolidWorks操作简单方便、易学易用，国内外的很多教育机构（大学）都把SolidWork
s列为制造专业的必修课。SolidWorks在杭州有专门的研发机构，我有个学生硕士毕业后在那里进行研发工作。
 
4.       UG
 NX
UG NX由美国Unigraphics
 Solutions (UGS)公司开发的CAD/CAE/CAM一体化的三维软件，后被德国西门子公司收购
。广泛用于通用机械，航空航天、汽车工业、医疗器械等领域。现在西门子公司在上海有专门的研发机构对UG
 NX
产品进行升级完善，我有2个学生博士毕业后在那里负责产品的开发和维护。
 
5.       Pro/E
Pro/Engineer是美国PTC公司(Parametric
 Technology Corporation)旗下的CAD/CAM/CAE一体化的三维软件。在参数化
设计，基于特征的建模方法具有独特的功能，在模具设计与制造方面功能强大，机械行业用的比较多。
 
注：除了上述所介绍的CAD/CAE
 /CAM系统软件（它们各有特色，在市场中都占有一定的份额）外，还有其他一些同
类产品，比如法国Missler公司的Topsolid和以色列Cimatron公司的Cimatron。一般在机械设计与产品研发相关的行业中
才会接触到这些软件，专业性比较强，在网上很容易能找到它们的相关资料。
 
 
三、           3D雕刻建模软件：笔刷式高精度建模软件
 
3D雕刻建模软件(Sculpturing
 modeling)，也称为笔刷式高精度建模软件，顾名思义，就是像艺术家那样用不同的“笔
刷”工具在模型表面上进行“雕刻”的自由创作。建模过程就像玩橡皮泥一样，利用拉，捏，推，扭等操作来对几何
进行编辑，生成任意的高度复杂和丰富的几何细节（如怪兽的复杂表面细节）。这些工具的出现颠覆了过去传统三
维设计工具的工作模式，解放了艺术家们的双手和思维，告别过去那种依靠鼠标和参数来笨拙创作的模式，完全尊
重设计师的创作灵感和传统工作习惯。
 
1.       ZBrush
美国Pixologic公司开发的ZBrush软件是世界上第一个让艺术家感到无约束自由创作的3D设计工具。 ZBrush能够雕刻
高达 10 亿多边形的模型，所以说限制只取决于的艺术家自身的想象力。
 
2.       MudBox
MudBox是Autodesk公司的3D雕刻建模软件，它和ZBrush相比各有千秋。在某些人看来，MudBox的功能甚至超过了
ZBrush，可谓ZBrush的超级杀手。
 
3.       MeshMixer
最近，Autodesk公司又开发出一款笔刷式3D建模工具MeshMixer，它能让用户通过笔刷式的交互来融合现有的模型
来创建3D模型（似乎是类似与Poisson融合或Laplacian融合的技术），比如类似“牛头马面”的混合3D模型。
值得注
意的是，最新版本的
MeshMixer
还添加
3D
打印支撑优化新算法，值得关注。我们
Siggraph
 Asia 2013
的论文“
Cost-effe
ctive
 Printing of 3D Objects with Skin-Frame Structures
”也给出了一种为
3D
打印加尽可能少的支撑材料的新算法（详
见我的博文“
经济节约型的3D打印技术
”），该算法也是具有较好的市场前景，我们也在努力进行产业转化。
 
4.       其他
其他还有一些同类的3D雕刻建模软件，比如3DCoat，Sculptris，Modo等。这里就不再详细介绍了。
 
注1：在工业界，人们更偏向于使用四边形网格(quad
 mesh)，而不是三角网格，一个很重要的原因就是这些雕刻建模
工具善于在四边形网格上进行细节的生成和编辑，因为四边形网格的边更能反应物体表面的流线方向(edge
 flow)。我
们Pacific Graphics 2010的一篇论文B-mesh，就是在建模过程中同时生成具有良好流线方向的四边形基网格(base
 mesh)，
然后直接可以导入到这些雕刻软件中进行进一步的细节雕刻建模。
 
注2：虽然这些笔刷式建模工具上手容易，给了用户便利的方式进行3D细节建模，但是，要想真正构建一个细节复杂
和逼真的3D模型还是不容易的，除了用户需要熟练掌握软件的各种工具及雕刻技巧外，还需要用户具有较好的艺术和
绘画功底。
 
 
四、           基于草图的3D建模软件
 
基于笔划或草图的交互方式由于其符合人类原有日常生活中的思考习惯，交互方式直观简单（就像在图纸上画画
一样来构建3D模型），是最近十多年来计算机图形学中研究的热点建模方法之一。这方面的研究论文有很多，比
如Siggraph 1999年的Teddy，到Siggraph
 2006年的SmoothSketch，Graphics
 Interface 2007的Magic Canvas，Siggraph 
2007年的FiberMesh，SigCHI
 2010年的ICanDraw等。最近，我们也提出一种基于阴影引导的草图交互的3D建模的
技术“Modeling
 by Drawing with Shadow Guidance”，从已知的模型数据库中提取信息来引导用户的笔划交互，能构
建更为精准的3D模型，该工作发表在Pacific
 Graphics 2013上。
虽然在科研上提出了很多基于草图的
3D
建模技术，
但是至今仍未能有比较成熟的商业化的软件出现，可能是因为要理解不同用户的划线和草图还是一件比较困难的
事情。对于一些比较规则的物体，比如建筑、家具等人造物体，这种方式相对可行些，比如
Google
的
SketchUp
（在
国内我们也称为“草图大师”）。
SketchUp
是一套面向普通用户的易于使用的
3D
建模软件。使用
SketchUp
，创建
3D
模型就像我们使用铅笔在图纸上作图一般，软件能自动识别你画的这些线条，加以自动捕捉。它的建模流程简单
明了，就是画线成面，而后拉伸成体，这也是建筑或室内场景建模最常用的方法。
SketchUp
还可以将你自己的制
作成果发布到
Google
 Earth
上和其他人共享，或者是提交到
Google
的
3D
 Warehouse
（
Google
的
3D
模型库）。当然你
也能从
Warehouse
那儿得到想要的素材，以此作为创作的基础。很有趣的是，在
2012
年
Google
公司的
SketchUp
被美
国
Trimble
公司收购了。去年出了个
Trimble
 SketchUp 2013
，网评似乎不太好。不知其是否能继续免费。
最近国内出
了一款叫做“
EasyToy
”的采用草图式的
3D
建模软件，适用于卡通动漫形象与玩具的设计。但我还没有试用过，不知
用户体验如何。另外，日本东京大学的
Takeo
 Igarashi
教授也发布了一些基于草图式的
3D
建模系统，比如
Teddy
，在
其主页上可以下载到。
另外，值得一提的是，基于草图的交互方式在现在正在兴起的
Web3D
建模领域会有新的广阔
空间。
Web3D
建模在稍后会介绍。
 
 
五、           基于照片的3D建模软件
 
从物体的照片来进行3D模型的构建，是计算机图形学和计算机视觉的一大研究方向，称为基于图像的几何建模(Ima
ge based modeling)。这种技术已逐渐成熟且走向实用阶段，最近有些软件能够让用户拿着普通相机或者手机对着要
建模的实物从不同视角拍摄若干照片，然后软件就能根据这些照片自动地生成相应的3D模型。这种基于
图片的建
模技术提供给了非专业建模人士来构建
3D
模型的工具。
 
1.       Autodesk
 123D
Autodesk公司最近发布了一套平民级的建模软件Autodesk
 123D，用户不需复杂的专业知识，只要为物体从不同的
视角拍摄几张照片，该软件就能自动地为其生成3D模型，而且软件是完全免费的。
(1)    Autodesk
 123D是一款免费的3D CAD 工具，用户可以使用一些简单的图形来设计、创建、编辑三维模型，或者
在一个已有的模型上进行修改。
(2)    Autodesk
 123D Catch是建模软件的重点，用户使用相机或手机来从不同角度拍摄物体、人物或场景，然后上传
到云，然后该软件利用云计算的强大计算能力，可将数码照片中几分钟的时间内转换为3D模型，而且还自动带上
纹理信息。我们试用过几次，感觉它的使用还是很方便的。但是其生成的3D几何的细节不多，主要是通过纹理信
息来表现真实感的。有时软件也会失败，生成的几何是不正确的。
(3)    Autodesk
 123D Make是将3D模型转换为2D的切割图案，用户可利用硬纸板、木料、金属或塑料等低成本材料
将这些图案迅速拼装成实物，从而再现原来的数字化模型。这让用户能够“制造”出所造的3D模型，有点像3D打印
的雏形。目前123D Make只有Mac版的。
(4)    Autodesk
 123D Sculpt是一款运行在iPad上的3D雕刻软件（前面已介绍过），通过绘画的方式在模型上雕刻
几何细节。
 
2.       3DSOM
 Pro
3DSOM Pro是一款从高质量的照片来生成3D建模的软件，它可以通过一个真实物体的照片来进行3D建模，并且制
作的模型可以在网络上以交互的方式呈现。
 
3.       PhotoSynth
微软开发了一款产品PhotoSynth，可将大量的照片做3D处理，但是它不是真正创建3D模型，而是根据照片之间的
相机参数及空间对应关系，建构一个虚拟的3D场景，使得用户能够在从不同角度和位置来查看该场景，而显示的
场景图像是由给定的照片所合成的。其基本原理来自于Siggraph 2006的论文“Photo
 Tourism: exploring photo colle
ctions in
 3D”及其他相关论文。
 
注：从多幅不同角度拍摄的照片来重建3D物体，从技术原理上来讲是可行的，但是由于算法的一些步骤，比如图像
中物体特征点的检测和匹配，相机参数的估计等，还会出现不太正确的结果，使得重建结果有时不够稳定，甚至不
正确。随着技术和计算能力的不断发展，相信这些会逐步得到解决。到时，从照片来重建3D模型的技术可能是最为
方便的3D建模技术了，因为人人都有手机，随时都可以拍照上传到云端来构建3D模型。如果有了大数据库的支持，
从单张照片来构建3D模型也是可能的，可以参看我们的Siggraph
 2011的论文。
 
 
六、           其他3D建模软件
 
1.       人体建模软件
关于构建人体模型及动画，首推Metacreations公司的Poser软件（俗称“人物造型大师”）和开源的MakeHuman软件
。这两款软件都是基于大量人类学形态特征数据，可以快速形成不同年龄段的男女脸部及肢体模型，并对局部体
形进行调整。可以轻松快捷地设计人体造型、动作和动画。我读博期间用过Poser构建人体模型来做morphing，
还是蛮方便的。
 
2.       城市建模软件
加拿大Esri公司的CityEngine是三维城市建模的首选软件，可以利用二维数据快速创建三维场景，并能高效的进行
规划设计。应用于数字城市、城市规划、轨道交通、管线、建筑、游戏开发和电影制作等领域。另外，CityEngine
对ArcGIS的完美支持，使很多已有的基础GIS数据不需转换即可迅速实现三维建模，缩短了三维GIS系统的建设周
期。该软件的核心技术是Siggraph 2001的论文“Procedural
 Modeling of Cities”及其他相关论文，早期是ETH Zurich
大学的Pascal Mueller研究小组创办的Procedural公司开发的，后被Esri公司收购。
 
3.       其他小巧的3D建模软件
下面的这个网页还介绍了一些其他3D建模相关的软件或程序：
http://tech.sina.com.cn/s/2008-10-20/08192519895.shtml
这些软件大部分都非常小巧，而且是开源且完全免费的。有很多媒体工作者和艺术家用这些小软件来制作3D作品
，其中Blender, K-3D, Art of Illusion, Seamless3d,
 Wings3D等软件的使用面稍微广泛些。有兴趣的读者可以到网上找
到相关资料去了解和学习，这里不作详细介绍。
 
4.       网页3D
 (Web3D)建模工具
最近，出现了一些基于网页(web)开发的3D模型设计软件，即基于WebGL，可以在浏览器中完成3D建模的工具。
比如3DTin，TinkerCAD（去年被Autodesk收购）等，它们的界面简单直观，有Chrome等浏览器插件插件，可以在
线生成3D模型，直接存在云端，并在社区分享模型。
在互联网的时代，
Web3D
技术将被越来越被广泛使用，建议
大家多关注。
 
 
七、           虚拟现实软件和平台
 
虚拟现实软件本质上不是用于3D建模的，而是用来对生成好的3D模型和场景提供关于视觉、听觉、触觉等虚拟的
模拟，让用户如同身历其境一般。相关软件也有很多，这不是本文的重点，只大致提及几个比较常见的。
 
1.       VirTools和Quest3D
法国VirTools公司的VirTools和美国Act-3D公司的Quest3D都是元老级的虚拟现实制作软件，简单来说，就是工业
或游戏用的实时图形渲染引擎，是3D虚拟和互动技术的集成工具。可以让没有程序基础的美术人员利用内置的行
为模块快速制作出许多不同用途的3D产品，如网际网络、计算机游戏、多媒体、建筑设计、交互式电视、教育训
练、仿真与产品展示等 。网上的学习资料比较多。
 
2.       Unity3D
 (U3D)
Unity Technologies开发的Unity3D
 (U3D)是最近几年冒出来的新秀，是一个全面整合的专业虚拟3D和游戏引擎。
它在制作虚拟现实及3D游戏方面上手非常容易，操作简单，互动性好，有强大的地形渲染器。我们的学生使用
U3D可以很快地制作一个3D游戏，因此也强烈推荐大家学习使用。
 
3.       Vega
Vega是MultiGen-Paradigm公司开发的用于实时视觉模拟和虚拟现实应用的开发引擎，提供很多的C/C++语言的应
用程序接口API，结合其应用程序的图形用户GUI界面软件LynX，可以迅速创建各种实时交互的3D环境。对于开
发3D游戏和3D场景漫游的项目非常方便。
 
4.       OSG
 (Open Scene Graph)
OSG (Open Scene Graph)是一套开源的基于C++平台的应用程序接口API，能够让开发者快速、便捷地创建高性能
、跨平台的交互式图形程序。它将3D场景定义为空间中一系列连续的对象，能够对3D场景进行有效的管理。由于
OSG是开源和完全免费的，很多3D应用的软件都选用OSG作为基础架构。几年前，我们与一个公司合作开发的义
齿软件就选用OSG作为管理3D数据的框架，使得开发非常方便。
 
5.       其他
其他的一些用于3D应用程序开发的软件开发包(SDK)或API还有GLUT(OpenGL
 Utility Toolkit), OpenGL Performer, 
CG2 VTree, Quamtum3D Mantis等。有兴趣的读者也可以去了解一下。
 
注：相比于十年前，由于有了上述开发平台和开发包，现在开发一个看起来还比较cool的3D应用程序或游戏不是那么
困难，随着技术的不断发展和3D应用不断渗入到各行各业，相信以后会更加方便。
 
 
八、           开源3D网格处理库
 
1.       PCL
 (Point Cloud Library)
Point Cloud Library (PCL)是一个独立的大型跨平台的处理二维/三维图像和点云数据的C++模板库，它基于许多第三
方库，比如Boost、Eigen、FLANN、VTK、CUDA、OpenNI、Qhull等，实现了大量点云相关的通用算法和高效数
据结构，涉及到点云获取、滤波、分割、配准、检索、特征提取、识别、追踪、曲面重建（包括Poisson重建算法
）、可视化等。早期的PCL是由Dr.
 Radu Bogdan Rusu在德国慕尼黑工业大学读博士期间开发的，目的是要为三维
点云数据处理的研究及应用，建立出一个共同的基础架构。另外，PCL利用OpenMP、GPU、CUDA等先进高性能
计算技术，通过并行化提高程序实时性。集成了Kinect Fusion重建算法。有人将其地位比喻为3D的OpenCV，足以
可见其对3D的开发和研究的重要性，我们的学生在科研过程中经常用到PCL。
 
2.       CGAL
 (Computational Geometry Algorithms Library)
CGAL是一套开源的C++算法库，提供了计算几何相关的数据结构和算法，诸如三角剖分（2D约束三角剖分及二维
和三维Delaunay三角剖分），Voronoi图（二维和三维的点，2D加权Voronoi图，分割Voronoi图等），多边形，多
面体（布尔运算），网格生成（二维Delaunay网格生成和三维表面和体积网格生成等），几何处理（表面网格简
化，细分和参数化等），凸壳算法，搜索结构（近邻搜索，kd树等），插值，形状分析，拟合等。CGAL功能强
大，是我们学生做科研的必备程序库之一。
 
3.       MeshLab
MeshLab是一个开源的处理三角形网格的C++算法库，提供了三角网格的数据结构和算法，诸如曲面重建、编辑
、修复、光顺、编辑等算法。MeshLab也是我们学生做科研的必备程序库之一。
 
4.       其他开源网格处理库
OpenMesh：由德国RWTH
 Aachen大学的Leif Kobbelt研究小组开发的C++网格处理库
Libigl: 由瑞士Ethz大学的Olga
 Sorkine研究小组开发的C++网格处理库
Trimesh：有美国Princeton大学的Thomas
 Funkhouser研究小组开发的C++网格处理库
 
5.       网格剖分(Delaunay)与生成库
Triangle, NetGen：平面三角网格生成库
TetGen, Stellar：空间四面体网格生成库
 
注：这里列出了几个主要的网格处理的C++代码库，我们的学生在学习和科研的过程中会经常用到它们。当然，网上
还有其他的各种算法库，对我们的科研和开发都是非常有用，我们有时也会用到，这里就不再详述。
 
 
九、           基于扫描（逆向设计）的3D建模软件
 
随着深度相机的普及及扫描仪的价格迅速下降，人们采集三维数据变得容易，从采集到的三维点云来重建三维
模型的工作在最近几年的Siggraph(Asia)上能常见到，比如我们Siggraph
 Asia 2010，Siggraph
 2013等的工作。最近
几年产生了许多基于点云数据的建模与处理（或逆向工程和设计）的软件，而且各种扫描设备的生产厂商也会发
布相应的点云重建的软件。
 
1.       Geomagic
Geomagic (俗称“杰魔”) 包括系列软件Geomagic
 Studio、Geomagic Qualify和Geomagic
 Piano。其中Geomagic Studio
是被广泛使用的逆向工程软件，具有下述所有特点：确保完美无缺的多边形和 NURBS 模型处理复杂形状或自由
曲面形状时，生产效率比传统 CAD软件提高数倍；可与主要的三维扫描设备和CAD/CAM软件进行集成；能够作
为一个独立的应用程序运用于快速制造，或者作为对CAD软件的补充。是我们学生科研的必备软件之一。
 
2.       RapidForm
RapidForm是韩国INUS公司出品的逆向工程软件，提供了新一代运算模式，可实时将点云数据运算出无接缝的多
边形曲面，使它成为 3D扫描数据的最佳化的接口，是很多3D扫描仪的OEM软件。我们购买的Konica
 Minolta的激
光扫描仪Range 7就是用RapidForm来进行逆向设计。我们SGP
 2010的ARAP参数化算法作为目前为止最好的参数化
算法之一，被集成到了RapidForm软件中。
 
3.       ReconstructMe
ProFactor公司开发的ReconstructMe是一个功能强大且易于使用的三维重建软件，能够使用微软的Kinect或华硕的
Xtion进行实时3D场景扫描（核心算法是Kinect
 Fusion），几分钟就可以完成一张全彩3D场景。我们尝试过，效果
还可以。ReconstructMeQt提供了一个实时三维重建利用ReconstructMe
 SDK（开源）的图形用户界面。
 
注：法国ManCTL公司开发的Skanect为Mac平台的第一款3D 扫描软件，也支持者华硕的Xtion或者微软的Kinect进行
实时3D 扫描。
 
4.       Artec
 Studio
Artec公司出品的Artec
 Eva, Artec Spider等手持式的结构光3D扫描仪，重量轻且易于使用，成为许多3D体验馆扫描
物体的首选产品。我试用过Artec Eva后感觉还是需要较多的技巧才能扫描好物体，而且后期需要用软件进行较多
的处理，比如数据的去噪、修复、光滑、补洞等。
同时，
Artec
公司还开发了一款软件
Artec
 Studio
，可以和微软的
Kinect
或华硕的
 
Xtion
以及其他厂商的体感周边外设配合使用，使其成为三维扫描仪。
Kinect
通过
Artec
 Studio
可以
完成模型扫描，然后进行后期处理，填补漏洞、清理数据、进行测量、导出数据等。不确定它是否也使用了
Kinect 
Fusion
算法。
 
5.       PolyWorks
PolyWorks是加拿大InnovMetric公司开发的点云处理软件，提供工程和制造业3D测量解决方案，包含点云扫描、
尺寸分析与比较、CAD和逆向工程等功能。
 
注1：全球四大逆向工程软件除了Geomagic
 Studio和RapidForm外，还包括ImageWare和CopyCAD，由于后两者我不
熟悉，在此就不介绍了，有兴趣的读者可以到网上去找相关资料了解。
 
注2：微软的Kinect作为快速获取3D数据的传感器，可以作为3D扫描仪来使用，我们曾使用3台Kinects来扫描人体全
身，论文发在2012年的IEEE
 TVCG期刊。现在有多款软件或者开发库（包括上面介绍的PCL，ReconstrutMe，Artec
Studio，Skanect），支持将单台Kinect作为手持式扫描仪来扫描物体，其核心都是Kinect
 Fusion算法。
 
 
十、           后记
 
最近，随着人们对3D建模的需求越来越大，出现了许多其他形式的3D建模软件和工具，比如Blokify, 基于块状化
3D建模软件，特别适合孩子们制作模型。这些新出现的工具我这里就不一一介绍了，大家可以关注网上的一些科
技新闻网站、论坛或博客等。
 
 
1.       3D模型数据浏览与转换软件
上面介绍的大部分的软件或库都支持查看不同格式的3D模型数据。如果仅仅是浏览或查看现有的3D模型数据，我
个人推荐3D Exploration软件（相当于查看图像的ACDSee软件），它是一个专门用来查看各种格式的3D模型文件，
包括3DS数据 (*.3ds,
 *.prj, *.asc)、LightWave Objects (*.lwo,*.lw)、 DirectX(*.x)、AutoCAD
 (*.dxf)、Object File Fo
rmat (*.off)、Wavefront
 (*.obj)等，还可以用鼠标交互从不同视角来查看。而且还能查看各种图像文件，包括bmp
、rle、dib、gif、jpg、png、tif、tga、pcx等。当然也能查看带纹理的3D模型。3D
 Exploration是我的机器必装软件
之一，强烈推荐。另一个我推荐的同类软件是Deep Exploration，它除了可以浏览3D数据外，还可以转换数据格式
（最新版本还支持Sketchup文件），同时它还可以对你的模型进行编辑及添加注释制作动画等，我也强烈推荐。
注：现在有很多3D数据格式，几乎每个3D建模软件都会定义自己的数据格式。几种比较公认的3D数据格式有VR
ML、obj、off、stl
 (用于3D打印的数据格式)等。现在有些组织在力推3D数据的标准。相信随着3D技术的发展，这
些格式都将越来越标准化和统一化。对各种数据格式需要更多了解的，可以到网上找找，比如：
http://www.cnblogs.com/sunliming/archive/2012/02/28/2372398.html
 
 
2.       3D模型渲染软件
本文介绍的各种3D建模软件一般都能渲染3D模型，但要得到更为逼真的真实感渲染效果，还可以使用专门的3D
模型渲染软件，比如Pixar Renderman、POV-Ray、 V-Ray、 Mental
 Ray、Final-Render等，这里就不详细介绍。一
般我们使用Maya进行渲染放在论文中，已经足够漂亮了，读者可以在我们的许多论文中看到利用Maya渲染的结果
图。
 
3.       其他相关的软件
本文以介绍3D建模的软件和库为主，另外，还有许多跟3D技术相关的软件和开发包我没有提及，比如图像处理、
可视化、处理医学图像、建筑设计、装潢设计及艺术设计等。读者可以根据各自的专业去网上寻找所需要的专业
软件。
 
4.       学习使用3D建模软件
相比于2D平面软件Adobe
 Photoshop，Illustrator，CorelDraw等，学习3D软件难度稍大些，需要了解和掌握一些3D
的概念、3D交互习惯和技巧。因此，想要在短期熟练掌握好一个3D建模软件，是不太可能的，需要多用、多摸索
、多体会。网上有许多教材和视频，您可以跟着去学习。总之，您要多去玩，就能玩熟了。如果您能有个确定的
目标来学习3D软件，比如完成项目或者论文中所需要的效果，您就能掌握得更快！因为，带有确定目标和任务的
学习，是最高效的学习。但您如果暂时用不到，暂可不必花太多时间去学习，学了但不去用，也容易忘。只要您
学习软件的速度快就可以，而这正是我们对学生的基本要求。
 
5.       3D时代的来临
最近两年3D打印机的兴起，引起人们的极大好奇与广泛关注，同时也有些争论。虽然还不清楚它是否能成为人们
生活中不可或缺的一项技术，但不可否认，3D打印技术确实已经给世界带来巨变，已逐渐在某些领域表现出巨大
的价值，比如，提高了制造行业的生产力，在医学领域得到了广泛应用（义齿，假肢，器官等），为艺术家提供
了有效的创作工具等等。个人认为，3D打印提供给了平民零技能制造的技术，会朝着“私人定制”（个性化需求）
的方向发展；随着大量草根参与到3D的设计和制造，3D打印将逐步颠覆人们创造东西的能力。正因人们对3D模型
有了巨大的需求，3D打印技术才使得计算机图形学“落地”，这也使得我们这个学科终于在人们生活中体现了巨大
的价值。关于3D打印技术将给大规模工业经济带来的巨大冲击以及给我们的生活将带来的巨大变化，这里不展开
讨论，我将以后抽空撰文加以详述。
我们再来看一下这几年的一些巨头科技公司的变化，
2011
年微软公司的
Kinect
让人们获取
3D
数据的硬件代价降低了许多，
2012
年
3D
打印的兴起造就了两家上市公司
Stratasys
和
3D
 Systems
，
2013
年苹果公司收购了
Kinect
的核心技术公司
PrimeSense
，谷歌公司收购了大名鼎鼎的机器人公司
Boston
 Dynamics
，这
些都说明，越来越多的高科技企业在快速发展
3D
科技，
3D
时代已经来临！
随着人们对
3D
技术有了越来越多的需求，本文所介绍的
3D
建模工具将会发挥出更为巨大的价值。随着科学和技术的发展，云计算与物联网的进一步发展，将会出现越来越便利的
3D
建模工具，比如
Autodesk
 123D
正在将
3D
技术从专业变成非专业，人们接触
3D
技术的门槛将越来越低，创造的
3D
模型越来越丰富。我坚信，日后
3D
技术将“飞入寻常百姓家”，会越来越平民化，且成为人们生活中重要的一部分。
当然，当前人们对3D技术的了解还远远不够，大部分的人对3D技术仍然很陌生。另一个我个人看好的市场就是3D
教育与培训，普及3D技术与培养3D技术人才已时不我待。
另外，现在也开始有了一些
3D
模型共享的网站在运营，
能够提供给全世界的用户下载、上传、分享
3D
数据；类似于十多年随着
Internet
发展而产生的图像共享网站，这些
3D
数据共享网站也将在不久的未来产生巨大的价值，
3D
模型数据也将逐步进入“大数据时代”。
我们很庆幸成为
3D
科技新时代的弄潮儿，有很多的机会和挑战在等待着我们！让我们一起努力！
Python的强大除了其简单的语法以及易用性，还有其不得不说的海量的第三库的支持。
但是，我们电脑上由于需要可能安装了多个版本的Python，如Python2.X和Python3.X,这时候我们除了在电脑上要解决多个Python版本共存的问题，还需要针对不同的版本安装支持不同版本的第三方库，而且在安装第三方库的时候在cmd.exe上可能会出现输入字符错误，或者其他的错误，简而言之，就是没有交互式的界面，不能让人像傻瓜一样简单的安装第三方包，但是Pycharm这个强大的pythonIDE（集成开发环境）给我们提供了这种便利，以下就介绍如何使用Pycharm安装不同Python版本的第三方库。
1.打开Pycharm,我的Pycharm版本为Pycharm4.5.4


2.打开File菜单下的Setting菜单，如下






3.选择Settings下Project:Python下的Project Interpreter，并选择Python的版本，点右侧+号进入第三方库的搜索界面


4.在第三方包的搜索界面输入要安装的第三方包的名字，点击左下角Install Package按钮，后会提示安装成功




到这里，第三步就安装完成了，快去试一试新的库的强大功能吧！
三维模型重建顾名思义就是从一些数据（点云，图片，三维轮廓线等）重建出物体的三维逼真的三维模型，在其重建的过程中针对不同的数据的的三维重建会有不同的处理算法，如针对点云数据的三维重建有很多种重建方法,如基于Delaunay三角化，Voronoi图，隐式曲面等方法，另外在三维模型的重建过程（MarchingCube，RayCast,网格构建等）以及三维模型生成后的后处理算法（三维网格简化，三维网格加密，三维模型表面光滑，三维模型的空洞修补等等）也是层出不穷，在这其中需要用到大量的三维图形学知识（从简单的画点画线算法到复杂的体绘制算法，以及光照计算，材质映射等）。在最后的实现方面致力于提高算法效率和运行性能，各种加快算法实现的三维数据结构（KD树，八叉树等）的提出和实现，以及压榨计算机和服务器性能的并行算法（OpenMP，MPI）等，减少算法实现过程中的内存占用以及运行时间（降低空间复杂度以及时间复杂度）。三维模型重建上的优秀算法或者是优秀实例我也只是管中窥豹，上面所提到的有些名词我也是大致了解，我尽自己最大的能力介绍下自己闲暇时间以前做过的相关三维模型重建的实例和其他相关的关于三维重建方面的知识，毕竟能力有限，知识面还有待拓展。
1.编程语言
是用的编程语言是C/C++，基本上相关的图形学方面的实现都是使用C/C++作为开发语言，不是说别的语言如Java，Python等语言不好，确实在效率方面以及内存处理方面C/C++有着比较大的优势，而且现在市面上的三维图形库其底层语言就是C/C++，所以使用起来更加方便。一门语言有其适用的场景和场合，正如Java在WEB和APP上面的天然优势一样，C/C++在图形处理，图像识别以及其他的图形处理领域也有着很大的优势。
2.我所使用的第三方库
（1）三维图形库OpenGL
OpenGL(Open Graphics Library)，OpenGL图形绘制库，有着优秀的二维和三维图形API，是一个功能强大的三维图形绘制的底层库，有着大量的调节三维模型视觉效果的函数，例如光照，模型材质，纹理等等。早期OpenGL包GLUT依然比较强劲，但是其不能用于64位平台的编译，而且GLUT官方已经不维护了，那么有一个新的FreeGlut横空出世，支持最新的OpenGL绘图标准，并且支持64位平台的编译，能够完全取代老化的GLUT库。


（2）三维图形库VTK
VTK（Visualization Tool Kit）同样也是一个优秀的三维图形库，近年来相当的火爆，它以OpenGL作为底层绘制语言进行封装，用户不需要考虑太多的光照以及材质影响到模型可视化效果的设置，这些VTK都已经帮你做好了，你需要考虑的是如何从原始数据绘制出你的图形。其内部封装了大量的三维图形处理函数，基本上你所能想到的算法都能找到影子，比如著名的面绘制方法MarchingCube，体绘制方法Raycast等等，往往你能在阅读他的帮助文档的时候看到一个意想不到的功能。


（3）计算机视觉库OpenCV
OpenCV（Open Source Computer Vision Library）今年来大热的计算机视觉库，同样以C/C++作为底层语言，封装了大量的图形处理和计算机视觉领域的算法，比如说图像识别领域，机器人，人类视觉仿真，好像现在大热的人工智能领域也开始使用OpenCV进行视觉领域方面的处理。


（4）矩阵运算库Eigen
在三维图形处理过程中通常需要大量的矩阵运算，而Eigen是一个轻量级的矩阵运算库，其函数API涵盖了几乎所有的矩阵运算，但是它的使用只需要包含一个头文件，不需要过于复杂的配置就可以使用已经封装好的各种矩阵运算函数。


（5）并行计算库OpenMP
OpenMP可以在你把项目代码构建好之后也仍然可以通过几行代码将你的程序自动的进行并行化计算，使用起来非常的简单，并行计算可以大幅度的提高你的程序的运行速度以及计算的效率。如果你的IDE是VS，那么你只需要简单的开启OpenMP就可以了，然后在VS中包含其头文件就可以使用OpenMP封装的函数进行并行程序设计。


其他的如CGAL（几何算法库），QT（图形界面库，不过本人更喜欢用老掉牙的MFC）等等。


3.我所接触到的三维重建类型
（1）点云三维重建（隐式曲面重建）
原始三维点云（三维点云以及法向量）-斯坦福兔子1889个点，采用OpenGL从底层写的径向基隐式曲面点云重建方法


采用径向基隐式曲面重建后的三维模型

（2）医学序列图片三维重建（使用VTK进行医学图片处理，模型构建采用MarchingCube算法）
重建结果

（3）OpenCV双目视觉重建（医学冠脉三维重建，VTK做可视化）
左视图A

右视图B

使用OpenCV做的三维冠脉重建，VTK做的显示

（4）基于轮廓线的三维模型重建
轮廓线


重建的三维模型




4.结语
万事开头难，作为一个刚刚入门三维重建领域的人写这篇文章心中的感觉简直是战战兢兢，三维模型重建方面的知识浩如沧海，我只不过是只窥得了寥寥数星。只不过自己想把自己学习到的一些知识与有缘人交流分享，共同进步。不知以后还不会不在三维领域工作与发展，不过之后的事情谁又知道呢。
后面我会详细介绍一些三维重建算法以及一些实例。



好久都没有动Python了，自从在网上买了《Python网络数据采集》这本书之后一直没有时间写自己的小的Demo,今天再网络上无意中看见
http://www.cnblogs.com/mfryf/p/3695844.html：

这篇博客，自己想要不花一个小时复习下BeutifulSoup，然后实现与上面的那个博客一模一样的功能，其实自己以前就想写这样的一个东西，像上面博主一样，也只是想每天看一下博客的访问量有没有上涨，哈哈哈哈哈。
最近需要用到三维点云数据，但是网上大部分的数据资源的数据格式都是杂乱无章而且没有清晰的数据说明，为了方便，自己整理了常用的三维点云数据，格式都是按照X坐标空格Y坐标空格Z坐标这种数据格式排列，方便数据读取和进行三维点云的重建实验。
   其中的数据包含了著名的斯坦福兔子，大象，马，凳子，人头等三维点云数据，显示的效果如下：






















以下为三维点云的重建效果：
三维点云数据我已经上传到我的下载频道：常见的三维点云数据，已经整理数据格式 - 下载频道 - CSDN.NET  http://download.csdn.net/detail/hw140701/9852949
常见的三维点云数据，已经整理数据格式 - 下载频道 - CSDN.NET http://download.csdn.net/detail/hw140701/9852949



另外一些常见的三维模型的下载地址为：常见的三维模型下载地址：http://www.cc.gatech.edu/projects/large_models/
希望可以帮助到有缘人0.0




VTK根据几个点插值成样条曲线，然后以样条曲线为中心线，生成圆柱体管道
最近在项目中有一种结构体数据需要存储，数据结构体如下

现在需要根据在m_Vector中的每一个结构体的ID来获得其对应的pinwei值，所以就写了一个函数，如下
然后上程序上面测试，对于一个size大约15000的容器，大概每次循环需要进行20次FindpinweiValueInVector（）函数的调用，所以在Vector中查找值的最坏的情况是时间复杂度为O(n),即进行15000*20，这还是每次的循环，当一个菜单执行完毕整整花了大概6个半小时左右，程序运行效率低下。


所以，必须要有一种查找效率较高的容器，就想到的map,map为平衡二叉树，查找效率为对数级别，时间复杂度为O(logN)，查找相对来说较快，1000大小的数据最坏只需要3次就可以查找到，15000只需要4次多就可以查找到。
所以声明一个map<int,double>型的容器，用于建立mystruct的ID与pinwei之间的对应关系，然后将Vector存储的值插入到map中，然后在map中根据键值（ID）查找Value(pinwei)。
函数如下



总结：以前在项目中用惯了STL的Vector，因为其比数组来的方便，不需要定义数组长度，可以不断的pushback(),但是其在大数据量中的查找效率简直令人发指，所以以后在什么时候得根据特定的情况使用特定的容器，不要习惯性的使用Vector。
后来又测试了下，用hash_map更快。


MFC项目开发过程中需要获取某个树控件下某个树节点下所有的子节点的文本，添加到某个组合框上，网上的相关代码差不多是遍历整个树控件，所以自己就封装了一个函数，用于获取指定树节点下的所有的子节点的文本然后添加到某个组合框中，其中获取的文本被压入CString类型的容器保存。

1.OpenMP介绍
OpenMP 是 Open MultiProcessing 的缩写，用于共享内存并行系统的多处理器程序设计的一套指导性编译处理方案。在项目程序已经完成好的情况下不需要大幅度的修改源代码，只需要加上专用的pragma来指明自己的意图，由此编译器可以自动将程序进行并行化，并在必要之处加入同步互斥以及通信。当选择忽略这些pragma，或者编译器不支持OpenMp时，程序又可退化为通常的程序(一般为串行)，代码仍然可以正常运作，只是不能利用多线程来加速程序执行。OpenMP提供的这种对于并行描述的高层抽象降低了并行编程的难度和复杂度，这样程序员可以把更多的精力投入到并行算法本身，而非其具体实现细节。对基于数据分集的多线程程序设计，OpenMP是一个很好的选择。



2.VS2010中开启OpenMP
右键项目属性-配置属性-C/C++-语言-OpenMP支持-点击是。






3. OpenMP并行化测试
在已有源代码的基础上，要对此段代码进行并行化处理，只需要使用

程序结果




当我们修改为8个线程的时候，其结果为




可以看出4个线程和8个线程都执行了cout << "Thread  " << omp_get_thread_num() << endl; //omp_get_thread_num()是获取当前线程id号这句代码，而且先后顺序没有特定的从线程1到线程2执行，可以看出简单的实现了并行块的设计。


下面以一个较大的for循环来测试OpenMP并行程序与普通串行程序的速度问题。
需要对for程序代码段执行并行化需要添加#pragma omp parallel for
串行化程序：





并行化程序：





1.OpenCV创建一个灰度图，遍历每一行每一列并设置每一行每一列的像素值，并将其保存为图片,但是at方法可读性较高，但是效率不高

2.OpenCV创建一个灰度图，使用迭代器iteator遍历每一行每一列并设置每一行每一列的像素值，并保存
随机数填充像素值



3.OpenCV创建一个灰度图，使用数据指针遍历每一行每一列并设置像素值，保存图像，但是指针很危险
不进行数组越界检查


这个问题简单但是又容易犯错，当代码出现错误的时候让人非常的懊恼；
比如有两个类：CleftView和CImplicitModelView两个类，现在有这样的需求需要在两个类中都调用对方的函数，所以就在CleftView.h中加上#include "CImplicitModelView"，在CImplicitModelView.h中加上#include "CleftView.h"，
但是当我们兴高采烈地的去编译时，会出现缺少分号的错误，但是当我检查了很久的代码，发现并没有出现缺少分号，这个原因是因为类与类之间的头文件互相包含所导致的。
解决方法就是：
在两个类的头文件中进行类先导声明，然后在各自类的.cpp文件中进行头文件的包含
例如：
(1)在CleftView.h中进行CImplicitModelView的类先导声明class CImplicitModelView;(有分号),然后在CleftView.cpp文件中包含CImplicitModelView类的头文件，#include"CImplicitModelView.h"
(2)在CImplicitModelView.h中进行CIeftView的类先导声明class CleftView;(有分号),然后在CImplicitModelView.cpp文件中包含CIeftView类的头文件，#include"CIeftView.h"
在CImplicitModelView.h中进行CIeftView的类先导声明class CleftView;(有分号),然后在CImplicitModelView.cpp文件中包含CIeftView类的头文件，#include"CIeftView.h"
CImplicitModelView
CImplicitModelView
这样，就可以实现在两个类中进行互访问
这样，就可以实现在两个类中进行互访问
vtk中没有可以直接在三维空间中绘制三维空间圆的类以及函数，在这里，编写了以函数以任意的三维点为中心，任意半径，绘制平行于Z=0平面的圆，
可以用于批量绘制三维空间的圆。也可改写为平行为X=0或者Y=0的平面。

参考代码为：在三维空间中Z=给定值平面绘制半径为给定值的圆，圆内部填充
1.error c3861:"_T:找不到标识符"
2.error C2664: “CreateFileW”: 不能将参数 1 从“const char [19]”转换为“LPCWSTR”
3.error C3861: “setprecision”: 找不到标识符
4. error C2501: 'vector' : missing storage-class or type specifiers
5.VS2010提示资源已在另一编辑器中打开
6.VS中出现error C2665:“AfxMessageBox”:
 2 个重载中没有一个可以转换所有参数类型
选择“项目”菜单->项目属性->配置属性->常规->字符集，改为“未设置”即可。
7.
无法解析的外部符号"public:__thiscall cv::SURF::SURF(void)" (??0SURF@cv@@QAE@XZ)，该符号在函数main 中被引用
无法解析的外部符号"public:__thiscall cv::SURF::SURF(double,int,int,bool,bool)"(??0SURF@cv@@QAE@NHH_N0@Z)，该符号在函数main
 中被引用
解决方法：
（1）添加#include"opencv2/nonfree/features2d.hpp"头文件
（2）用VS2010的话就在通用属性->连接器->输入->附加依赖项里边添加上库文件opencv_nonfree249d.lib这里最后的249具体可能根据你的版本变化，为你当前opencv版本，d字母表示debug，也可去掉，表示Release。


8.error
 RC2170: bitmap file res\XXX.bmp is not in 3.00 format

9.
去除VS2010对汉字的拼写检查后留下的红色波浪线
VAssistX菜单栏->Visual Assist X Options->Underlines->把underlines spelling errors in comments and strings using前面的勾去掉就行


10.

在我们建立三维模型的过程中，当用多边形网格或者是三角面片来近似的表示曲面的表面时，曲面被离散成许多的平面多边形，如果我们的网格较大，离散度较粗，在模型表面使用明暗处理后，两两相邻的多边形会出现凸起或者是凹陷的折痕，在连接处显得比周围处亮或者暗，这就是所谓的马赫夫效应，如下图所示
针对于出现的马赫夫效应，我们需要进行明暗处理，消除或者是减少三维模型的马赫夫效应，使其看上去更加的光滑美观，常用的明暗处理技术有双线性光强插值—Gouraud明暗处理技术和双线性法向插值-Phong明暗处理技术。以下展示经过明暗处理前后结果对比
OpenGL提供了两种着色模式
void glShadeModel ( GLenum mode)，恒定着色
GL_FLAT，光滑着色GL_SMOOTH，而GL_SMOOTH中则是使用了Gouraud明暗处理技术，对于Phong明暗处理技术可以参见http://blog.csdn.net/dalewzm/article/details/46291397
http://blog.csdn.net/silangquan/article/details/10011169

Gouraud明暗处理算法在处理亮度的不连续性方面很有效，但是在明暗强度函数的斜率急剧变化处仍然可以看到马赫夫效应，不能完全消除光强度的不连续性。而Phong明暗处理是对表面的法向量而不是亮度进行插值，大大改善了Gouraud模型对高亮度镜面反射光的处理，在每一点都是用法向量的一个近似值，所以一般法向量插值的结果要优于亮度插值，在很大程度上消除了马赫夫效应，但是会大大增加明暗处理的时间。


鉴于此，我在用MC算法建立三维模型的时候，由于我的网格设置较大，导致出现了马赫夫效应，即模型表面的可视化效果不光滑，如下：



于是使用OpenGL自带的Gouraud明暗处理技术，以一个MC算法生成的章鱼模型为例子，效果如下
相比未使用明暗处理的模型，使用了Gouraud处理的模型从可视化的角度上来看更加的光滑，效果更好。




医学raw文件下载地址（自己的下载频道）:1:http://download.csdn.net/detail/hw140701/9832153
2:http://download.csdn.net/detail/hw140701/9832151
没有积分的可私信我。
VS2010-MFC在状态栏上添加进度条比在VC6.0中更加简单，不需要再从CStatusBar类中派生子类。
仔细查看VS2010生成的MainFrm.h文件我们可以看出，m_wndStatusBar已经是CMFCStatusBar的对象了，而不是CStatusBar对象。
CStatusBar对象。
所以就去微软的官网查看CMFCStatusBar的帮助文档，有中文，太好了
CMFCStatusBar的帮助文档，有中文，太好了
微软提供的MFC的帮助文档，有中文

微软提供的MFC的帮助文档，有中文

CMFCStatusBar类的帮助文档
此类自带进度条，只需要调用就可以了






以下为如何在VS2010单文档程序中在进度栏上添加进度条
步骤1:如上图所示，将m_wndStatusBar从protected型变量改成public型变量；
m_wndStatusBar从protected型变量改成public型变量；
步骤2：在MainFrm.cpp中添加进度条的标识IDS_PROGRESS
步骤2：在MainFrm.cpp中添加进度条的标识IDS_PROGRESS




并在资源文件字符串表String Table中新增一个字符串IDS_PROGRESS，如下图
并在资源文件字符串表String Table中新增一个字符串IDS_PROGRESS，如下图








步骤3：在CMainFrame的OnCreate()函数中添加以下代码，用于初试化状态栏
步骤3：在CMainFrame的OnCreate()函数中添加以下代码，用于初试化状态栏




步骤4：在View中某个读取文件的响应函数，添加以下代码，即可在状态栏显示文件加载进度条，以及当前文件大小和百分比信息




当我们点击读取文件后，文件总长度可以通过FILE类的Ftell函数进行获取，然后就可以在状态栏查看当前文档的加载进度以及已经加载文件的大小




整个编写流程就完成了，比VC 里面简单太多了。
使用VTK生成分布在球内部或者表面的三维点云数据，可以设置球的中心，半径以及生成的三维点的个数并选择可以设置在球内部生成或者是球表面生成。

在原先的博客VTK读取一个TXT文档中的三维点坐标绘制三维点云基础上，有小伙伴询问是否可以以点云中每一个三维点的坐标为中心绘制一个小的球体，用于标识特征点，这种就让我想到了化学里面的分子结构，所以就在原有博客的基础上进行了改写，实现了点云不是以点的方式而是以小球体形式显示出来，实现了大量球体的同时绘制。
不多说直接贴代码：

整体图：




局部的线框显示细节图：




局部表面显示细节图：


LeetCode第一题：
问题描述：给定一个整形的数组，在给定一个特定的整数值，要求返回这个整形数组中两个元素的和等于给定的整数的元素索引。
STL容器vector是新手入门STL最常用也是最好用的容器类，其不像array需要固定大小，而是可以动态的在容器尾部或者是中间插入元素，相当的好用，但是我们往往会在一个程序中向vector中压入了很多的元素，在使用完vector中的元素之后，只是会用clear去清理vector中的元素，有些小伙伴认为清空容器就等于释放了内存，其实真正的是这样的吗？我们不妨来做一个测试。
首先我们声明一个double型的容器，往里面压入了10000000个元素，然后用clear方法，看是否能真正的释放掉vector所占的内存，这里用SDK中的 GetProcessMemoryInfo方法来获取当前进程的所占用的内存。
代码如下：

程序运行结果：




我们可以看到使用clear方法虽然清空了vector中的元素，但是并没有释放掉vector所占用的内存，高效的管理内存是程序设计所要求的，C++ 11有了一个全新的shrink_to_fit()方法，该方法与clear()搭配使用，将vector所占用大小缩小到合适的范围，以下进行测试
代码如下：






我们可以看到，使用shrink_to_fit方法可以快速的释放掉vector所占用的内存。
MFC的界面太丑了，但是学会之后写一写简单的可交互的PC端程序还是可以的，但是用VS2010自己生成的MFC工程上的控件程序还是MFC经典风格，实在是看不下去，如下




要使其按钮带有Win7风格，带有Aero的美化效果，就需要在MFC工程的头文件Stdafx.h文件中，加入以下代码








但是如果想要有更加好的效果，还是自绘吧。
1.SkinMag MFC美化界面库
总所周知，MFC的皮肤比较呆板，有各种各样的MFC界面库可以供我们使用，来修改程序的外观。C++界面库可以参见：http://blog.csdn.net/witch_soya/article/details/10982451
在这里介绍一种配置比较简单的MFC界面库SkinMagic。
可从这里下载SkinMagic2.4破解版：http://download.csdn.net/download/wbxyzwh/9693071
下载解压后，文件夹文件如下：
2.SkinMagic在VS2010 MFC程序中的配置
2.1文件拷贝
将下列三个文件以及所有的*.smf皮肤文件拷贝至建立的MFC工程文件目录下




2.2
在stdafx.h中加入头文件和库的引用，如下：



皮肤的调用有两种方法，一是直接从皮肤文件中调用，另一种方法是从资源文件中调用，分别说明如下：




在CxxxApp::InitInstance()中的加入以下代码如下：

2.5 将皮肤应用到程序上
3. SkinMagic界面库各个皮肤效果
一个基于指针和重载操作符的数组类设计Array,可以进行数组范围检查，与平常看到的类而言，这个类的编写让人感觉逻辑十分清晰，以及更加可以理解面向对象程序设计理念。
Arry.h




更新于2017年7月7日：刚刚有网友说为什么将照片大小设置为500*500或者是更大的尺寸就不可以了，因为随着静态数据的增加所需要的堆栈保留大小就会增加，而VS中默认保留的是1M，所以程序尚未运行就会出现堆栈溢出错误，解决方法参考一下以下的博文：VS2010运行错误：0x010e86c7
 处有未经处理的异常: 0xC00000FD: Stack overflow - yangliuqing19的博客 - CSDN博客  http://blog.csdn.net/yangliuqing19/article/details/51568731点击打开链接
主要用到OpenCV自带的CascadeClassifier这个类下的detectMultiScale函数，其检测效果并不是很好
    

（1）静态图片上的人脸检测





可以看出，有些人脸没有检测出来，或者是检测出来有位置错误。
（2）摄像头人脸检测

参考书籍：数据结构（C++版）陈宝平主编
参考链接：http://www.cnblogs.com/charley_yang/archive/2010/12/08/1900256.html
二叉树类封装以及代码

最近有小伙伴在问，我想显示一个求得的三维点云中的每一个点的法向量的指向，怎么获得这种逼真的三维显示效果呢？当然是OpenGL啦，也是我自己用的比较习惯，所以就花了十几分钟帮助上面提问的小伙伴解决问题，然后也提供给大家一个查看三维点云法向量的工具，稍后我会在我的ＣＳＤＮ的下载频道上传该软件的Ｒｅｌｅａｓｅ版本供大家使用，主要的显示效果是三维点云中的每一个点使用实心球体表示，法向量用一个方向箭头和圆锥体表示，类似于坐标轴的指向。主要用到三个函数，Render3DCylinder（在任意两个三维点间画圆柱体），Render3DSphere（以任意三维点为中心画球体），Render3DCone（在任意两个三维点之间画圆锥体）。
其三个函数的主要代码如下：






整个程序的源码由于项目的关系不能给出，只能给出发布版本，不过主要的核心的功能是利用上述的三个函数实现的。相应的程序的Realease版本的下载地址：[免费]OpenGL+MFC显示三维点云中每一个点的法向量，Release版本-CSDN下载  http://download.csdn.net/download/hw140701/9970732http://download.csdn.net/download/hw140701/9970732



1.新建一个编辑框控件（Edit Control）,将其多行（Multiline）前面打勾（属性设置为True）,Auto HScroll（自动水平滚动）前面的勾去掉（属性设置False）,这样就可以实现每一行填满后自动换行了。
2.再将垂直滚动条（Vetrical Scroll）前面打勾（属性设置为True），自动垂直滚动打钩，设置成true，当输入或显示超过编辑框的大小后就会出现垂直滚动条。
3.如果是输入，滚动条会自动移动跟随到当前输入行，但是如果是设置将很多内容一次性让编辑框显示，滚动条就会一直处于最上方，需要手动拉到最下面才能看见最后一行的内容，在很多时候这是我们不需要的，而是想要滚动条处于最下方，如下的代码将实现这一功能：
this->SetDlgItemText(IDC_EDIT_RECV,str);//将字符串str中内容显示到ID为IDC_EDIT_RECV的编辑框
m_recvshw.LineScroll(m_recvshw.GetLineCount());//m_recvshw为该编辑框的成员变量（也就是control类型的变量）
//使用控件变量的一些成员函数设置滚动条的位置




这两天有个筒子叫我帮他爬这个网站http://bbs.baobeihuijia.com/forum-191-1.html上的失踪儿童信息，准备根据失踪儿童的失踪时的地理位置来更好的寻找失踪儿童，这种事情本就应该义不容辞,如果对网站服务器造成负荷，还请谅解。


这次依然是用第三方爬虫包BeautifulSoup，还有Selenium+Chrome，Selenium+PhantomJS来爬取信息。
通过分析网站的框架，依然分三步来进行。
第一步：获取http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接
http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接
第二步：获取每一个分页链接上所发的帖子的链接
第二步：获取每一个分页链接上所发的帖子的链接
第三步：获取每一个帖子链接上要爬取的信息，编号，姓名，性别，出生日期，失踪时身高，失踪时间，失踪地点，以及是否报案
第三步：获取每一个帖子链接上要爬取的信息，编号，姓名，性别，出生日期，失踪时身高，失踪时间，失踪地点，以及是否报案
起先用的BeautifulSoup，但是被管理员设置了网站重定向，然后就采用selenium的方式，在这里还是对网站管理员说一声抱歉。
1、获取http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接
获取
http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接




通过分析：发现分页的页面链接处于<div class="pg">下，所以写了以下的代码
通过分析：发现分页的页面链接处于<div class="pg">下，所以写了以下的代码
BeautifulSoup形式：


2.获取每一个分页链接上所发的帖子的链接
2.获取每一个分页链接上所发的帖子的链接
获取每一个分页链接上所发的帖子的链接






每个帖子的链接都位于href下
每个帖子的链接都位于href下
每个帖子的链接都位于href下
所以写了以下的代码：
所以写了以下的代码：
所以写了以下的代码：
BeautifulSoup形式：
BeautifulSoup形式：
BeautifulSoup形式：



获取每一个帖子链接上要爬取的信息，编号，姓名，性别，出生日期，失踪时身高，失踪时间，失踪地点，以及是否报案，并写入CSV中








通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
BeautifulSoup形式：
BeautifulSoup形式：
BeautifulSoup形式：
BeautifulSoup形式：




现附上所有代码，此代码仅供参考，不能用于商业用途，网络爬虫易给网站服务器造成巨大负荷，任何人使用本代码所引起的任何后果，本人不予承担法律责任。贴出代码的初衷是供大家学习爬虫，大家只是研究下网络框架即可，不要使用此代码去加重网站负荷，本人由于不当使用，已被封IP，前车之鉴，爬取失踪人口信息只是为了从空间上分析人口失踪的规律，由此给网站造成的什么不便，请见谅。








附上所有代码：
附上所有代码：
附上所有代码：
附上所有代码：




































三维模型重建顾名思义就是从一些数据（点云，图片，三维轮廓线等）重建出物体的三维逼真的三维模型，在其重建的过程中针对不同的数据的的三维重建会有不同的处理算法，如针对点云数据的三维重建有很多种重建方法,如基于Delaunay三角化，Voronoi图，隐式曲面等方法，另外在三维模型的重建过程（MarchingCube，RayCast,网格构建等）以及三维模型生成后的后处理算法（三维网格简化，三维网格加密，三维模型表面光滑，三维模型的空洞修补等等）也是层出不穷，在这其中需要用到大量的三维图形学知识（从简单的画点画线算法到复杂的体绘制算法，以及光照计算，材质映射等）。在最后的实现方面致力于提高算法效率和运行性能，各种加快算法实现的三维数据结构（KD树，八叉树等）的提出和实现，以及压榨计算机和服务器性能的并行算法（OpenMP，MPI）等，减少算法实现过程中的内存占用以及运行时间（降低空间复杂度以及时间复杂度）。三维模型重建上的优秀算法或者是优秀实例我也只是管中窥豹，上面所提到的有些名词我也是大致了解，我尽自己最大的能力介绍下自己闲暇时间以前做过的相关三维模型重建的实例和其他相关的关于三维重建方面的知识，毕竟能力有限，知识面还有待拓展。
1.编程语言
是用的编程语言是C/C++，基本上相关的图形学方面的实现都是使用C/C++作为开发语言，不是说别的语言如Java，Python等语言不好，确实在效率方面以及内存处理方面C/C++有着比较大的优势，而且现在市面上的三维图形库其底层语言就是C/C++，所以使用起来更加方便。一门语言有其适用的场景和场合，正如Java在WEB和APP上面的天然优势一样，C/C++在图形处理，图像识别以及其他的图形处理领域也有着很大的优势。
2.我所使用的第三方库
（1）三维图形库OpenGL
OpenGL(Open Graphics Library)，OpenGL图形绘制库，有着优秀的二维和三维图形API，是一个功能强大的三维图形绘制的底层库，有着大量的调节三维模型视觉效果的函数，例如光照，模型材质，纹理等等。早期OpenGL包GLUT依然比较强劲，但是其不能用于64位平台的编译，而且GLUT官方已经不维护了，那么有一个新的FreeGlut横空出世，支持最新的OpenGL绘图标准，并且支持64位平台的编译，能够完全取代老化的GLUT库。


（2）三维图形库VTK
VTK（Visualization Tool Kit）同样也是一个优秀的三维图形库，近年来相当的火爆，它以OpenGL作为底层绘制语言进行封装，用户不需要考虑太多的光照以及材质影响到模型可视化效果的设置，这些VTK都已经帮你做好了，你需要考虑的是如何从原始数据绘制出你的图形。其内部封装了大量的三维图形处理函数，基本上你所能想到的算法都能找到影子，比如著名的面绘制方法MarchingCube，体绘制方法Raycast等等，往往你能在阅读他的帮助文档的时候看到一个意想不到的功能。


（3）计算机视觉库OpenCV
OpenCV（Open Source Computer Vision Library）今年来大热的计算机视觉库，同样以C/C++作为底层语言，封装了大量的图形处理和计算机视觉领域的算法，比如说图像识别领域，机器人，人类视觉仿真，好像现在大热的人工智能领域也开始使用OpenCV进行视觉领域方面的处理。


（4）矩阵运算库Eigen
在三维图形处理过程中通常需要大量的矩阵运算，而Eigen是一个轻量级的矩阵运算库，其函数API涵盖了几乎所有的矩阵运算，但是它的使用只需要包含一个头文件，不需要过于复杂的配置就可以使用已经封装好的各种矩阵运算函数。


（5）并行计算库OpenMP
OpenMP可以在你把项目代码构建好之后也仍然可以通过几行代码将你的程序自动的进行并行化计算，使用起来非常的简单，并行计算可以大幅度的提高你的程序的运行速度以及计算的效率。如果你的IDE是VS，那么你只需要简单的开启OpenMP就可以了，然后在VS中包含其头文件就可以使用OpenMP封装的函数进行并行程序设计。


其他的如CGAL（几何算法库），QT（图形界面库，不过本人更喜欢用老掉牙的MFC）等等。


3.我所接触到的三维重建类型
（1）点云三维重建（隐式曲面重建）
原始三维点云（三维点云以及法向量）-斯坦福兔子1889个点，采用OpenGL从底层写的径向基隐式曲面点云重建方法


采用径向基隐式曲面重建后的三维模型

（2）医学序列图片三维重建（使用VTK进行医学图片处理，模型构建采用MarchingCube算法）
重建结果

（3）OpenCV双目视觉重建（医学冠脉三维重建，VTK做可视化）
左视图A

右视图B

使用OpenCV做的三维冠脉重建，VTK做的显示

（4）基于轮廓线的三维模型重建
轮廓线


重建的三维模型




4.结语
万事开头难，作为一个刚刚入门三维重建领域的人写这篇文章心中的感觉简直是战战兢兢，三维模型重建方面的知识浩如沧海，我只不过是只窥得了寥寥数星。只不过自己想把自己学习到的一些知识与有缘人交流分享，共同进步。不知以后还不会不在三维领域工作与发展，不过之后的事情谁又知道呢。
后面我会详细介绍一些三维重建算法以及一些实例。



最近需要用到三维点云数据，但是网上大部分的数据资源的数据格式都是杂乱无章而且没有清晰的数据说明，为了方便，自己整理了常用的三维点云数据，格式都是按照X坐标空格Y坐标空格Z坐标这种数据格式排列，方便数据读取和进行三维点云的重建实验。
   其中的数据包含了著名的斯坦福兔子，大象，马，凳子，人头等三维点云数据，显示的效果如下：






















以下为三维点云的重建效果：
三维点云数据我已经上传到我的下载频道：常见的三维点云数据，已经整理数据格式 - 下载频道 - CSDN.NET  http://download.csdn.net/detail/hw140701/9852949
常见的三维点云数据，已经整理数据格式 - 下载频道 - CSDN.NET http://download.csdn.net/detail/hw140701/9852949



另外一些常见的三维模型的下载地址为：常见的三维模型下载地址：http://www.cc.gatech.edu/projects/large_models/
希望可以帮助到有缘人0.0




1.OpenCV创建一个灰度图，遍历每一行每一列并设置每一行每一列的像素值，并将其保存为图片,但是at方法可读性较高，但是效率不高

2.OpenCV创建一个灰度图，使用迭代器iteator遍历每一行每一列并设置每一行每一列的像素值，并保存
随机数填充像素值



3.OpenCV创建一个灰度图，使用数据指针遍历每一行每一列并设置像素值，保存图像，但是指针很危险
不进行数组越界检查


由于最近的需要在任意两个三维点直接绘制三维圆柱体管道，OpenGL太底层了，以至于什么东西都要自己写
在网上参考了如下的博客:
http://blog.csdn.net/ryfdizuo/article/details/6548257

http://blog.sina.com.cn/s/blog_5cd804e70100oxca.html

http://blog.sina.com.cn/s/blog_3d2759c90100rpnf.html

在上述博客中有详细的原理介绍，而我只是将代码改成自己可以用的形式，以便调用。
代码如下：









增大其传进去的两个参数：段数Slices，以及递归次数stacks，可以获得更加光滑的圆柱体绘制效果：
vtk中没有可以直接在三维空间中绘制三维空间圆的类以及函数，在这里，编写了以函数以任意的三维点为中心，任意半径，绘制平行于Z=0平面的圆，
可以用于批量绘制三维空间的圆。也可改写为平行为X=0或者Y=0的平面。

参考代码为：在三维空间中Z=给定值平面绘制半径为给定值的圆，圆内部填充
MFC PictureControl控件上自适应显示图片，分图片失真或者图片不失真两种





图片不失真，但是没有铺满整个图片控件区域：


问题描述:将一个string型的字符转成int型的数字，需要处理字符串输入的各种情况，如字符串前面的空格，+号，-号等符号。
     测试代码：

使用findContours（）查找图片轮廓线，并将轮廓线坐标点输出，访问二维vector，使用迭代器和下标两种方式


由于需要在三维空间中进行三维模型的碰撞与相交，为了加快检测的效率，考虑用三维物体包围盒。AABB与OOBB包围盒比起来原理简单，容易实现，为了更好的在三维空间中使用AABB包围盒，所以自己写了一个关于三维的AABB包围盒类AABB类，写了不同参数的构造函数，以及关于AABB包围盒的各种成员方法，虽然不是很全，但是可以满足日常的需要。
下面贴代码：
AABB.h


突发奇想，想写一个轰炸自己QQ好友的聊天轰炸机，哈哈哈，看了半天自己就写了一个Low的聊天轰炸机，纯粹依靠剪切板往聊天窗口复制文字，然后模拟回车按钮完成发送，写了一个简单的MFC对话框Demo，大牛自动跳出，无需再看。
主要代码如下：



1.单独拉出你想轰炸的QQ好友的聊天窗口，不要合在一起；
2.设置你想轰炸的QQ好友的昵称，就是你前面拉出来的单独的会话窗口好友的昵称；
3.选择你的BOOM.txt文件，里面是你想轰炸别人的话；
4.设置轰炸的次数。
截图如下：






源码链接：源码链接，Debug和Release版本，里面自带了我自己写的BOOM.txt




OpenCV2中新增了方便的Mat类，但是OpenCV中仍然支持C语言的lplImage和CvMat结构，但是在有些时候，出于兼容性的考虑，需要进行Mat与IpIImage和CvMat的转换。
1.Mat转为lplImage和CvMat格式
1.1 Mat转为IplImage结构
Mat img(Size(400,400),CV_8UC3);
lplImage iplimg=img;//转为IplImage结构
1.2 Mat转为CvMat类型
CvMat cvimg=img;//转为CvMat结构
类型转换后，IplImage和CvMat与Mat共用同一矩阵数据，IplImage和CvMat没有引用技术功能，如果img中的数据被释放，那么iplimg和cvimg也同时失去数据。
2.IplImage和CvMat格式转为Mat
Mat类有两个构造函数，可以实现IplImage和CvMat到Mat的转换。这两个函数都有一个参数copyData,如果copyData的值为false,那么Mat将于IplImage或CvMat共用同一矩阵数据，如果值是True,Mat会申请新的内存，然后将IplImage或CvMat的数据复制到Mat的数据区。如果共用数据，Mat不会使用计数器来管理内存，需要自己来管理。建议将参数设置为True.
构造函数如下：
Mat::Mat(const CvMat *m,bool copyData=false)
Mat::Mat(const IplImage * Img,bool copyData=false)
例子：
IplImage *iplimg=cvLoadImage("LOL.jpg");
Mat im(iplimg,true);
CvMat类似上例。
用惯了AfxMessageBox（），总感觉这个东西不那么顺手，就想在状态显示当前程序的提示信息。
想要在任何类中都设置状态栏的信息，必须获取到m_wndStatusBar的指针。
所以第一步，将CMainFrame中的m_wndStatusBar的保护类型从保护改为public
m_wndStatusBar的保护类型从保护改为public




第二步：在任意类中添加下列代码，改变状态栏的提示信息



BeautifulSoup的find()和findAll()这两个函数在某些方面十分的相似，我们可以使用它们过滤HTML页面，并查找需要的标签组和单个的标签。
    这两个函数非常的相似：
    findAll(tag,attributes,recursive,text,limit,keywords)
    find(tag,attributes,recursive,text,keywords)
    
    
标签参数tag:可以传递一个标签的名称或多个标签名称组成的Python列表做标签参数。
    如：findAll({"tag1","tag2","tag3","tag4"})
    
    
属性参数attributes是用一个Python字典封装一个标签的若干属性和对应的属性值。
    如：返回HTML文档中attribute1和attribute2属性的tag标签
    findAll("tag",{"classs":{"attribute1","attribute2"}})
   
    
递归参数recursive是一个布尔变量。如果你想知道所抓取的HTML文档标签结构中有多少层的信息，如果recursive设置为True，findAll就会根据你的要求去查找标签参数的所有子标签以及子标签的子标签。如果recursive设置为False，findAll就只会查找文档的以及标签。findAll默认支持递归查找（recursive的默认值是True）,一般情况下不需要设置该参数。只是当你真正了解自己需要哪些信息，而且抓取速度非常重要时，就可以视情况设置递归参数。


    
文本参数text是使用标签中的文本内容去进行匹配，而不是标签的属性。
    如果我们需要查询某个网页中包含"the text"内容的文本数量，我们可以使用以下语句
    namelist=bsObj.findAll(text="the text")
    print(len(namelist))
    


    
范围限制参数limit，只能用于findAll方法。find()方法等价与findAll()方法limit参数等于1时的情形。如果你只对网页中获取的前x项感兴趣，就可以设置它。但是要注意的是这个参数设置之后获取的前几项结果是按照网页上的顺序排序的，也有可能不是你想要的结果。
  
    
关键词参数keyword，可以让你选择那些具有指定属性的标签。
   如：
alltext=bsObj.findAll(id="text")
        print(allText[0].get_text())
       
    .get_text()会把你正在处理的HTML文档中的所有标签都清除，然后只返回一个只包含文字的字符串。如果你正在处理一个包含许多超链接、段落以及标签的大段源代码，那么get_text()会把这些超链接、段落、以及标签全都清除，剩下不带标签的文字。
   通常在你准备打印，存储以及操作数据时，应该在最后再使用.get_text()去提取你想要的文本信息，在一般的情况下，应该尽可能的保留HTML文档的标签的结构。
我们在进行爬虫时有的时候不可能只是在一个网站上进行内容上的爬取，理想中的爬虫应该是顺着一个链接从一个页面到另外一个页面，这需要获取页面上的所有的外链，同时收集每个页面上的内链。网站首页上不一定会发现外链，为了防止程序出错，就要递归深入到一个网站直到找到一个外链为止。
但在爬取的过程中出现了TimeoutError: [WinError 10060] 由于连接方在一段时间后没有正确答复或连接的主机没有反应，连接尝试失败。这个错误。
可能是由于访问网站频率过快，或者是我处于校园网，访问过快，被学校的服务的给限制了，或者是网速不好。所以在网上百度了下，设置了代理IP，结果完美运行，没有出现这个原因，最新的代理IP，自行百度即可。
Meshlab是一个强大的三维模型处理的软件，在三维点云的处理方面也十分强大，不仅仅可以用三维点云重构出三维模型，还可以计算出三维点云每个点的法向量，这在逆向工程和基于三维点云的隐式曲面重建中非常有用。
   我的Meshlab的版本是3.3，可以在网上自行下载破解版。
1.Meshlab读取三维点云
第一步：打开Meshlab软件
第二步：点击File菜单下的ImportMesh导入txt文档，需要选择你的txt文档中XYZ坐标之间的分隔符，导入成功后会显示你的三维点云数据
2.三维点云重建
点击下图图标，弹出右侧图层侧边栏
然后点击Fiter菜单下Normals，Curtavures and Oreientation下的Smooths normals on a point set计算三维点云的法向量，如下图
然后设置计算点云法向量的参数，默认就好，如有需要可以自行设置，点击Apply等计算完成然后点击Close关闭对话框
计算完点击法向量之后，点击Filter菜单下Remeshing Simplication and Reconstruction下的Surface Reconstruction：Ball Pivoting进行三维点云重建
然后设置三维点云重建参数，默认就好，也可以自行设置，点击Apply等重建完成，点击close关闭对话框
然后点击下列图标显示重建的三维模型，也可以设置光照等其他参数
以下为三维重建结果
3.法向量的导出与计算
三维点云的法向量的导出与计算有两种方式，一种是在上一节三维重建中我们已经得到了重建后的三维模型，那么每个点都带有法向量，可以直接导出即可，还有一种就是从杂乱的三维点中计算每一个三维点的法向量
3.1从三维模型中导出三维点云中每个点的法向量
接着第二节的步骤，点击File菜单下Export Mesh as 
然后在接下来的对话框中选择xyz格式
然后在 接下来的对话框中勾选Normal就可以生成文本格式的三维点以及三维点法向量
以下为文本格式的三维点坐标以及三维点法向量的结果
3.2 直接从三维散乱点云中生成三维点的法向量
然后点击Filter菜单下Normals，Curtavures and Oreientation下的Compute normals for point set计算三维点云的法向量，如下图
在弹出来的对话框可以自行设置参数，先Apply然后再Close
法向量的导出与3.1中的一样，可以自行参考。


以下为三维点云以及点云的法向量的可视化结果，点云表示为红色的点，法向量表示为绿色的线段
好久都没有动Python了，自从在网上买了《Python网络数据采集》这本书之后一直没有时间写自己的小的Demo,今天再网络上无意中看见
http://www.cnblogs.com/mfryf/p/3695844.html：

这篇博客，自己想要不花一个小时复习下BeutifulSoup，然后实现与上面的那个博客一模一样的功能，其实自己以前就想写这样的一个东西，像上面博主一样，也只是想每天看一下博客的访问量有没有上涨，哈哈哈哈哈。
MFC项目开发过程中需要获取某个树控件下某个树节点下所有的子节点的文本，添加到某个组合框上，网上的相关代码差不多是遍历整个树控件，所以自己就封装了一个函数，用于获取指定树节点下的所有的子节点的文本然后添加到某个组合框中，其中获取的文本被压入CString类型的容器保存。

当初学Python进一个Python学习群，不久之后群主大大就发了自己写的一个爬虫，就是爬取www.mzitu.com网站上的妹纸图片，看完之后，惊为天人，一脸懵逼，觉得群主大大好厉害，当初自己进群的初衷以及学Python的初衷就是为了做爬虫，然后慢慢的开始。所以说这次，就是为了实践一下，爬取这个网站上的所有的图片，别邪恶哦，虽然是隐藏福利，我只是为了写爬虫实践，我只是为了写爬虫实践，我只是为了写爬虫实践！！！


网络爬虫会给网站服务器造成巨大负荷，所以，本次实践的源码仅供参考交流，不宜用于商业应用，由此造成的任何法律责任本人不予承担。


为了得到这个网站上所有的妹子图片，就得分析网站的架构，通过分析发现http://www.mzitu.com/all这个网址下有2013-2017年网站上所有的相册的链接，所以准备通过以下步骤爬取网站上的所有图片。


第1步：在http://www.mzitu.com/all下获取所有的相册的链接以及相册的名字
第2步：根据每个相册的链接得到每个相册每一个图片页面的链接
第3步：根据每一个图片的链接得到每一张图片的名字以及图片链接


第一步：在http://www.mzitu.com/all下获取所有的相册的链接以及相册的名字
在
http://www.mzitu.com/all下获取所有的相册的链接以及相册的名字
分析网站源码，查看每一个相册链接以及名字的所处标签




由图上可以看出，每一个相册的链接以及名称都位于<a >标签下


第二步：根据每个相册的链接得到每个相册每一个图片页面的链接
根据每个相册的链接得到每个相册每一个图片页面的链接
通过分析网站源码，分析每一个相册下每一个图片页面的链接
通过分析网站源码，分析每一个相册下每一个图片页面的链接




通过分析，发现每一个图片页面链接都处于<div class="pagenavi">的<a herf>下，但是只有几个图片的页面的链接，如上图所示，分别只有2,3,4.......65，但是图片页面的规律是相册链接+"/"+页面编号，在这里我们得到最大的页面编号65，就可以通过循环得到每一个图片页面的链接，所以在这里通过字符选取将编号压入进一个list，然后通过max方法得到最大编号，得到每一个相册图片页面的链接。


第三步：根据每一个图片的链接得到每一张图片的名字以及图片链接
根据每一个图片的链接得到每一张图片的名字以及图片链接
根据以上得到的图片页面链接，在每个页面内爬取图片的下载链接以及图片的名称
根据以上得到的图片页面链接，在每个页面内爬取图片的下载链接以及图片的名称




通过分析，图片链接以及名称都位于<img>标签内


通过以上的分析，将整个流程写为Python代码，在其中使用了第三方包Beautifulsoup,现附上全部代码，如有错误，请指教







刚刚开始写的时候，会遇到服务器断开链接，以及主机在一定时间内无法连接的错误，在百度上，谷歌上看了半天，可能是由于网站的反爬虫机制，我自己的解决办法如下，不知道你们可不可行：
1、关闭windows防火墙，爬完再开
2、采用多headers，伪装不同的浏览器
3、每下载完，sleep一下，减缓访问网站的频率，如果过快，网站服务器会认为你是爬虫
4、设置全局超时时间，有时候因为网速的问题会出现这种情况
5、设置代理IP


刚刚开始不知道为什么这个网站不能用代理IP访问，一访问，网站服务器就强制断开连接，后来又可以了，尽量用代理IP，免得被封IP，代理ip网站可上http://ip.zdaye.com/查询


在这个代码中，没有采用多线程机制，所以爬起来比较慢，勿喷。
最好在晚上爬，网速快。
爬取结果（隐藏福利）：






转载地址：http://www.cnblogs.com/bluestorm/p/3168720.html
这三种类型各有各的优点，比如CString比较灵活，是基于MFC常用的类型，安全性也最高，但可移植性最差。string是使用STL时必不可少的类型，所以是做工程时必须熟练掌握的；char*是从学习C语言开始就已经和我们形影不离的了，有许多API都是以char*作为参数输入的。所以熟练掌握三者之间的转换十分必要。
VTK生成指定圆心以及指定半径的三维球，并将其导出为obj三维模型格式



Meshlab中载入qiu.obj




可在meshlab中将其转换为其他的三维数据格式或者提取球体表面的三维点云。
一、创建状态栏的两种方法
CStatusBarCtrl和CStatusBar两个类来完成
CStatusBar两个类来完成
                  //设置状态栏文本
                  m_StatusBar.SetText("分栏一", 0, 0);
                  m_StatusBar.SetText("分栏二", 1, 0);
                  m_StatusBar.SetText("分栏三", 2, 0);
                  //下面是在状态栏中加入图标
                  m_StatusBar.SetIcon(1, 
                                SetIcon(AfxGetApp()->LoadIcon(IDR_MAINFRAME),
                 //----------------让这个状态栏最终显示在对话框中-------------
                  RepositionBars(AFX_IDW_CONTROLBAR_FIRST,AFX_IDW_CONTROLBAR_LAST,0);
二、实时显示系统时间信息
在程序中添加WM_TIMER消息响应函数，这里以基于对话框程序为例
第一种创建状态栏的方法
void CCJCZDlgDemoDlg::OnTimer(UINT_PTR nIDEvent)
{
// TODO: 在此添加消息处理程序代码和/或调用默认值
CTime t = CTime::GetCurrentTime();
CString str;
str.Format("%04d/%02d/%02d  %02d:%02d:%02d",t.GetYear(),t.GetMonth(),t.GetDay(),t.GetHour(),t.GetMinute(),t.GetSecond());
m_StatusBar.SetText(str, 2, 0);


CDialogEx::OnTimer(nIDEvent);
}

m_wndStatusBar.SetPaneText(2,str);
    冠脉三维重建就是从两幅不同角度拍摄的冠脉医学图片根据相机参数(角度)重建出原有的三维冠脉形态。
    具体文献可以参考：
      1.黄家祥. 冠状动脉树三维骨架重建方法的研究[D]. 天津大学, 2003.
      2.王国铸. 单臂冠脉造影三维重建与定量分析[D]. 华中科技大学, 2012.
      3.郝培远. 冠脉造影三维重建定量分析(QCA)及最佳投照角度的研究[D]. 南方医科大学, 2011.等文献





这里以黄家祥这篇文章的数据作为例子，具体的冠脉三维重建步骤可见这篇文章黄家祥. 冠状动脉树三维骨架重建方法的研究[D]. 天津大学, 2003。
以下为其中的一个实验所给出的数据，两幅不同角度的图片为。




         图A                               图B




图A和图B的相机参数分别为RAO 0，CAUD35和LAO 80，CRAN15。

图A和图B的相机参数分别为RAO 0，CAUD35和LAO 80，CRAN15。




















有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。

有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。

有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。






    匹配的结果如下：
匹配的结果如下：
















上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。

上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。

上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。












以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）

以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）

以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）

以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）












总体上来看，重建效果与论文中最后给出的结果类似，VTK封装了OpenGL底层的绘图命令，所以在光照与材质方面不需要我们去过多的设置就会有逼真的三维显示效果。
总体上来看，重建效果与论文中最后给出的结果类似，VTK封装了OpenGL底层的绘图命令，所以在光照与材质方面不需要我们去过多的设置就会有逼真的三维显示效果。




1.显示一个地球各大洲板块的轮廓线

2. 地图指北针图例



原文地址：Graphics Software  http://www.dgp.toronto.edu/~rms/links.htmlGraphics Software
贴出来贴出来贴出来，防止自己忘掉。。。。

Shape Modeling
Texturing
题目描述：反转整数输出，注意的是输入被假定为一个32位有符号整数。当反整数溢出时，函数应返回0。
  今年的华为的实习生招聘笔试的第一个题与这个有点类似，不过华为的是输入两个整数，反转，然后输出两个整数反转后两个数的和。
  测试代码：

自己封装的三维向量类Vector.h,包含一些常见的三维向量类的操作符重载和一些基本运算，可以直接复制粘贴作为头文件包含在项目文件中。

Win32编译环境下，用ADO数据库连接Access数据库一般都不会报错，但是最近由于项目上的需要，程序需要编译成64位以便申请到更多的使用内存空间，当把编译方式从Win32改为x64的时候，突然出现了数据库连接出现未知错误，这时候就猜到了应该是编译环境的改变导致了数据库连接出错，在参考了其他大神的解决方案之后，终于解决了这个问题,我的环境为Win7
 64+MFC(VS2010)+ADO+Access2007。
    参考链接如下：
    http://blog.csdn.net/sundacheng1989/article/details/17925431
    http://www.cnblogs.com/bluedoctor/p/3925871.html
    http://blog.csdn.net/kirawoo/article/details/39032387
    http://blog.csdn.net/u010891996/article/details/12522911


解决方法：
步骤1：去官网下载AccessDatabaseEngine_64.exe,下载链接
https://www.microsoft.com/zh-cn/download/details.aspx?id=13255
或者直接去我的下载频道进行下载
http://download.csdn.net/detail/hw140701/9830665





步骤2:这一个步骤是强制安装刚刚下载的AccessDatabaseEngine_64.exe，如果不强制安装的话，它会要求你卸载你所安装的全部的Office软件，那多麻烦！！！，所以选择忽略提醒，强制安装，
AccessDatabaseEngine_64.exe，如果不强制安装的话，它会要求你卸载你所安装的全部的Office软件，那多麻烦！！！，所以选择忽略提醒，强制安装，
打开cmd.exe,在命令行输入“你的AccessDatabaseEngine_64.exe的存放路径” /passive，比如我的就是"F:\软件\我下载的\Windows数据库编程\AccessDatabaseEngine_64.exe"
 /passive强制安装，输完这个命令就等待安装完成。
打开cmd.exe,在命令行输入“你的AccessDatabaseEngine_64.exe的存放路径” /passive，比如我的就是"F:\软件\我下载的\Windows数据库编程\AccessDatabaseEngine_64.exe"
 /passive强制安装，输完这个命令就等待安装完成。
AccessDatabaseEngine_64.exe的存放路径
AccessDatabaseEngine_64.exe
步骤3：在安装完上述引擎之后，你需要修改一下你的代码，在win32编译环境下我们的数据库的链接字符串是
步骤3：在安装完上述引擎之后，你需要修改一下你的代码，在win32编译环境下我们的数据库的链接字符串是
m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%s",databaseName);

如果你需要在x64的编译环境环境下连接Access数据库你需要修改为
如果你需要在x64的编译环境环境下连接Access数据库你需要修改为
m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

为了更好的适配不同的编译环境，我将我的代码修改为
为了更好的适配不同的编译环境，我将我的代码修改为


m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);
当是32位程序的时候就为
当是32位程序的时候就为
当是32位程序的时候就为
m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);








然后重启一下PC，应该就可以编译成功了。
然后重启一下PC，应该就可以编译成功了。
然后重启一下PC，应该就可以编译成功了。
然后重启一下PC，应该就可以编译成功了。




在网上看见一个对3D建模介绍十分全面的博客，来自中国科技大学图形与几何计算实验室刘利刚老师，介绍的非常棒，膜拜一下。
此处注明转载博客网址：3D建模与处理软件简介-中国科技大学刘利刚
3D建模与处理软件简介
刘利刚
中国科技大学
http://staff.ustc.edu.cn/~lgliu
 
【前言】自半年前笔者发表博客“什么是计算机图形学”以来，时常有人来向笔者询问3D模型的构建方法与工具。
笔者的研究方向是以3D技术为主，具体包括3D建模，3D处理及3D打印三个方面，在3D建模与处理方面从事了
十多年的研究，接触过很多3D相关的软件，在这方面有些经验。因此，特撰写此文，以帮助我们的学生及关注3D
技术的人了解3D建模和3D技术。本文仅仅为笔者根据自己的经验对3D建模与处理软件浅薄的理解，不涉及对技术
的深入讨论，是非学术性的。因此，笔者尽量尝试用通俗的语言介绍一下各种3D建模的软件和工具，以帮助还未接
触3D技术的学生来了解这些工具，以便在今后的科研和工作中能够选择合适的3D工具。笔者对本文的有些内容的理
解也是很有限的，值得进一步的学习和交流。有不当之处，还请读者谅解指正。
 
 
一、           专业3D建模软件
 
1.       3DS
 Max
美国Autodesk公司的3D
 Studio Max（前身是Discreet公司的，后被Autodesk收购）是基于PC系统的三维建模、动画
、渲染的制作软件，为用户群最为广泛的3D建模软件之一。常用于建筑模型、工业模型、室内设计等行业。因为
其广泛性，它的插件也很多，有些很强大，基本上都能满足一般的3D建模的需求。我们的学生也需要经常用到3DS
Max来构建模型。网上关于3DS
 Max的教程和学习视频非常多，使用者众多。
 
2.       Maya
Maya也是Autodesk公司出品的世界顶级的3D软件，它集成了早年的两个3D软件Alias和Wavefront（这两个软件在我
读博时就非常有名，当时就代表了最先进的动画及数字技术，我曾用过Wavefront）。相比于3DS
 Max，Maya的专
业性更强，功能非常强大，渲染真实感极强，是电影级别的高端制作软件。在工业界，应用Maya的多是从事影视
广告，角色动画，电影特技等行业。我们的学生也经常用Maya来制作和渲染3D模型，生成漂亮的渲染结果放在论
文中。
 
3.       Softimage
Softimage曾经是加拿大Avid公司旗下的专业的3D动画设计软件，后被Autodesk收购。它在影视动画方面，特别是
角色功能非常强大。许多电影，比如《泰坦尼克号》、《失落的世界》、《第五元素》等，都曾使用Softimage来
制作大量的惊人的视觉效果。
 
4.       LightWave
LightWave是美国NewTek公司开发的一款3D动画制作软件，具有悠久的历史，我在读博时曾接触过。它的功能非
常强大，特别是在生物建模和角色动画方面功能异常强大，广泛应用在电影、电视、游戏、网页、广告、印刷、
动画等各领域。在电影《泰坦尼克号》中细致逼真的船体模型及其他众多游戏的场景和动画都曾使用LightWave
来制作的。
 
5.       Rhino（犀牛）
Rhino是美国Robert
 McNeel公司开发的专业3D造型软件，它对机器配置要求很低，安装文件才几十兆，但“麻雀虽
小，五脏俱全”，其设计和创建3D模型的能力是非常强大的，特别是在创建NURBS曲线曲面方面功能强大，也得到
很多建模专业人士的喜爱。在与上海造船厂研究所的合作项目中，我们用Rhino来进行船体曲面的NURBS建模和修
改，非常方便灵活。
 
6.       Cinema
 4D
Cinema 4D (C4D)是德国Maxon公司的3D创作软件，在苹果机上用得比较多，特别是在欧美日为最受欢迎的三维动
画制作工具。2009-2010年我在美国哈佛大学访问期间，经常看到学生用C4D在进行3D建模和动画的设计。
 
7.       Creator
MultiGen-Paradigm公司开发的Creator是专门创建用于大型3D虚拟仿真的实时三维模型的软件。其强大之处在于管
理3D模型数据的数据库，使得输入、结构化、修改、创建原型和优化模型数据库非常容易。前几年与一家从事数
字城市的公司合作时我们就用Creator快速创建大量的城市建筑模型，并且生成数据库来管理这些模型，还是相当
的方便。
 
注：从上述介绍可知，美国Autodesk公司当之无愧是当今3D建模和动画的“老大”，拥有3DS
 Max、Maya和Softimage等
3D建模和动画专业软件。3DS
 Max和Maya在3D建模方面各有特色，前者更为大众化些，相对容易掌握些，后者在专
业级的行业应用更为广泛，特别在制作动画和高质量渲染方面强于前者。我们的学生用Maya的相对多些，包括建模，
渲染和动画制作。Softimage和LightWave在3D动画方面表现强大。Rhino对NURBS曲面的支持更好。Creator适合于构
建大量的3D模型并构建数据库进行管理和修改。
 
 
二、           CAD建模和产品设计软件
 
1.       AutoCAD
AutoCAD (Auto Computer-Aided Design)是美国Autodesk公司出品的自动计算机辅助设计(CAD)软件，用于二维绘图
、文档规划和三维设计。适用于制作平面布置图、地材图、水电图、节点图及大样图等。广泛应用于土木建筑、装
饰装潢、城市规划、园林设计、电子电路、机械设计、航空航天、轻工化工等诸多领域。大家买房时看的房型图大
部分都是用AutoCAD来做的。
 
2.       CATIA
Catia由法国Dassault
 Systems公司开发的CAD/CAE/CAM一体化的三维软件，支持产品开发的整个过程，从概念(CAI
D)，到设计(CAD)，到分析(CAE)，到制造(CAM)的完整流程。可帮助制造厂商设计未来的产品，并支持从项目前阶
段、具体的设计、分析、模拟、组装到维护在内的全部工业设计流程，在机械行业，航空航天、汽车工业、造船工
业等应用广泛。其实体造型和曲面设计的功能非常强大。我读博期间曾接触过Catia，在它上面写过一个NURBS曲
面转换的插件程序。
 
3.       SolidWorks
SolidWorks是世界上第一个基于Windows开发的三维CAD系统，后被法国Dassault
 Systems公司(开发Catia的公司)所
收购。相对于其他同类产品，SolidWorks操作简单方便、易学易用，国内外的很多教育机构（大学）都把SolidWork
s列为制造专业的必修课。SolidWorks在杭州有专门的研发机构，我有个学生硕士毕业后在那里进行研发工作。
 
4.       UG
 NX
UG NX由美国Unigraphics
 Solutions (UGS)公司开发的CAD/CAE/CAM一体化的三维软件，后被德国西门子公司收购
。广泛用于通用机械，航空航天、汽车工业、医疗器械等领域。现在西门子公司在上海有专门的研发机构对UG
 NX
产品进行升级完善，我有2个学生博士毕业后在那里负责产品的开发和维护。
 
5.       Pro/E
Pro/Engineer是美国PTC公司(Parametric
 Technology Corporation)旗下的CAD/CAM/CAE一体化的三维软件。在参数化
设计，基于特征的建模方法具有独特的功能，在模具设计与制造方面功能强大，机械行业用的比较多。
 
注：除了上述所介绍的CAD/CAE
 /CAM系统软件（它们各有特色，在市场中都占有一定的份额）外，还有其他一些同
类产品，比如法国Missler公司的Topsolid和以色列Cimatron公司的Cimatron。一般在机械设计与产品研发相关的行业中
才会接触到这些软件，专业性比较强，在网上很容易能找到它们的相关资料。
 
 
三、           3D雕刻建模软件：笔刷式高精度建模软件
 
3D雕刻建模软件(Sculpturing
 modeling)，也称为笔刷式高精度建模软件，顾名思义，就是像艺术家那样用不同的“笔
刷”工具在模型表面上进行“雕刻”的自由创作。建模过程就像玩橡皮泥一样，利用拉，捏，推，扭等操作来对几何
进行编辑，生成任意的高度复杂和丰富的几何细节（如怪兽的复杂表面细节）。这些工具的出现颠覆了过去传统三
维设计工具的工作模式，解放了艺术家们的双手和思维，告别过去那种依靠鼠标和参数来笨拙创作的模式，完全尊
重设计师的创作灵感和传统工作习惯。
 
1.       ZBrush
美国Pixologic公司开发的ZBrush软件是世界上第一个让艺术家感到无约束自由创作的3D设计工具。 ZBrush能够雕刻
高达 10 亿多边形的模型，所以说限制只取决于的艺术家自身的想象力。
 
2.       MudBox
MudBox是Autodesk公司的3D雕刻建模软件，它和ZBrush相比各有千秋。在某些人看来，MudBox的功能甚至超过了
ZBrush，可谓ZBrush的超级杀手。
 
3.       MeshMixer
最近，Autodesk公司又开发出一款笔刷式3D建模工具MeshMixer，它能让用户通过笔刷式的交互来融合现有的模型
来创建3D模型（似乎是类似与Poisson融合或Laplacian融合的技术），比如类似“牛头马面”的混合3D模型。
值得注
意的是，最新版本的
MeshMixer
还添加
3D
打印支撑优化新算法，值得关注。我们
Siggraph
 Asia 2013
的论文“
Cost-effe
ctive
 Printing of 3D Objects with Skin-Frame Structures
”也给出了一种为
3D
打印加尽可能少的支撑材料的新算法（详
见我的博文“
经济节约型的3D打印技术
”），该算法也是具有较好的市场前景，我们也在努力进行产业转化。
 
4.       其他
其他还有一些同类的3D雕刻建模软件，比如3DCoat，Sculptris，Modo等。这里就不再详细介绍了。
 
注1：在工业界，人们更偏向于使用四边形网格(quad
 mesh)，而不是三角网格，一个很重要的原因就是这些雕刻建模
工具善于在四边形网格上进行细节的生成和编辑，因为四边形网格的边更能反应物体表面的流线方向(edge
 flow)。我
们Pacific Graphics 2010的一篇论文B-mesh，就是在建模过程中同时生成具有良好流线方向的四边形基网格(base
 mesh)，
然后直接可以导入到这些雕刻软件中进行进一步的细节雕刻建模。
 
注2：虽然这些笔刷式建模工具上手容易，给了用户便利的方式进行3D细节建模，但是，要想真正构建一个细节复杂
和逼真的3D模型还是不容易的，除了用户需要熟练掌握软件的各种工具及雕刻技巧外，还需要用户具有较好的艺术和
绘画功底。
 
 
四、           基于草图的3D建模软件
 
基于笔划或草图的交互方式由于其符合人类原有日常生活中的思考习惯，交互方式直观简单（就像在图纸上画画
一样来构建3D模型），是最近十多年来计算机图形学中研究的热点建模方法之一。这方面的研究论文有很多，比
如Siggraph 1999年的Teddy，到Siggraph
 2006年的SmoothSketch，Graphics
 Interface 2007的Magic Canvas，Siggraph 
2007年的FiberMesh，SigCHI
 2010年的ICanDraw等。最近，我们也提出一种基于阴影引导的草图交互的3D建模的
技术“Modeling
 by Drawing with Shadow Guidance”，从已知的模型数据库中提取信息来引导用户的笔划交互，能构
建更为精准的3D模型，该工作发表在Pacific
 Graphics 2013上。
虽然在科研上提出了很多基于草图的
3D
建模技术，
但是至今仍未能有比较成熟的商业化的软件出现，可能是因为要理解不同用户的划线和草图还是一件比较困难的
事情。对于一些比较规则的物体，比如建筑、家具等人造物体，这种方式相对可行些，比如
Google
的
SketchUp
（在
国内我们也称为“草图大师”）。
SketchUp
是一套面向普通用户的易于使用的
3D
建模软件。使用
SketchUp
，创建
3D
模型就像我们使用铅笔在图纸上作图一般，软件能自动识别你画的这些线条，加以自动捕捉。它的建模流程简单
明了，就是画线成面，而后拉伸成体，这也是建筑或室内场景建模最常用的方法。
SketchUp
还可以将你自己的制
作成果发布到
Google
 Earth
上和其他人共享，或者是提交到
Google
的
3D
 Warehouse
（
Google
的
3D
模型库）。当然你
也能从
Warehouse
那儿得到想要的素材，以此作为创作的基础。很有趣的是，在
2012
年
Google
公司的
SketchUp
被美
国
Trimble
公司收购了。去年出了个
Trimble
 SketchUp 2013
，网评似乎不太好。不知其是否能继续免费。
最近国内出
了一款叫做“
EasyToy
”的采用草图式的
3D
建模软件，适用于卡通动漫形象与玩具的设计。但我还没有试用过，不知
用户体验如何。另外，日本东京大学的
Takeo
 Igarashi
教授也发布了一些基于草图式的
3D
建模系统，比如
Teddy
，在
其主页上可以下载到。
另外，值得一提的是，基于草图的交互方式在现在正在兴起的
Web3D
建模领域会有新的广阔
空间。
Web3D
建模在稍后会介绍。
 
 
五、           基于照片的3D建模软件
 
从物体的照片来进行3D模型的构建，是计算机图形学和计算机视觉的一大研究方向，称为基于图像的几何建模(Ima
ge based modeling)。这种技术已逐渐成熟且走向实用阶段，最近有些软件能够让用户拿着普通相机或者手机对着要
建模的实物从不同视角拍摄若干照片，然后软件就能根据这些照片自动地生成相应的3D模型。这种基于
图片的建
模技术提供给了非专业建模人士来构建
3D
模型的工具。
 
1.       Autodesk
 123D
Autodesk公司最近发布了一套平民级的建模软件Autodesk
 123D，用户不需复杂的专业知识，只要为物体从不同的
视角拍摄几张照片，该软件就能自动地为其生成3D模型，而且软件是完全免费的。
(1)    Autodesk
 123D是一款免费的3D CAD 工具，用户可以使用一些简单的图形来设计、创建、编辑三维模型，或者
在一个已有的模型上进行修改。
(2)    Autodesk
 123D Catch是建模软件的重点，用户使用相机或手机来从不同角度拍摄物体、人物或场景，然后上传
到云，然后该软件利用云计算的强大计算能力，可将数码照片中几分钟的时间内转换为3D模型，而且还自动带上
纹理信息。我们试用过几次，感觉它的使用还是很方便的。但是其生成的3D几何的细节不多，主要是通过纹理信
息来表现真实感的。有时软件也会失败，生成的几何是不正确的。
(3)    Autodesk
 123D Make是将3D模型转换为2D的切割图案，用户可利用硬纸板、木料、金属或塑料等低成本材料
将这些图案迅速拼装成实物，从而再现原来的数字化模型。这让用户能够“制造”出所造的3D模型，有点像3D打印
的雏形。目前123D Make只有Mac版的。
(4)    Autodesk
 123D Sculpt是一款运行在iPad上的3D雕刻软件（前面已介绍过），通过绘画的方式在模型上雕刻
几何细节。
 
2.       3DSOM
 Pro
3DSOM Pro是一款从高质量的照片来生成3D建模的软件，它可以通过一个真实物体的照片来进行3D建模，并且制
作的模型可以在网络上以交互的方式呈现。
 
3.       PhotoSynth
微软开发了一款产品PhotoSynth，可将大量的照片做3D处理，但是它不是真正创建3D模型，而是根据照片之间的
相机参数及空间对应关系，建构一个虚拟的3D场景，使得用户能够在从不同角度和位置来查看该场景，而显示的
场景图像是由给定的照片所合成的。其基本原理来自于Siggraph 2006的论文“Photo
 Tourism: exploring photo colle
ctions in
 3D”及其他相关论文。
 
注：从多幅不同角度拍摄的照片来重建3D物体，从技术原理上来讲是可行的，但是由于算法的一些步骤，比如图像
中物体特征点的检测和匹配，相机参数的估计等，还会出现不太正确的结果，使得重建结果有时不够稳定，甚至不
正确。随着技术和计算能力的不断发展，相信这些会逐步得到解决。到时，从照片来重建3D模型的技术可能是最为
方便的3D建模技术了，因为人人都有手机，随时都可以拍照上传到云端来构建3D模型。如果有了大数据库的支持，
从单张照片来构建3D模型也是可能的，可以参看我们的Siggraph
 2011的论文。
 
 
六、           其他3D建模软件
 
1.       人体建模软件
关于构建人体模型及动画，首推Metacreations公司的Poser软件（俗称“人物造型大师”）和开源的MakeHuman软件
。这两款软件都是基于大量人类学形态特征数据，可以快速形成不同年龄段的男女脸部及肢体模型，并对局部体
形进行调整。可以轻松快捷地设计人体造型、动作和动画。我读博期间用过Poser构建人体模型来做morphing，
还是蛮方便的。
 
2.       城市建模软件
加拿大Esri公司的CityEngine是三维城市建模的首选软件，可以利用二维数据快速创建三维场景，并能高效的进行
规划设计。应用于数字城市、城市规划、轨道交通、管线、建筑、游戏开发和电影制作等领域。另外，CityEngine
对ArcGIS的完美支持，使很多已有的基础GIS数据不需转换即可迅速实现三维建模，缩短了三维GIS系统的建设周
期。该软件的核心技术是Siggraph 2001的论文“Procedural
 Modeling of Cities”及其他相关论文，早期是ETH Zurich
大学的Pascal Mueller研究小组创办的Procedural公司开发的，后被Esri公司收购。
 
3.       其他小巧的3D建模软件
下面的这个网页还介绍了一些其他3D建模相关的软件或程序：
http://tech.sina.com.cn/s/2008-10-20/08192519895.shtml
这些软件大部分都非常小巧，而且是开源且完全免费的。有很多媒体工作者和艺术家用这些小软件来制作3D作品
，其中Blender, K-3D, Art of Illusion, Seamless3d,
 Wings3D等软件的使用面稍微广泛些。有兴趣的读者可以到网上找
到相关资料去了解和学习，这里不作详细介绍。
 
4.       网页3D
 (Web3D)建模工具
最近，出现了一些基于网页(web)开发的3D模型设计软件，即基于WebGL，可以在浏览器中完成3D建模的工具。
比如3DTin，TinkerCAD（去年被Autodesk收购）等，它们的界面简单直观，有Chrome等浏览器插件插件，可以在
线生成3D模型，直接存在云端，并在社区分享模型。
在互联网的时代，
Web3D
技术将被越来越被广泛使用，建议
大家多关注。
 
 
七、           虚拟现实软件和平台
 
虚拟现实软件本质上不是用于3D建模的，而是用来对生成好的3D模型和场景提供关于视觉、听觉、触觉等虚拟的
模拟，让用户如同身历其境一般。相关软件也有很多，这不是本文的重点，只大致提及几个比较常见的。
 
1.       VirTools和Quest3D
法国VirTools公司的VirTools和美国Act-3D公司的Quest3D都是元老级的虚拟现实制作软件，简单来说，就是工业
或游戏用的实时图形渲染引擎，是3D虚拟和互动技术的集成工具。可以让没有程序基础的美术人员利用内置的行
为模块快速制作出许多不同用途的3D产品，如网际网络、计算机游戏、多媒体、建筑设计、交互式电视、教育训
练、仿真与产品展示等 。网上的学习资料比较多。
 
2.       Unity3D
 (U3D)
Unity Technologies开发的Unity3D
 (U3D)是最近几年冒出来的新秀，是一个全面整合的专业虚拟3D和游戏引擎。
它在制作虚拟现实及3D游戏方面上手非常容易，操作简单，互动性好，有强大的地形渲染器。我们的学生使用
U3D可以很快地制作一个3D游戏，因此也强烈推荐大家学习使用。
 
3.       Vega
Vega是MultiGen-Paradigm公司开发的用于实时视觉模拟和虚拟现实应用的开发引擎，提供很多的C/C++语言的应
用程序接口API，结合其应用程序的图形用户GUI界面软件LynX，可以迅速创建各种实时交互的3D环境。对于开
发3D游戏和3D场景漫游的项目非常方便。
 
4.       OSG
 (Open Scene Graph)
OSG (Open Scene Graph)是一套开源的基于C++平台的应用程序接口API，能够让开发者快速、便捷地创建高性能
、跨平台的交互式图形程序。它将3D场景定义为空间中一系列连续的对象，能够对3D场景进行有效的管理。由于
OSG是开源和完全免费的，很多3D应用的软件都选用OSG作为基础架构。几年前，我们与一个公司合作开发的义
齿软件就选用OSG作为管理3D数据的框架，使得开发非常方便。
 
5.       其他
其他的一些用于3D应用程序开发的软件开发包(SDK)或API还有GLUT(OpenGL
 Utility Toolkit), OpenGL Performer, 
CG2 VTree, Quamtum3D Mantis等。有兴趣的读者也可以去了解一下。
 
注：相比于十年前，由于有了上述开发平台和开发包，现在开发一个看起来还比较cool的3D应用程序或游戏不是那么
困难，随着技术的不断发展和3D应用不断渗入到各行各业，相信以后会更加方便。
 
 
八、           开源3D网格处理库
 
1.       PCL
 (Point Cloud Library)
Point Cloud Library (PCL)是一个独立的大型跨平台的处理二维/三维图像和点云数据的C++模板库，它基于许多第三
方库，比如Boost、Eigen、FLANN、VTK、CUDA、OpenNI、Qhull等，实现了大量点云相关的通用算法和高效数
据结构，涉及到点云获取、滤波、分割、配准、检索、特征提取、识别、追踪、曲面重建（包括Poisson重建算法
）、可视化等。早期的PCL是由Dr.
 Radu Bogdan Rusu在德国慕尼黑工业大学读博士期间开发的，目的是要为三维
点云数据处理的研究及应用，建立出一个共同的基础架构。另外，PCL利用OpenMP、GPU、CUDA等先进高性能
计算技术，通过并行化提高程序实时性。集成了Kinect Fusion重建算法。有人将其地位比喻为3D的OpenCV，足以
可见其对3D的开发和研究的重要性，我们的学生在科研过程中经常用到PCL。
 
2.       CGAL
 (Computational Geometry Algorithms Library)
CGAL是一套开源的C++算法库，提供了计算几何相关的数据结构和算法，诸如三角剖分（2D约束三角剖分及二维
和三维Delaunay三角剖分），Voronoi图（二维和三维的点，2D加权Voronoi图，分割Voronoi图等），多边形，多
面体（布尔运算），网格生成（二维Delaunay网格生成和三维表面和体积网格生成等），几何处理（表面网格简
化，细分和参数化等），凸壳算法，搜索结构（近邻搜索，kd树等），插值，形状分析，拟合等。CGAL功能强
大，是我们学生做科研的必备程序库之一。
 
3.       MeshLab
MeshLab是一个开源的处理三角形网格的C++算法库，提供了三角网格的数据结构和算法，诸如曲面重建、编辑
、修复、光顺、编辑等算法。MeshLab也是我们学生做科研的必备程序库之一。
 
4.       其他开源网格处理库
OpenMesh：由德国RWTH
 Aachen大学的Leif Kobbelt研究小组开发的C++网格处理库
Libigl: 由瑞士Ethz大学的Olga
 Sorkine研究小组开发的C++网格处理库
Trimesh：有美国Princeton大学的Thomas
 Funkhouser研究小组开发的C++网格处理库
 
5.       网格剖分(Delaunay)与生成库
Triangle, NetGen：平面三角网格生成库
TetGen, Stellar：空间四面体网格生成库
 
注：这里列出了几个主要的网格处理的C++代码库，我们的学生在学习和科研的过程中会经常用到它们。当然，网上
还有其他的各种算法库，对我们的科研和开发都是非常有用，我们有时也会用到，这里就不再详述。
 
 
九、           基于扫描（逆向设计）的3D建模软件
 
随着深度相机的普及及扫描仪的价格迅速下降，人们采集三维数据变得容易，从采集到的三维点云来重建三维
模型的工作在最近几年的Siggraph(Asia)上能常见到，比如我们Siggraph
 Asia 2010，Siggraph
 2013等的工作。最近
几年产生了许多基于点云数据的建模与处理（或逆向工程和设计）的软件，而且各种扫描设备的生产厂商也会发
布相应的点云重建的软件。
 
1.       Geomagic
Geomagic (俗称“杰魔”) 包括系列软件Geomagic
 Studio、Geomagic Qualify和Geomagic
 Piano。其中Geomagic Studio
是被广泛使用的逆向工程软件，具有下述所有特点：确保完美无缺的多边形和 NURBS 模型处理复杂形状或自由
曲面形状时，生产效率比传统 CAD软件提高数倍；可与主要的三维扫描设备和CAD/CAM软件进行集成；能够作
为一个独立的应用程序运用于快速制造，或者作为对CAD软件的补充。是我们学生科研的必备软件之一。
 
2.       RapidForm
RapidForm是韩国INUS公司出品的逆向工程软件，提供了新一代运算模式，可实时将点云数据运算出无接缝的多
边形曲面，使它成为 3D扫描数据的最佳化的接口，是很多3D扫描仪的OEM软件。我们购买的Konica
 Minolta的激
光扫描仪Range 7就是用RapidForm来进行逆向设计。我们SGP
 2010的ARAP参数化算法作为目前为止最好的参数化
算法之一，被集成到了RapidForm软件中。
 
3.       ReconstructMe
ProFactor公司开发的ReconstructMe是一个功能强大且易于使用的三维重建软件，能够使用微软的Kinect或华硕的
Xtion进行实时3D场景扫描（核心算法是Kinect
 Fusion），几分钟就可以完成一张全彩3D场景。我们尝试过，效果
还可以。ReconstructMeQt提供了一个实时三维重建利用ReconstructMe
 SDK（开源）的图形用户界面。
 
注：法国ManCTL公司开发的Skanect为Mac平台的第一款3D 扫描软件，也支持者华硕的Xtion或者微软的Kinect进行
实时3D 扫描。
 
4.       Artec
 Studio
Artec公司出品的Artec
 Eva, Artec Spider等手持式的结构光3D扫描仪，重量轻且易于使用，成为许多3D体验馆扫描
物体的首选产品。我试用过Artec Eva后感觉还是需要较多的技巧才能扫描好物体，而且后期需要用软件进行较多
的处理，比如数据的去噪、修复、光滑、补洞等。
同时，
Artec
公司还开发了一款软件
Artec
 Studio
，可以和微软的
Kinect
或华硕的
 
Xtion
以及其他厂商的体感周边外设配合使用，使其成为三维扫描仪。
Kinect
通过
Artec
 Studio
可以
完成模型扫描，然后进行后期处理，填补漏洞、清理数据、进行测量、导出数据等。不确定它是否也使用了
Kinect 
Fusion
算法。
 
5.       PolyWorks
PolyWorks是加拿大InnovMetric公司开发的点云处理软件，提供工程和制造业3D测量解决方案，包含点云扫描、
尺寸分析与比较、CAD和逆向工程等功能。
 
注1：全球四大逆向工程软件除了Geomagic
 Studio和RapidForm外，还包括ImageWare和CopyCAD，由于后两者我不
熟悉，在此就不介绍了，有兴趣的读者可以到网上去找相关资料了解。
 
注2：微软的Kinect作为快速获取3D数据的传感器，可以作为3D扫描仪来使用，我们曾使用3台Kinects来扫描人体全
身，论文发在2012年的IEEE
 TVCG期刊。现在有多款软件或者开发库（包括上面介绍的PCL，ReconstrutMe，Artec
Studio，Skanect），支持将单台Kinect作为手持式扫描仪来扫描物体，其核心都是Kinect
 Fusion算法。
 
 
十、           后记
 
最近，随着人们对3D建模的需求越来越大，出现了许多其他形式的3D建模软件和工具，比如Blokify, 基于块状化
3D建模软件，特别适合孩子们制作模型。这些新出现的工具我这里就不一一介绍了，大家可以关注网上的一些科
技新闻网站、论坛或博客等。
 
 
1.       3D模型数据浏览与转换软件
上面介绍的大部分的软件或库都支持查看不同格式的3D模型数据。如果仅仅是浏览或查看现有的3D模型数据，我
个人推荐3D Exploration软件（相当于查看图像的ACDSee软件），它是一个专门用来查看各种格式的3D模型文件，
包括3DS数据 (*.3ds,
 *.prj, *.asc)、LightWave Objects (*.lwo,*.lw)、 DirectX(*.x)、AutoCAD
 (*.dxf)、Object File Fo
rmat (*.off)、Wavefront
 (*.obj)等，还可以用鼠标交互从不同视角来查看。而且还能查看各种图像文件，包括bmp
、rle、dib、gif、jpg、png、tif、tga、pcx等。当然也能查看带纹理的3D模型。3D
 Exploration是我的机器必装软件
之一，强烈推荐。另一个我推荐的同类软件是Deep Exploration，它除了可以浏览3D数据外，还可以转换数据格式
（最新版本还支持Sketchup文件），同时它还可以对你的模型进行编辑及添加注释制作动画等，我也强烈推荐。
注：现在有很多3D数据格式，几乎每个3D建模软件都会定义自己的数据格式。几种比较公认的3D数据格式有VR
ML、obj、off、stl
 (用于3D打印的数据格式)等。现在有些组织在力推3D数据的标准。相信随着3D技术的发展，这
些格式都将越来越标准化和统一化。对各种数据格式需要更多了解的，可以到网上找找，比如：
http://www.cnblogs.com/sunliming/archive/2012/02/28/2372398.html
 
 
2.       3D模型渲染软件
本文介绍的各种3D建模软件一般都能渲染3D模型，但要得到更为逼真的真实感渲染效果，还可以使用专门的3D
模型渲染软件，比如Pixar Renderman、POV-Ray、 V-Ray、 Mental
 Ray、Final-Render等，这里就不详细介绍。一
般我们使用Maya进行渲染放在论文中，已经足够漂亮了，读者可以在我们的许多论文中看到利用Maya渲染的结果
图。
 
3.       其他相关的软件
本文以介绍3D建模的软件和库为主，另外，还有许多跟3D技术相关的软件和开发包我没有提及，比如图像处理、
可视化、处理医学图像、建筑设计、装潢设计及艺术设计等。读者可以根据各自的专业去网上寻找所需要的专业
软件。
 
4.       学习使用3D建模软件
相比于2D平面软件Adobe
 Photoshop，Illustrator，CorelDraw等，学习3D软件难度稍大些，需要了解和掌握一些3D
的概念、3D交互习惯和技巧。因此，想要在短期熟练掌握好一个3D建模软件，是不太可能的，需要多用、多摸索
、多体会。网上有许多教材和视频，您可以跟着去学习。总之，您要多去玩，就能玩熟了。如果您能有个确定的
目标来学习3D软件，比如完成项目或者论文中所需要的效果，您就能掌握得更快！因为，带有确定目标和任务的
学习，是最高效的学习。但您如果暂时用不到，暂可不必花太多时间去学习，学了但不去用，也容易忘。只要您
学习软件的速度快就可以，而这正是我们对学生的基本要求。
 
5.       3D时代的来临
最近两年3D打印机的兴起，引起人们的极大好奇与广泛关注，同时也有些争论。虽然还不清楚它是否能成为人们
生活中不可或缺的一项技术，但不可否认，3D打印技术确实已经给世界带来巨变，已逐渐在某些领域表现出巨大
的价值，比如，提高了制造行业的生产力，在医学领域得到了广泛应用（义齿，假肢，器官等），为艺术家提供
了有效的创作工具等等。个人认为，3D打印提供给了平民零技能制造的技术，会朝着“私人定制”（个性化需求）
的方向发展；随着大量草根参与到3D的设计和制造，3D打印将逐步颠覆人们创造东西的能力。正因人们对3D模型
有了巨大的需求，3D打印技术才使得计算机图形学“落地”，这也使得我们这个学科终于在人们生活中体现了巨大
的价值。关于3D打印技术将给大规模工业经济带来的巨大冲击以及给我们的生活将带来的巨大变化，这里不展开
讨论，我将以后抽空撰文加以详述。
我们再来看一下这几年的一些巨头科技公司的变化，
2011
年微软公司的
Kinect
让人们获取
3D
数据的硬件代价降低了许多，
2012
年
3D
打印的兴起造就了两家上市公司
Stratasys
和
3D
 Systems
，
2013
年苹果公司收购了
Kinect
的核心技术公司
PrimeSense
，谷歌公司收购了大名鼎鼎的机器人公司
Boston
 Dynamics
，这
些都说明，越来越多的高科技企业在快速发展
3D
科技，
3D
时代已经来临！
随着人们对
3D
技术有了越来越多的需求，本文所介绍的
3D
建模工具将会发挥出更为巨大的价值。随着科学和技术的发展，云计算与物联网的进一步发展，将会出现越来越便利的
3D
建模工具，比如
Autodesk
 123D
正在将
3D
技术从专业变成非专业，人们接触
3D
技术的门槛将越来越低，创造的
3D
模型越来越丰富。我坚信，日后
3D
技术将“飞入寻常百姓家”，会越来越平民化，且成为人们生活中重要的一部分。
当然，当前人们对3D技术的了解还远远不够，大部分的人对3D技术仍然很陌生。另一个我个人看好的市场就是3D
教育与培训，普及3D技术与培养3D技术人才已时不我待。
另外，现在也开始有了一些
3D
模型共享的网站在运营，
能够提供给全世界的用户下载、上传、分享
3D
数据；类似于十多年随着
Internet
发展而产生的图像共享网站，这些
3D
数据共享网站也将在不久的未来产生巨大的价值，
3D
模型数据也将逐步进入“大数据时代”。
我们很庆幸成为
3D
科技新时代的弄潮儿，有很多的机会和挑战在等待着我们！让我们一起努力！
Python的强大除了其简单的语法以及易用性，还有其不得不说的海量的第三库的支持。
但是，我们电脑上由于需要可能安装了多个版本的Python，如Python2.X和Python3.X,这时候我们除了在电脑上要解决多个Python版本共存的问题，还需要针对不同的版本安装支持不同版本的第三方库，而且在安装第三方库的时候在cmd.exe上可能会出现输入字符错误，或者其他的错误，简而言之，就是没有交互式的界面，不能让人像傻瓜一样简单的安装第三方包，但是Pycharm这个强大的pythonIDE（集成开发环境）给我们提供了这种便利，以下就介绍如何使用Pycharm安装不同Python版本的第三方库。
1.打开Pycharm,我的Pycharm版本为Pycharm4.5.4


2.打开File菜单下的Setting菜单，如下






3.选择Settings下Project:Python下的Project Interpreter，并选择Python的版本，点右侧+号进入第三方库的搜索界面


4.在第三方包的搜索界面输入要安装的第三方包的名字，点击左下角Install Package按钮，后会提示安装成功




到这里，第三步就安装完成了，快去试一试新的库的强大功能吧！
VTK根据几个点插值成样条曲线，然后以样条曲线为中心线，生成圆柱体管道
这个问题简单但是又容易犯错，当代码出现错误的时候让人非常的懊恼；
比如有两个类：CleftView和CImplicitModelView两个类，现在有这样的需求需要在两个类中都调用对方的函数，所以就在CleftView.h中加上#include "CImplicitModelView"，在CImplicitModelView.h中加上#include "CleftView.h"，
但是当我们兴高采烈地的去编译时，会出现缺少分号的错误，但是当我检查了很久的代码，发现并没有出现缺少分号，这个原因是因为类与类之间的头文件互相包含所导致的。
解决方法就是：
在两个类的头文件中进行类先导声明，然后在各自类的.cpp文件中进行头文件的包含
例如：
(1)在CleftView.h中进行CImplicitModelView的类先导声明class CImplicitModelView;(有分号),然后在CleftView.cpp文件中包含CImplicitModelView类的头文件，#include"CImplicitModelView.h"
(2)在CImplicitModelView.h中进行CIeftView的类先导声明class CleftView;(有分号),然后在CImplicitModelView.cpp文件中包含CIeftView类的头文件，#include"CIeftView.h"
在CImplicitModelView.h中进行CIeftView的类先导声明class CleftView;(有分号),然后在CImplicitModelView.cpp文件中包含CIeftView类的头文件，#include"CIeftView.h"
CImplicitModelView
CImplicitModelView
这样，就可以实现在两个类中进行互访问
这样，就可以实现在两个类中进行互访问
问题描述：给定两个非空的链表，表示两个非负整数。 数字以相反的顺序存储，每个节点包含一个数字。 添加两个数字并将其作为链表返回。
测试代码：

在我们建立三维模型的过程中，当用多边形网格或者是三角面片来近似的表示曲面的表面时，曲面被离散成许多的平面多边形，如果我们的网格较大，离散度较粗，在模型表面使用明暗处理后，两两相邻的多边形会出现凸起或者是凹陷的折痕，在连接处显得比周围处亮或者暗，这就是所谓的马赫夫效应，如下图所示
针对于出现的马赫夫效应，我们需要进行明暗处理，消除或者是减少三维模型的马赫夫效应，使其看上去更加的光滑美观，常用的明暗处理技术有双线性光强插值—Gouraud明暗处理技术和双线性法向插值-Phong明暗处理技术。以下展示经过明暗处理前后结果对比
OpenGL提供了两种着色模式
void glShadeModel ( GLenum mode)，恒定着色
GL_FLAT，光滑着色GL_SMOOTH，而GL_SMOOTH中则是使用了Gouraud明暗处理技术，对于Phong明暗处理技术可以参见http://blog.csdn.net/dalewzm/article/details/46291397
http://blog.csdn.net/silangquan/article/details/10011169

Gouraud明暗处理算法在处理亮度的不连续性方面很有效，但是在明暗强度函数的斜率急剧变化处仍然可以看到马赫夫效应，不能完全消除光强度的不连续性。而Phong明暗处理是对表面的法向量而不是亮度进行插值，大大改善了Gouraud模型对高亮度镜面反射光的处理，在每一点都是用法向量的一个近似值，所以一般法向量插值的结果要优于亮度插值，在很大程度上消除了马赫夫效应，但是会大大增加明暗处理的时间。


鉴于此，我在用MC算法建立三维模型的时候，由于我的网格设置较大，导致出现了马赫夫效应，即模型表面的可视化效果不光滑，如下：



于是使用OpenGL自带的Gouraud明暗处理技术，以一个MC算法生成的章鱼模型为例子，效果如下
相比未使用明暗处理的模型，使用了Gouraud处理的模型从可视化的角度上来看更加的光滑，效果更好。




Python并不是我的主业，当初学Python主要是为了学爬虫，以为自己觉得能够从网上爬东西是一件非常神奇又是一件非常有用的事情，因为我们可以获取一些方面的数据或者其他的东西，反正各有用处。
这两天闲着没事，主要是让脑子放松一下就写着爬虫来玩，上一篇初略的使用BeautifulSoup去爬某个CSDN博客的基本统计信息（http://blog.csdn.net/hw140701/article/details/55048364），今天就想要不就直接根据某个CSDN博客的主页的地址爬取该博客的所有文章链接，进而提取每一篇文章中的元素，我这里是提取每一篇博客中的文字信息。
一、主要思路
通过分析CSDN博客的网站源码，我们发现当我们输入某博客主页网址时，如：http://blog.csdn.net/hw140701
在主页会有多篇文章，以及文章的链接，默认的是15篇。在主页博客的底部会有分页的链接，如下图


如图所示，一共65篇分5页，每一页中又包含了15篇文章的链接。
所以我们总体的思路是：
1.输入博客主页地址，先获取当前页所有文章的链接；
2.获取每个分页的链接地址
3.通过每个分页的链接地址获取每一个分页上所有文章的链接地址
4.根据每一篇文章的链接地址，获取每一篇文章的内容，直到该博客所有文章都爬取完毕


二、代码分析
2.1分页链接源码分析
用浏览器打开网页地址，使用开发者工具查看博客主页网站源码，发现分页链接地址隐藏在下列标签之中


所以我们通过下列代码所有分页链接进行匹配



2.2分页上每一篇文章链接源码分析
得到每一个分页的链接后，对每一个分页上的文章链接源码进行分析，其源码如下


通过分析，所以我们采取以下的方法进行匹配


通过对每一篇文章中的网站源码进行分析，发现其内容位于源码中的以下位置


所以通过下列代码进行匹配

现附上全部代码，注释部分可能有错，可以根据此代码自行修改，去爬取某CSDN博客中的任意元素

先说说题外话，OpenGL是一个跨平台优秀的三维可视化库，而在Windows中内部封装的OpenGL还是1.1版本，不吐槽，维护自身Direct3D的发展也是情有可原。如果你是Win32系统，编译环境也是Win32的话，对OpenGL只是练习，那么就用简单的GLUT来配置OpenGL环境就好了，但是如果你想用X64(64位)环境来编译的话，这个GLUT会编译不成功，因为它不提供64位下的使用环境，而且太老掉牙了，版本已经不更新了，那么这个时候你就需要freeglut这个包(国外推荐使用freeglut，摒弃glut),这个包提供了32位(x86)和64(x64)两种编译环境下可用的静态链接库和动态链接库。关于64位环境编译的程序与32环境编译的程序之间的区别就是32位程序在系统中最多能申请到2G内存（2的32次方字节），而64位程序在系统中最多能申请到（2的64次方字节）的内存，64位程序理论上可以使用当前PC机上所装载的全部的内存，极大的提高了程序的性能。下面介绍了Glut和FreeGlut的详细配置教程，以便在32位编译环境和64位编译环境都得心应手的使用OpenGL。
*我的VS2010的安装位置：D:\Program Files (x86)\Microsoft Visual Studio 10.0
1.关于Glut的配置
1.1. 下载GLUT。Windows环境下的GLUT下载地址：
http://www.opengl.org/resources/libraries/glut/glutdlls37beta.zip



1.2
1.3 
1.4 
1.5 

2.Freeglut的配置




我使用的环境具体是Win764位+VS2010+Freeglut2.8.1,而Freeglut2.8.1这个版本支持VS2010,可使用最高的版本3.0，同样支持各种VS版本。


2.1 Freeglut的下载
Freeglut2.8.1:http://download.csdn.net/detail/hw140701/9830604
Freeglut其他版本的下载地址：
Freeglut3.0版本：
http://www.transmissionzero.co.uk/software/freeglut-devel/

http://download.csdn.net/detail/hw140701/9830606



2.2 生成VS2010 64位编译环境下下可用的Freeglut的包含头文件，静态链接库lib,动态链接库dll。
解压缩包，打开解压后的压缩文件夹，里面会有一个VisualStduio的文件夹，如下


    打开VisualStudio文件夹，里面会有VS2008，VS2010，VS2012三个版本的


    选择VS2010，打开项目文件freeglut.sln。


    选择Release版本，x64平台编译，右键解决方案，点击全部生成


然后你会在解压的文件夹下发现两个新的文件夹inclue和lib文件夹




include文件夹下会有GL文件夹，里面包含了freeglut所需用到的头文件，freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h,注意这里的glut.h与Glut包的glut.h文件不相同。
lib文件夹下会有一个x64文件夹，里面包含了freeglut.lib和freeglut.dll文件。
2.3 具体配置
 Freeglut配置本质上与Glut的配置原理相同，不过，我们这里配置的是64位的freeglut，稍微有一些不同。这里也简单介绍一下freeglut32位的配置，如果你要生成freeglut32可用的包含文件，静态链接库以及动态链接库，请参见上节中64的生成方法，不要需要将编译平台改为Win32，此节不再赘述。
1.将\freeglut-2.8.1\freeglut-2.8.1\include\GL文件夹下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2.将freeglut.lib复制到D:\ProgramFiles (x86)\Microsoft Visual Studio 10.0\VC\lib下。
    3.将freeglut.dll复制到C:\Windows\System32下
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\SysWOW64下。
    1.将\freeglut-2.8.1\freeglut-2.8.1\include\GL文件夹下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2.将freeglut.lib复制到D:\ProgramFiles (x86)\Microsoft Visual Studio 10.0\VC\lib\amd64下，注意这里是放64位静态链接库的地方。
    3.将freeglut.dll复制到C:\Windows\SysWOW64下
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\ System32下。
 
最后在使用的时候只需添加#include<GL/freeglut.h>就可以了。
2.4 Freeglut3.0的配置
    类似于Freeglut2.8.1的配置
下载网址就是
http://www.transmissionzero.co.uk/software/freeglut-devel/
选择freeglut3.0.0 MSVC Package




解压缩文件，有include,bin,lib三个文件夹
2.4.1 Freeglut3.0 32位的配置
    1.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\include\GL下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\lib下的
freeglut.lib复制到D:\Program Files (x86)\Microsoft Visual Studio10.0\VC\lib。
    3.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\bin下的
freeglut.dll复制到C:\Windows\System32下。
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\SysWOW64下。
 
2.4.2 Freeglut3.0 64位配置
    1.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\include\GL下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2. \freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\lib\x64下的
freeglut.lib复制到D:\Program Files (x86)\Microsoft Visual Studio10.0\VC\lib\amd64下。
    3. \freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\bin\x64下的
freeglut.dll复制到C:\Windows\ SysWOW64下
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\ System32下。




3.Glew的配置
3.1 Glew的下载
http://www.cnblogs.com/Akunwjy/p/Freeglut.html













显示文件夹窗口默认显示效果：


加上语句bi.ulFlags=BIF_BROWSEINCLUDEFILES;后不仅可以显示文件夹，还可以显示文件：

加上语句bi.ulFlags=BIF_BROWSEINCLUDEFILES;后不仅可以显示文件夹，还可以显示文件：




加上语句bi.ulFlags=BIF_NEWDIALOGSTYLE;后窗口可以调整大小，并有新建文件夹按钮：

加上语句bi.ulFlags=BIF_NEWDIALOGSTYLE;后窗口可以调整大小，并有新建文件夹按钮：

加上语句bi.ulFlags=BIF_NEWDIALOGSTYLE;后窗口可以调整大小，并有新建文件夹按钮：






加上语句bi.lpszTitle=L"指定要处理的文件夹";
 后在窗口内显示提示用户的语句：

加上语句bi.lpszTitle=L"指定要处理的文件夹";
 后在窗口内显示提示用户的语句：

加上语句bi.lpszTitle=L"指定要处理的文件夹";
 后在窗口内显示提示用户的语句：

加上语句bi.lpszTitle=L"指定要处理的文件夹";
 后在窗口内显示提示用户的语句：








easysize.h自行在CSDN下载频道进行下载。
步骤一：把easysize.h拷贝到CMyDlg项目文件夹中，同时在CMyDlg的.h文件和.cpp文件中加入#include "easysize.h"；
步骤二：在CMyDlg类的h文件中，加入DECLARE_EASYSIZE，注意结尾处不要加“；”。
步骤三：在CMyDlg类的OnInitDialog()函数的结尾处加入INIT_EASYSIZE, 注意此处结尾处要加“；”。
步骤四：增加WM_SIZE消息响应函数OnSize()，在函数中加入UPDATE_EASYSIZE，注意此处结尾处要加“；”。
步骤五：在CMyDlg的cpp文件中添加EASYSIZE 的宏映射
EASYSIZE(control,left,top,right,bottom,options)
Control---控件的ID，需要设置的控件
left top right bottom---矩形框的位置，可以设置的参数：ES_BORDER、ES_KEEPSIZE、其他control的ID。
        ES_BORDER代表控件与边框的距离保持不变
        ES_KEEPSIZE代表控件的宽度和高度保持不变，left/right只能设置其中一个为ES_KEEPSIZE,top/bottom亦然。
Control  ID代表以另一个空间为参照
        具体注释如下，待设置控件记为ID1，参照控件记为ID2
        i left=ID2  ID1左边到ID2右边的距离保持不变（不管ID2如何变化）
        ii right=ID2 ID1右边到ID2左边的距离保持不变（不管ID2如何变化）
iii top=ID2  ID1上边到ID2下边的距离保持不变（不管ID2如何变化）
iv bottom=ID2 ID1下边到ID2上边的距离保持不变（不管ID2如何变化）
options---特别操作ES_HCENTER, ES_VCENTER and 0的结合。
0代表没有任何操作；
ES_HCENTER代表控件在left/right之间水平居中，此时left/right都不能设置成ES_KEEPSIZE，控件的宽度保持不变；
ES_VCENTER同理ES_HCENTER
注意： 布局风格的设置将很大程序影响控件在对话框上的布局，不同设置布局会有天壤之别！！！！


由于有这个需求，就是当在对话框设置一些数值的时候，可以在对话框上预览三维图像。
（1）生成一个基于对话框的程序，或者直接在单文档或者多文档上插入一个对话框，生成一个新的对话框类CGridingDlg,名字可以任取。
（2）配置好工程的OpenGL环境，不知道可以百度。
（3）在CGridingDlg的头文件中添加以下变量:
CGridingDlg的头文件中添加以下变量:






(4)重载对话框类CGridingDlg的虚函数OnInitDialog(),添加WM_TIMER消息，
(4)重载对话框类CGridingDlg的虚函数OnInitDialog(),添加WM_TIMER消息，
CGridingDlg的虚函数OnInitDialog(),添加WM_TIMER消息，
添加函数SetupPixelFormat(HDC hDC)---->用于设置OpenGL的像素格式
添加函数SetupPixelFormat(HDC hDC)---->用于设置OpenGL的像素格式
添加函数SetupPixelFormat(HDC hDC)---->用于设置OpenGL的像素格式



在对话框上面添加一个Picture控件，用于显示图形，设置其ID为IDC_STATIC_PictureRender
在对话框上面添加一个Picture控件，用于显示图形，设置其ID为IDC_STATIC_PictureRender
在对话框上面添加一个Picture控件，用于显示图形，设置其ID为IDC_STATIC_PictureRender






添加InitializeOpenGL()函数用于在对话框中初始化OpenGL。
添加InitializeOpenGL()函数用于在对话框中初始化OpenGL。
添加InitializeOpenGL()函数用于在对话框中初始化OpenGL。















RenderScene()函数添加进去，每隔多少毫秒就调用RenderScene()，时间间隔设置的越少就可以形成连续绘制的效果
RenderScene()，时间间隔设置的越少就可以形成连续绘制的效果






RenderScene()函数中封装一个函数，将该函数放置于RenderScene()函数的绘图代码区就好了。
RenderScene()函数的绘图代码区就好了。
绘制的效果如下
绘制的效果如下
绘制的效果如下
绘制的效果如下
绘制的效果如下




















但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。


























































































问题描述：判断一个数是不是回文数。
回文数：就是从左往右念和从右往左念都是一样的，对称的一个数，如121,789987等。
注意：负数不是回文数，如-121。
解题思路一：如果一个数倒序输出后还等于原始的值，那么该数为回文数。
解题思路2：如果一个数最左边的数等于最右边的数，然后再去除这两个数，然后再判断最左边的数依然等于最右边的数，直到最后一个数，那么该数为回文数。


在leetcode里面提交的结果是第一种方法貌似比第二种要快。
配置步骤
1.在pycharm编译其中按上一篇文章简单粗暴：使用pycharm安装对应的Python版本第三方包，在包的搜索窗口输入Selenium，然后点击Install Package即可。




2.下载最新版本的Chrome浏览器安装


3.下载最新版本ChromeDrive.exe
可进入以下网址进行下载
http://chromedriver.storage.googleapis.com/index.html

下载下来为一个压缩包文件，解压缩，得到chromedrive.exe
chromedrive.exe


4.将下载的最新版本的chromedrive.exe拷贝到你的python3.x的安装目录，或者是C:Windows目录下
整个Selenium+Chrome的环境配置就完成了
我的python3.x安装路劲为：C:\Users\Administrator\AppData\Local\Programs\Python\Python35\




到这里整个Selenium+Chrome环境配置就完成了，快使用下列代码打开你的浏览器吧

5.上面代码每次都会打开一次Chrome浏览器，但是假如我们循环次数较多时，每次都打开一次浏览器会干扰我们在桌面上的其他工作，所以这里介绍一个无界面的浏览器包PhantomJS
首先在官网下载地址：http://phantomjs.org/download.html
或者CSDN下载频道以往版本：http://download.csdn.net/detail/tylanbin/7211747
然后得到压缩包，解压，将里面的PhantomJS.exe文件复制到你的python安装路径或者C:windows下，只要是系统的环境path目录都行
PhantomJS.exe文件复制到你的python安装路径或者C:windows下，只要是系统的环境path目录都行
然后只需要把上面driver=webdriver.Chrome()改成driver=webdriver.PhantomJS()即可


driver=webdriver.PhantomJS()即可
PhantomJS


最近在项目中有一种结构体数据需要存储，数据结构体如下

现在需要根据在m_Vector中的每一个结构体的ID来获得其对应的pinwei值，所以就写了一个函数，如下
然后上程序上面测试，对于一个size大约15000的容器，大概每次循环需要进行20次FindpinweiValueInVector（）函数的调用，所以在Vector中查找值的最坏的情况是时间复杂度为O(n),即进行15000*20，这还是每次的循环，当一个菜单执行完毕整整花了大概6个半小时左右，程序运行效率低下。


所以，必须要有一种查找效率较高的容器，就想到的map,map为平衡二叉树，查找效率为对数级别，时间复杂度为O(logN)，查找相对来说较快，1000大小的数据最坏只需要3次就可以查找到，15000只需要4次多就可以查找到。
所以声明一个map<int,double>型的容器，用于建立mystruct的ID与pinwei之间的对应关系，然后将Vector存储的值插入到map中，然后在map中根据键值（ID）查找Value(pinwei)。
函数如下



总结：以前在项目中用惯了STL的Vector，因为其比数组来的方便，不需要定义数组长度，可以不断的pushback(),但是其在大数据量中的查找效率简直令人发指，所以以后在什么时候得根据特定的情况使用特定的容器，不要习惯性的使用Vector。
后来又测试了下，用hash_map更快。


1.OpenMP介绍
OpenMP 是 Open MultiProcessing 的缩写，用于共享内存并行系统的多处理器程序设计的一套指导性编译处理方案。在项目程序已经完成好的情况下不需要大幅度的修改源代码，只需要加上专用的pragma来指明自己的意图，由此编译器可以自动将程序进行并行化，并在必要之处加入同步互斥以及通信。当选择忽略这些pragma，或者编译器不支持OpenMp时，程序又可退化为通常的程序(一般为串行)，代码仍然可以正常运作，只是不能利用多线程来加速程序执行。OpenMP提供的这种对于并行描述的高层抽象降低了并行编程的难度和复杂度，这样程序员可以把更多的精力投入到并行算法本身，而非其具体实现细节。对基于数据分集的多线程程序设计，OpenMP是一个很好的选择。



2.VS2010中开启OpenMP
右键项目属性-配置属性-C/C++-语言-OpenMP支持-点击是。






3. OpenMP并行化测试
在已有源代码的基础上，要对此段代码进行并行化处理，只需要使用

程序结果




当我们修改为8个线程的时候，其结果为




可以看出4个线程和8个线程都执行了cout << "Thread  " << omp_get_thread_num() << endl; //omp_get_thread_num()是获取当前线程id号这句代码，而且先后顺序没有特定的从线程1到线程2执行，可以看出简单的实现了并行块的设计。


下面以一个较大的for循环来测试OpenMP并行程序与普通串行程序的速度问题。
需要对for程序代码段执行并行化需要添加#pragma omp parallel for
串行化程序：





并行化程序：










1.error c3861:"_T:找不到标识符"
2.error C2664: “CreateFileW”: 不能将参数 1 从“const char [19]”转换为“LPCWSTR”
3.error C3861: “setprecision”: 找不到标识符
4. error C2501: 'vector' : missing storage-class or type specifiers
5.VS2010提示资源已在另一编辑器中打开
6.VS中出现error C2665:“AfxMessageBox”:
 2 个重载中没有一个可以转换所有参数类型
选择“项目”菜单->项目属性->配置属性->常规->字符集，改为“未设置”即可。
7.
无法解析的外部符号"public:__thiscall cv::SURF::SURF(void)" (??0SURF@cv@@QAE@XZ)，该符号在函数main 中被引用
无法解析的外部符号"public:__thiscall cv::SURF::SURF(double,int,int,bool,bool)"(??0SURF@cv@@QAE@NHH_N0@Z)，该符号在函数main
 中被引用
解决方法：
（1）添加#include"opencv2/nonfree/features2d.hpp"头文件
（2）用VS2010的话就在通用属性->连接器->输入->附加依赖项里边添加上库文件opencv_nonfree249d.lib这里最后的249具体可能根据你的版本变化，为你当前opencv版本，d字母表示debug，也可去掉，表示Release。


8.error
 RC2170: bitmap file res\XXX.bmp is not in 3.00 format

9.
去除VS2010对汉字的拼写检查后留下的红色波浪线
VAssistX菜单栏->Visual Assist X Options->Underlines->把underlines spelling errors in comments and strings using前面的勾去掉就行


10.

在程序开发中我们经常看见有一些软件左侧有目录树或者是图层树，点击之后就可以右侧View窗口显示相关的内容，其实实现这种机制有两种方法，第一种就是对MFC的View窗口进行窗口分割，左侧的窗口view类派生于CTreeView，其中CTreeView自带一个变量用于View中的树控件的控制。第二种方法就是用一个可停靠的面板嵌套一个对话框，再在对话框中添加树控件，同样可以达到相同的目的。
以下详解搭建步骤：
第一步：在VS2010中生成一个MFC经典风格的单文档程序，命名为CMyTestMFCDlg，编译下保证没有出错。

第二步：为该工程添加一个新类CMyDockablePane，派生于CDockablePane。



第三步：新建上述类完成后，在CMainFrame头文件中包含该类的头文件#include
 "MyDockablePane.h"
   声明该类的对象：



编译运行：


第四步：插入一个新的对话框，命名为IDD_DIALOG_DOCKDIALOG，在对话框属性中将Style设为Child，Border设为None。
为该对话框新建类：CDockDialog，基类为CDialogEx。
添加一个树控件，IDC_TREE_Test，为树控件关联一个控件变量m_TreeControl
在MyDockablePane.h中包含头文件#include
 "DockDialog.h"
添加CDockDialog
 类的成员变量：CDockDialog m_TestDlg;
添加CMyDockablePane的WM_CREATE和WM_SIZE消息响应函数
在函数中添加以下代码

CDockDialog类中重载虚函数OnInitDialog()，添加以下代码初始化树控件

CDockDialog头文件中添加#include "resource.h"




最后即可编译成功
最后即可编译成功






医学raw文件下载地址（自己的下载频道）:1:http://download.csdn.net/detail/hw140701/9832153
2:http://download.csdn.net/detail/hw140701/9832151
没有积分的可私信我。
VS2010-MFC在状态栏上添加进度条比在VC6.0中更加简单，不需要再从CStatusBar类中派生子类。
仔细查看VS2010生成的MainFrm.h文件我们可以看出，m_wndStatusBar已经是CMFCStatusBar的对象了，而不是CStatusBar对象。
CStatusBar对象。
所以就去微软的官网查看CMFCStatusBar的帮助文档，有中文，太好了
CMFCStatusBar的帮助文档，有中文，太好了
微软提供的MFC的帮助文档，有中文

微软提供的MFC的帮助文档，有中文

CMFCStatusBar类的帮助文档
此类自带进度条，只需要调用就可以了






以下为如何在VS2010单文档程序中在进度栏上添加进度条
步骤1:如上图所示，将m_wndStatusBar从protected型变量改成public型变量；
m_wndStatusBar从protected型变量改成public型变量；
步骤2：在MainFrm.cpp中添加进度条的标识IDS_PROGRESS
步骤2：在MainFrm.cpp中添加进度条的标识IDS_PROGRESS




并在资源文件字符串表String Table中新增一个字符串IDS_PROGRESS，如下图
并在资源文件字符串表String Table中新增一个字符串IDS_PROGRESS，如下图








步骤3：在CMainFrame的OnCreate()函数中添加以下代码，用于初试化状态栏
步骤3：在CMainFrame的OnCreate()函数中添加以下代码，用于初试化状态栏




步骤4：在View中某个读取文件的响应函数，添加以下代码，即可在状态栏显示文件加载进度条，以及当前文件大小和百分比信息




当我们点击读取文件后，文件总长度可以通过FILE类的Ftell函数进行获取，然后就可以在状态栏查看当前文档的加载进度以及已经加载文件的大小




整个编写流程就完成了，比VC 里面简单太多了。
使用VTK生成分布在球内部或者表面的三维点云数据，可以设置球的中心，半径以及生成的三维点的个数并选择可以设置在球内部生成或者是球表面生成。

在原先的博客VTK读取一个TXT文档中的三维点坐标绘制三维点云基础上，有小伙伴询问是否可以以点云中每一个三维点的坐标为中心绘制一个小的球体，用于标识特征点，这种就让我想到了化学里面的分子结构，所以就在原有博客的基础上进行了改写，实现了点云不是以点的方式而是以小球体形式显示出来，实现了大量球体的同时绘制。
不多说直接贴代码：

整体图：




局部的线框显示细节图：




局部表面显示细节图：


LeetCode第一题：
问题描述：给定一个整形的数组，在给定一个特定的整数值，要求返回这个整形数组中两个元素的和等于给定的整数的元素索引。
STL容器vector是新手入门STL最常用也是最好用的容器类，其不像array需要固定大小，而是可以动态的在容器尾部或者是中间插入元素，相当的好用，但是我们往往会在一个程序中向vector中压入了很多的元素，在使用完vector中的元素之后，只是会用clear去清理vector中的元素，有些小伙伴认为清空容器就等于释放了内存，其实真正的是这样的吗？我们不妨来做一个测试。
首先我们声明一个double型的容器，往里面压入了10000000个元素，然后用clear方法，看是否能真正的释放掉vector所占的内存，这里用SDK中的 GetProcessMemoryInfo方法来获取当前进程的所占用的内存。
代码如下：

程序运行结果：




我们可以看到使用clear方法虽然清空了vector中的元素，但是并没有释放掉vector所占用的内存，高效的管理内存是程序设计所要求的，C++ 11有了一个全新的shrink_to_fit()方法，该方法与clear()搭配使用，将vector所占用大小缩小到合适的范围，以下进行测试
代码如下：






我们可以看到，使用shrink_to_fit方法可以快速的释放掉vector所占用的内存。
MFC的界面太丑了，但是学会之后写一写简单的可交互的PC端程序还是可以的，但是用VS2010自己生成的MFC工程上的控件程序还是MFC经典风格，实在是看不下去，如下




要使其按钮带有Win7风格，带有Aero的美化效果，就需要在MFC工程的头文件Stdafx.h文件中，加入以下代码








但是如果想要有更加好的效果，还是自绘吧。
1.SkinMag MFC美化界面库
总所周知，MFC的皮肤比较呆板，有各种各样的MFC界面库可以供我们使用，来修改程序的外观。C++界面库可以参见：http://blog.csdn.net/witch_soya/article/details/10982451
在这里介绍一种配置比较简单的MFC界面库SkinMagic。
可从这里下载SkinMagic2.4破解版：http://download.csdn.net/download/wbxyzwh/9693071
下载解压后，文件夹文件如下：
2.SkinMagic在VS2010 MFC程序中的配置
2.1文件拷贝
将下列三个文件以及所有的*.smf皮肤文件拷贝至建立的MFC工程文件目录下




2.2
在stdafx.h中加入头文件和库的引用，如下：



皮肤的调用有两种方法，一是直接从皮肤文件中调用，另一种方法是从资源文件中调用，分别说明如下：




在CxxxApp::InitInstance()中的加入以下代码如下：

2.5 将皮肤应用到程序上
3. SkinMagic界面库各个皮肤效果
一个基于指针和重载操作符的数组类设计Array,可以进行数组范围检查，与平常看到的类而言，这个类的编写让人感觉逻辑十分清晰，以及更加可以理解面向对象程序设计理念。
Arry.h




更新于2017年7月7日：刚刚有网友说为什么将照片大小设置为500*500或者是更大的尺寸就不可以了，因为随着静态数据的增加所需要的堆栈保留大小就会增加，而VS中默认保留的是1M，所以程序尚未运行就会出现堆栈溢出错误，解决方法参考一下以下的博文：VS2010运行错误：0x010e86c7
 处有未经处理的异常: 0xC00000FD: Stack overflow - yangliuqing19的博客 - CSDN博客  http://blog.csdn.net/yangliuqing19/article/details/51568731点击打开链接
主要用到OpenCV自带的CascadeClassifier这个类下的detectMultiScale函数，其检测效果并不是很好
    

（1）静态图片上的人脸检测





可以看出，有些人脸没有检测出来，或者是检测出来有位置错误。
（2）摄像头人脸检测

（1）用Windows画图工具将图片另存为.bmp图片，现在测试支持16色图片，24色图片可以支持，256色未测试。
1、把你的图包含到程序的“Bitmap资源”里，提示说该资源使用了大于256色的调色板，在VC里无法编辑等等，点确定就可以 
2、定位到   void CXXXDlg::On
Paint()，在if()...else()中的else()下添加如下代码   
   else   
   {   
           //CDialog::On
Paint();//要禁止这个调用  
 或则放到最后 
           CPaintDC   dc(this);   
           CRect   rect;   
           GetClientRect(&rect);   
           CDC   dcMem;   
           dcMem.CreateCompatibleDC(&dc);   
           CBitmap   bmpBackground;   
           bmpBackground.LoadBitmap(IDB_BITMAP);   
                   //IDB_BITMAP是你自己的图对应的ID   
           BITMAP   bitmap;   
           bmpBackground.GetBitmap(&bitmap);   
           CBitmap   *pbmpOld=dcMem.SelectObject(&bmpBackground);   
           dc.StretchBlt(0,0,rect.Width(),rect.Height(),&dcMem,0,0,   
         bitmap.bmWidth,bitmap.bmHeight,SRCCOPY);   
   }
（2）在对话框上增加一个按钮ID_Button1,以及一个编辑框控件ID_Editpoints，为编辑框控件添加一个成员变量，m_Editpoints,实现按下按钮ID_Button1,就可以打开文本文件，并将文本文件的内容显示到编辑框中。
在OnButton1（）添加如下的代码：
       void CBitmap_DLgDlg::OnButton1() 
{
// TODO: Add your control notification handler code here
    //CColorDialog dlg;
//dlg.DoModal();
CString filter;
filter="文本文件(*txt)|*.txt|GoCAD文件(*.pl,*.ts)|*.pl;*.ts||";
CFileDialog dlg (TRUE,NULL,NULL,OFN_HIDEREADONLY,filter);
if (IDOK==dlg.DoModal())
{
    CString s;
s=dlg.GetPathName();
AfxMessageBox(s);
CFile file(s,CFile::modeRead);
char *pBuff;
DWORD dwFileLen;
dwFileLen=file.GetLength();
pBuff=new char[dwFileLen+1];
pBuff[dwFileLen]=0;
file.Read(pBuff,dwFileLen);
file.Close();
UpdateData();
m_Editpoints=pBuff;
UpdateData(false);
}



参考书籍：数据结构（C++版）陈宝平主编
参考链接：http://www.cnblogs.com/charley_yang/archive/2010/12/08/1900256.html
二叉树类封装以及代码

最近有小伙伴在问，我想显示一个求得的三维点云中的每一个点的法向量的指向，怎么获得这种逼真的三维显示效果呢？当然是OpenGL啦，也是我自己用的比较习惯，所以就花了十几分钟帮助上面提问的小伙伴解决问题，然后也提供给大家一个查看三维点云法向量的工具，稍后我会在我的ＣＳＤＮ的下载频道上传该软件的Ｒｅｌｅａｓｅ版本供大家使用，主要的显示效果是三维点云中的每一个点使用实心球体表示，法向量用一个方向箭头和圆锥体表示，类似于坐标轴的指向。主要用到三个函数，Render3DCylinder（在任意两个三维点间画圆柱体），Render3DSphere（以任意三维点为中心画球体），Render3DCone（在任意两个三维点之间画圆锥体）。
其三个函数的主要代码如下：






整个程序的源码由于项目的关系不能给出，只能给出发布版本，不过主要的核心的功能是利用上述的三个函数实现的。相应的程序的Realease版本的下载地址：[免费]OpenGL+MFC显示三维点云中每一个点的法向量，Release版本-CSDN下载  http://download.csdn.net/download/hw140701/9970732http://download.csdn.net/download/hw140701/9970732



1.新建一个编辑框控件（Edit Control）,将其多行（Multiline）前面打勾（属性设置为True）,Auto HScroll（自动水平滚动）前面的勾去掉（属性设置False）,这样就可以实现每一行填满后自动换行了。
2.再将垂直滚动条（Vetrical Scroll）前面打勾（属性设置为True），自动垂直滚动打钩，设置成true，当输入或显示超过编辑框的大小后就会出现垂直滚动条。
3.如果是输入，滚动条会自动移动跟随到当前输入行，但是如果是设置将很多内容一次性让编辑框显示，滚动条就会一直处于最上方，需要手动拉到最下面才能看见最后一行的内容，在很多时候这是我们不需要的，而是想要滚动条处于最下方，如下的代码将实现这一功能：
this->SetDlgItemText(IDC_EDIT_RECV,str);//将字符串str中内容显示到ID为IDC_EDIT_RECV的编辑框
m_recvshw.LineScroll(m_recvshw.GetLineCount());//m_recvshw为该编辑框的成员变量（也就是control类型的变量）
//使用控件变量的一些成员函数设置滚动条的位置




这两天有个筒子叫我帮他爬这个网站http://bbs.baobeihuijia.com/forum-191-1.html上的失踪儿童信息，准备根据失踪儿童的失踪时的地理位置来更好的寻找失踪儿童，这种事情本就应该义不容辞,如果对网站服务器造成负荷，还请谅解。


这次依然是用第三方爬虫包BeautifulSoup，还有Selenium+Chrome，Selenium+PhantomJS来爬取信息。
通过分析网站的框架，依然分三步来进行。
第一步：获取http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接
http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接
第二步：获取每一个分页链接上所发的帖子的链接
第二步：获取每一个分页链接上所发的帖子的链接
第三步：获取每一个帖子链接上要爬取的信息，编号，姓名，性别，出生日期，失踪时身高，失踪时间，失踪地点，以及是否报案
第三步：获取每一个帖子链接上要爬取的信息，编号，姓名，性别，出生日期，失踪时身高，失踪时间，失踪地点，以及是否报案
起先用的BeautifulSoup，但是被管理员设置了网站重定向，然后就采用selenium的方式，在这里还是对网站管理员说一声抱歉。
1、获取http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接
获取
http://bbs.baobeihuijia.com/forum-191-1.html这个版块上的所有分页页面链接




通过分析：发现分页的页面链接处于<div class="pg">下，所以写了以下的代码
通过分析：发现分页的页面链接处于<div class="pg">下，所以写了以下的代码
BeautifulSoup形式：


2.获取每一个分页链接上所发的帖子的链接
2.获取每一个分页链接上所发的帖子的链接
获取每一个分页链接上所发的帖子的链接






每个帖子的链接都位于href下
每个帖子的链接都位于href下
每个帖子的链接都位于href下
所以写了以下的代码：
所以写了以下的代码：
所以写了以下的代码：
BeautifulSoup形式：
BeautifulSoup形式：
BeautifulSoup形式：



获取每一个帖子链接上要爬取的信息，编号，姓名，性别，出生日期，失踪时身高，失踪时间，失踪地点，以及是否报案，并写入CSV中








通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
通过查看每一个帖子的链接，发现其失踪人口信息都在<ul>标签下，所以编写了以下的代码
BeautifulSoup形式：
BeautifulSoup形式：
BeautifulSoup形式：
BeautifulSoup形式：




现附上所有代码，此代码仅供参考，不能用于商业用途，网络爬虫易给网站服务器造成巨大负荷，任何人使用本代码所引起的任何后果，本人不予承担法律责任。贴出代码的初衷是供大家学习爬虫，大家只是研究下网络框架即可，不要使用此代码去加重网站负荷，本人由于不当使用，已被封IP，前车之鉴，爬取失踪人口信息只是为了从空间上分析人口失踪的规律，由此给网站造成的什么不便，请见谅。








附上所有代码：
附上所有代码：
附上所有代码：
附上所有代码：




































三维模型重建顾名思义就是从一些数据（点云，图片，三维轮廓线等）重建出物体的三维逼真的三维模型，在其重建的过程中针对不同的数据的的三维重建会有不同的处理算法，如针对点云数据的三维重建有很多种重建方法,如基于Delaunay三角化，Voronoi图，隐式曲面等方法，另外在三维模型的重建过程（MarchingCube，RayCast,网格构建等）以及三维模型生成后的后处理算法（三维网格简化，三维网格加密，三维模型表面光滑，三维模型的空洞修补等等）也是层出不穷，在这其中需要用到大量的三维图形学知识（从简单的画点画线算法到复杂的体绘制算法，以及光照计算，材质映射等）。在最后的实现方面致力于提高算法效率和运行性能，各种加快算法实现的三维数据结构（KD树，八叉树等）的提出和实现，以及压榨计算机和服务器性能的并行算法（OpenMP，MPI）等，减少算法实现过程中的内存占用以及运行时间（降低空间复杂度以及时间复杂度）。三维模型重建上的优秀算法或者是优秀实例我也只是管中窥豹，上面所提到的有些名词我也是大致了解，我尽自己最大的能力介绍下自己闲暇时间以前做过的相关三维模型重建的实例和其他相关的关于三维重建方面的知识，毕竟能力有限，知识面还有待拓展。
1.编程语言
是用的编程语言是C/C++，基本上相关的图形学方面的实现都是使用C/C++作为开发语言，不是说别的语言如Java，Python等语言不好，确实在效率方面以及内存处理方面C/C++有着比较大的优势，而且现在市面上的三维图形库其底层语言就是C/C++，所以使用起来更加方便。一门语言有其适用的场景和场合，正如Java在WEB和APP上面的天然优势一样，C/C++在图形处理，图像识别以及其他的图形处理领域也有着很大的优势。
2.我所使用的第三方库
（1）三维图形库OpenGL
OpenGL(Open Graphics Library)，OpenGL图形绘制库，有着优秀的二维和三维图形API，是一个功能强大的三维图形绘制的底层库，有着大量的调节三维模型视觉效果的函数，例如光照，模型材质，纹理等等。早期OpenGL包GLUT依然比较强劲，但是其不能用于64位平台的编译，而且GLUT官方已经不维护了，那么有一个新的FreeGlut横空出世，支持最新的OpenGL绘图标准，并且支持64位平台的编译，能够完全取代老化的GLUT库。


（2）三维图形库VTK
VTK（Visualization Tool Kit）同样也是一个优秀的三维图形库，近年来相当的火爆，它以OpenGL作为底层绘制语言进行封装，用户不需要考虑太多的光照以及材质影响到模型可视化效果的设置，这些VTK都已经帮你做好了，你需要考虑的是如何从原始数据绘制出你的图形。其内部封装了大量的三维图形处理函数，基本上你所能想到的算法都能找到影子，比如著名的面绘制方法MarchingCube，体绘制方法Raycast等等，往往你能在阅读他的帮助文档的时候看到一个意想不到的功能。


（3）计算机视觉库OpenCV
OpenCV（Open Source Computer Vision Library）今年来大热的计算机视觉库，同样以C/C++作为底层语言，封装了大量的图形处理和计算机视觉领域的算法，比如说图像识别领域，机器人，人类视觉仿真，好像现在大热的人工智能领域也开始使用OpenCV进行视觉领域方面的处理。


（4）矩阵运算库Eigen
在三维图形处理过程中通常需要大量的矩阵运算，而Eigen是一个轻量级的矩阵运算库，其函数API涵盖了几乎所有的矩阵运算，但是它的使用只需要包含一个头文件，不需要过于复杂的配置就可以使用已经封装好的各种矩阵运算函数。


（5）并行计算库OpenMP
OpenMP可以在你把项目代码构建好之后也仍然可以通过几行代码将你的程序自动的进行并行化计算，使用起来非常的简单，并行计算可以大幅度的提高你的程序的运行速度以及计算的效率。如果你的IDE是VS，那么你只需要简单的开启OpenMP就可以了，然后在VS中包含其头文件就可以使用OpenMP封装的函数进行并行程序设计。


其他的如CGAL（几何算法库），QT（图形界面库，不过本人更喜欢用老掉牙的MFC）等等。


3.我所接触到的三维重建类型
（1）点云三维重建（隐式曲面重建）
原始三维点云（三维点云以及法向量）-斯坦福兔子1889个点，采用OpenGL从底层写的径向基隐式曲面点云重建方法


采用径向基隐式曲面重建后的三维模型

（2）医学序列图片三维重建（使用VTK进行医学图片处理，模型构建采用MarchingCube算法）
重建结果

（3）OpenCV双目视觉重建（医学冠脉三维重建，VTK做可视化）
左视图A

右视图B

使用OpenCV做的三维冠脉重建，VTK做的显示

（4）基于轮廓线的三维模型重建
轮廓线


重建的三维模型




4.结语
万事开头难，作为一个刚刚入门三维重建领域的人写这篇文章心中的感觉简直是战战兢兢，三维模型重建方面的知识浩如沧海，我只不过是只窥得了寥寥数星。只不过自己想把自己学习到的一些知识与有缘人交流分享，共同进步。不知以后还不会不在三维领域工作与发展，不过之后的事情谁又知道呢。
后面我会详细介绍一些三维重建算法以及一些实例。



最近需要用到三维点云数据，但是网上大部分的数据资源的数据格式都是杂乱无章而且没有清晰的数据说明，为了方便，自己整理了常用的三维点云数据，格式都是按照X坐标空格Y坐标空格Z坐标这种数据格式排列，方便数据读取和进行三维点云的重建实验。
   其中的数据包含了著名的斯坦福兔子，大象，马，凳子，人头等三维点云数据，显示的效果如下：






















以下为三维点云的重建效果：
三维点云数据我已经上传到我的下载频道：常见的三维点云数据，已经整理数据格式 - 下载频道 - CSDN.NET  http://download.csdn.net/detail/hw140701/9852949
常见的三维点云数据，已经整理数据格式 - 下载频道 - CSDN.NET http://download.csdn.net/detail/hw140701/9852949



另外一些常见的三维模型的下载地址为：常见的三维模型下载地址：http://www.cc.gatech.edu/projects/large_models/
希望可以帮助到有缘人0.0




1.OpenCV创建一个灰度图，遍历每一行每一列并设置每一行每一列的像素值，并将其保存为图片,但是at方法可读性较高，但是效率不高

2.OpenCV创建一个灰度图，使用迭代器iteator遍历每一行每一列并设置每一行每一列的像素值，并保存
随机数填充像素值



3.OpenCV创建一个灰度图，使用数据指针遍历每一行每一列并设置像素值，保存图像，但是指针很危险
不进行数组越界检查


由于最近的需要在任意两个三维点直接绘制三维圆柱体管道，OpenGL太底层了，以至于什么东西都要自己写
在网上参考了如下的博客:
http://blog.csdn.net/ryfdizuo/article/details/6548257

http://blog.sina.com.cn/s/blog_5cd804e70100oxca.html

http://blog.sina.com.cn/s/blog_3d2759c90100rpnf.html

在上述博客中有详细的原理介绍，而我只是将代码改成自己可以用的形式，以便调用。
代码如下：









增大其传进去的两个参数：段数Slices，以及递归次数stacks，可以获得更加光滑的圆柱体绘制效果：
vtk中没有可以直接在三维空间中绘制三维空间圆的类以及函数，在这里，编写了以函数以任意的三维点为中心，任意半径，绘制平行于Z=0平面的圆，
可以用于批量绘制三维空间的圆。也可改写为平行为X=0或者Y=0的平面。

参考代码为：在三维空间中Z=给定值平面绘制半径为给定值的圆，圆内部填充
MFC PictureControl控件上自适应显示图片，分图片失真或者图片不失真两种





图片不失真，但是没有铺满整个图片控件区域：


问题描述:将一个string型的字符转成int型的数字，需要处理字符串输入的各种情况，如字符串前面的空格，+号，-号等符号。
     测试代码：

使用findContours（）查找图片轮廓线，并将轮廓线坐标点输出，访问二维vector，使用迭代器和下标两种方式


由于需要在三维空间中进行三维模型的碰撞与相交，为了加快检测的效率，考虑用三维物体包围盒。AABB与OOBB包围盒比起来原理简单，容易实现，为了更好的在三维空间中使用AABB包围盒，所以自己写了一个关于三维的AABB包围盒类AABB类，写了不同参数的构造函数，以及关于AABB包围盒的各种成员方法，虽然不是很全，但是可以满足日常的需要。
下面贴代码：
AABB.h


突发奇想，想写一个轰炸自己QQ好友的聊天轰炸机，哈哈哈，看了半天自己就写了一个Low的聊天轰炸机，纯粹依靠剪切板往聊天窗口复制文字，然后模拟回车按钮完成发送，写了一个简单的MFC对话框Demo，大牛自动跳出，无需再看。
主要代码如下：



1.单独拉出你想轰炸的QQ好友的聊天窗口，不要合在一起；
2.设置你想轰炸的QQ好友的昵称，就是你前面拉出来的单独的会话窗口好友的昵称；
3.选择你的BOOM.txt文件，里面是你想轰炸别人的话；
4.设置轰炸的次数。
截图如下：






源码链接：源码链接，Debug和Release版本，里面自带了我自己写的BOOM.txt




OpenCV2中新增了方便的Mat类，但是OpenCV中仍然支持C语言的lplImage和CvMat结构，但是在有些时候，出于兼容性的考虑，需要进行Mat与IpIImage和CvMat的转换。
1.Mat转为lplImage和CvMat格式
1.1 Mat转为IplImage结构
Mat img(Size(400,400),CV_8UC3);
lplImage iplimg=img;//转为IplImage结构
1.2 Mat转为CvMat类型
CvMat cvimg=img;//转为CvMat结构
类型转换后，IplImage和CvMat与Mat共用同一矩阵数据，IplImage和CvMat没有引用技术功能，如果img中的数据被释放，那么iplimg和cvimg也同时失去数据。
2.IplImage和CvMat格式转为Mat
Mat类有两个构造函数，可以实现IplImage和CvMat到Mat的转换。这两个函数都有一个参数copyData,如果copyData的值为false,那么Mat将于IplImage或CvMat共用同一矩阵数据，如果值是True,Mat会申请新的内存，然后将IplImage或CvMat的数据复制到Mat的数据区。如果共用数据，Mat不会使用计数器来管理内存，需要自己来管理。建议将参数设置为True.
构造函数如下：
Mat::Mat(const CvMat *m,bool copyData=false)
Mat::Mat(const IplImage * Img,bool copyData=false)
例子：
IplImage *iplimg=cvLoadImage("LOL.jpg");
Mat im(iplimg,true);
CvMat类似上例。
用惯了AfxMessageBox（），总感觉这个东西不那么顺手，就想在状态显示当前程序的提示信息。
想要在任何类中都设置状态栏的信息，必须获取到m_wndStatusBar的指针。
所以第一步，将CMainFrame中的m_wndStatusBar的保护类型从保护改为public
m_wndStatusBar的保护类型从保护改为public




第二步：在任意类中添加下列代码，改变状态栏的提示信息



BeautifulSoup的find()和findAll()这两个函数在某些方面十分的相似，我们可以使用它们过滤HTML页面，并查找需要的标签组和单个的标签。
    这两个函数非常的相似：
    findAll(tag,attributes,recursive,text,limit,keywords)
    find(tag,attributes,recursive,text,keywords)
    
    
标签参数tag:可以传递一个标签的名称或多个标签名称组成的Python列表做标签参数。
    如：findAll({"tag1","tag2","tag3","tag4"})
    
    
属性参数attributes是用一个Python字典封装一个标签的若干属性和对应的属性值。
    如：返回HTML文档中attribute1和attribute2属性的tag标签
    findAll("tag",{"classs":{"attribute1","attribute2"}})
   
    
递归参数recursive是一个布尔变量。如果你想知道所抓取的HTML文档标签结构中有多少层的信息，如果recursive设置为True，findAll就会根据你的要求去查找标签参数的所有子标签以及子标签的子标签。如果recursive设置为False，findAll就只会查找文档的以及标签。findAll默认支持递归查找（recursive的默认值是True）,一般情况下不需要设置该参数。只是当你真正了解自己需要哪些信息，而且抓取速度非常重要时，就可以视情况设置递归参数。


    
文本参数text是使用标签中的文本内容去进行匹配，而不是标签的属性。
    如果我们需要查询某个网页中包含"the text"内容的文本数量，我们可以使用以下语句
    namelist=bsObj.findAll(text="the text")
    print(len(namelist))
    


    
范围限制参数limit，只能用于findAll方法。find()方法等价与findAll()方法limit参数等于1时的情形。如果你只对网页中获取的前x项感兴趣，就可以设置它。但是要注意的是这个参数设置之后获取的前几项结果是按照网页上的顺序排序的，也有可能不是你想要的结果。
  
    
关键词参数keyword，可以让你选择那些具有指定属性的标签。
   如：
alltext=bsObj.findAll(id="text")
        print(allText[0].get_text())
       
    .get_text()会把你正在处理的HTML文档中的所有标签都清除，然后只返回一个只包含文字的字符串。如果你正在处理一个包含许多超链接、段落以及标签的大段源代码，那么get_text()会把这些超链接、段落、以及标签全都清除，剩下不带标签的文字。
   通常在你准备打印，存储以及操作数据时，应该在最后再使用.get_text()去提取你想要的文本信息，在一般的情况下，应该尽可能的保留HTML文档的标签的结构。
我们在进行爬虫时有的时候不可能只是在一个网站上进行内容上的爬取，理想中的爬虫应该是顺着一个链接从一个页面到另外一个页面，这需要获取页面上的所有的外链，同时收集每个页面上的内链。网站首页上不一定会发现外链，为了防止程序出错，就要递归深入到一个网站直到找到一个外链为止。
但在爬取的过程中出现了TimeoutError: [WinError 10060] 由于连接方在一段时间后没有正确答复或连接的主机没有反应，连接尝试失败。这个错误。
可能是由于访问网站频率过快，或者是我处于校园网，访问过快，被学校的服务的给限制了，或者是网速不好。所以在网上百度了下，设置了代理IP，结果完美运行，没有出现这个原因，最新的代理IP，自行百度即可。
Meshlab是一个强大的三维模型处理的软件，在三维点云的处理方面也十分强大，不仅仅可以用三维点云重构出三维模型，还可以计算出三维点云每个点的法向量，这在逆向工程和基于三维点云的隐式曲面重建中非常有用。
   我的Meshlab的版本是3.3，可以在网上自行下载破解版。
1.Meshlab读取三维点云
第一步：打开Meshlab软件
第二步：点击File菜单下的ImportMesh导入txt文档，需要选择你的txt文档中XYZ坐标之间的分隔符，导入成功后会显示你的三维点云数据
2.三维点云重建
点击下图图标，弹出右侧图层侧边栏
然后点击Fiter菜单下Normals，Curtavures and Oreientation下的Smooths normals on a point set计算三维点云的法向量，如下图
然后设置计算点云法向量的参数，默认就好，如有需要可以自行设置，点击Apply等计算完成然后点击Close关闭对话框
计算完点击法向量之后，点击Filter菜单下Remeshing Simplication and Reconstruction下的Surface Reconstruction：Ball Pivoting进行三维点云重建
然后设置三维点云重建参数，默认就好，也可以自行设置，点击Apply等重建完成，点击close关闭对话框
然后点击下列图标显示重建的三维模型，也可以设置光照等其他参数
以下为三维重建结果
3.法向量的导出与计算
三维点云的法向量的导出与计算有两种方式，一种是在上一节三维重建中我们已经得到了重建后的三维模型，那么每个点都带有法向量，可以直接导出即可，还有一种就是从杂乱的三维点中计算每一个三维点的法向量
3.1从三维模型中导出三维点云中每个点的法向量
接着第二节的步骤，点击File菜单下Export Mesh as 
然后在接下来的对话框中选择xyz格式
然后在 接下来的对话框中勾选Normal就可以生成文本格式的三维点以及三维点法向量
以下为文本格式的三维点坐标以及三维点法向量的结果
3.2 直接从三维散乱点云中生成三维点的法向量
然后点击Filter菜单下Normals，Curtavures and Oreientation下的Compute normals for point set计算三维点云的法向量，如下图
在弹出来的对话框可以自行设置参数，先Apply然后再Close
法向量的导出与3.1中的一样，可以自行参考。


以下为三维点云以及点云的法向量的可视化结果，点云表示为红色的点，法向量表示为绿色的线段
好久都没有动Python了，自从在网上买了《Python网络数据采集》这本书之后一直没有时间写自己的小的Demo,今天再网络上无意中看见
http://www.cnblogs.com/mfryf/p/3695844.html：

这篇博客，自己想要不花一个小时复习下BeutifulSoup，然后实现与上面的那个博客一模一样的功能，其实自己以前就想写这样的一个东西，像上面博主一样，也只是想每天看一下博客的访问量有没有上涨，哈哈哈哈哈。
MFC项目开发过程中需要获取某个树控件下某个树节点下所有的子节点的文本，添加到某个组合框上，网上的相关代码差不多是遍历整个树控件，所以自己就封装了一个函数，用于获取指定树节点下的所有的子节点的文本然后添加到某个组合框中，其中获取的文本被压入CString类型的容器保存。

当初学Python进一个Python学习群，不久之后群主大大就发了自己写的一个爬虫，就是爬取www.mzitu.com网站上的妹纸图片，看完之后，惊为天人，一脸懵逼，觉得群主大大好厉害，当初自己进群的初衷以及学Python的初衷就是为了做爬虫，然后慢慢的开始。所以说这次，就是为了实践一下，爬取这个网站上的所有的图片，别邪恶哦，虽然是隐藏福利，我只是为了写爬虫实践，我只是为了写爬虫实践，我只是为了写爬虫实践！！！


网络爬虫会给网站服务器造成巨大负荷，所以，本次实践的源码仅供参考交流，不宜用于商业应用，由此造成的任何法律责任本人不予承担。


为了得到这个网站上所有的妹子图片，就得分析网站的架构，通过分析发现http://www.mzitu.com/all这个网址下有2013-2017年网站上所有的相册的链接，所以准备通过以下步骤爬取网站上的所有图片。


第1步：在http://www.mzitu.com/all下获取所有的相册的链接以及相册的名字
第2步：根据每个相册的链接得到每个相册每一个图片页面的链接
第3步：根据每一个图片的链接得到每一张图片的名字以及图片链接


第一步：在http://www.mzitu.com/all下获取所有的相册的链接以及相册的名字
在
http://www.mzitu.com/all下获取所有的相册的链接以及相册的名字
分析网站源码，查看每一个相册链接以及名字的所处标签




由图上可以看出，每一个相册的链接以及名称都位于<a >标签下


第二步：根据每个相册的链接得到每个相册每一个图片页面的链接
根据每个相册的链接得到每个相册每一个图片页面的链接
通过分析网站源码，分析每一个相册下每一个图片页面的链接
通过分析网站源码，分析每一个相册下每一个图片页面的链接




通过分析，发现每一个图片页面链接都处于<div class="pagenavi">的<a herf>下，但是只有几个图片的页面的链接，如上图所示，分别只有2,3,4.......65，但是图片页面的规律是相册链接+"/"+页面编号，在这里我们得到最大的页面编号65，就可以通过循环得到每一个图片页面的链接，所以在这里通过字符选取将编号压入进一个list，然后通过max方法得到最大编号，得到每一个相册图片页面的链接。


第三步：根据每一个图片的链接得到每一张图片的名字以及图片链接
根据每一个图片的链接得到每一张图片的名字以及图片链接
根据以上得到的图片页面链接，在每个页面内爬取图片的下载链接以及图片的名称
根据以上得到的图片页面链接，在每个页面内爬取图片的下载链接以及图片的名称




通过分析，图片链接以及名称都位于<img>标签内


通过以上的分析，将整个流程写为Python代码，在其中使用了第三方包Beautifulsoup,现附上全部代码，如有错误，请指教







刚刚开始写的时候，会遇到服务器断开链接，以及主机在一定时间内无法连接的错误，在百度上，谷歌上看了半天，可能是由于网站的反爬虫机制，我自己的解决办法如下，不知道你们可不可行：
1、关闭windows防火墙，爬完再开
2、采用多headers，伪装不同的浏览器
3、每下载完，sleep一下，减缓访问网站的频率，如果过快，网站服务器会认为你是爬虫
4、设置全局超时时间，有时候因为网速的问题会出现这种情况
5、设置代理IP


刚刚开始不知道为什么这个网站不能用代理IP访问，一访问，网站服务器就强制断开连接，后来又可以了，尽量用代理IP，免得被封IP，代理ip网站可上http://ip.zdaye.com/查询


在这个代码中，没有采用多线程机制，所以爬起来比较慢，勿喷。
最好在晚上爬，网速快。
爬取结果（隐藏福利）：






转载地址：http://www.cnblogs.com/bluestorm/p/3168720.html
这三种类型各有各的优点，比如CString比较灵活，是基于MFC常用的类型，安全性也最高，但可移植性最差。string是使用STL时必不可少的类型，所以是做工程时必须熟练掌握的；char*是从学习C语言开始就已经和我们形影不离的了，有许多API都是以char*作为参数输入的。所以熟练掌握三者之间的转换十分必要。
VTK生成指定圆心以及指定半径的三维球，并将其导出为obj三维模型格式



Meshlab中载入qiu.obj




可在meshlab中将其转换为其他的三维数据格式或者提取球体表面的三维点云。
一、创建状态栏的两种方法
CStatusBarCtrl和CStatusBar两个类来完成
CStatusBar两个类来完成
                  //设置状态栏文本
                  m_StatusBar.SetText("分栏一", 0, 0);
                  m_StatusBar.SetText("分栏二", 1, 0);
                  m_StatusBar.SetText("分栏三", 2, 0);
                  //下面是在状态栏中加入图标
                  m_StatusBar.SetIcon(1, 
                                SetIcon(AfxGetApp()->LoadIcon(IDR_MAINFRAME),
                 //----------------让这个状态栏最终显示在对话框中-------------
                  RepositionBars(AFX_IDW_CONTROLBAR_FIRST,AFX_IDW_CONTROLBAR_LAST,0);
二、实时显示系统时间信息
在程序中添加WM_TIMER消息响应函数，这里以基于对话框程序为例
第一种创建状态栏的方法
void CCJCZDlgDemoDlg::OnTimer(UINT_PTR nIDEvent)
{
// TODO: 在此添加消息处理程序代码和/或调用默认值
CTime t = CTime::GetCurrentTime();
CString str;
str.Format("%04d/%02d/%02d  %02d:%02d:%02d",t.GetYear(),t.GetMonth(),t.GetDay(),t.GetHour(),t.GetMinute(),t.GetSecond());
m_StatusBar.SetText(str, 2, 0);


CDialogEx::OnTimer(nIDEvent);
}

m_wndStatusBar.SetPaneText(2,str);
    冠脉三维重建就是从两幅不同角度拍摄的冠脉医学图片根据相机参数(角度)重建出原有的三维冠脉形态。
    具体文献可以参考：
      1.黄家祥. 冠状动脉树三维骨架重建方法的研究[D]. 天津大学, 2003.
      2.王国铸. 单臂冠脉造影三维重建与定量分析[D]. 华中科技大学, 2012.
      3.郝培远. 冠脉造影三维重建定量分析(QCA)及最佳投照角度的研究[D]. 南方医科大学, 2011.等文献





这里以黄家祥这篇文章的数据作为例子，具体的冠脉三维重建步骤可见这篇文章黄家祥. 冠状动脉树三维骨架重建方法的研究[D]. 天津大学, 2003。
以下为其中的一个实验所给出的数据，两幅不同角度的图片为。




         图A                               图B




图A和图B的相机参数分别为RAO 0，CAUD35和LAO 80，CRAN15。

图A和图B的相机参数分别为RAO 0，CAUD35和LAO 80，CRAN15。




















有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。

有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。

有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。






    匹配的结果如下：
匹配的结果如下：
















上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。

上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。

上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。












以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）

以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）

以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）

以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）












总体上来看，重建效果与论文中最后给出的结果类似，VTK封装了OpenGL底层的绘图命令，所以在光照与材质方面不需要我们去过多的设置就会有逼真的三维显示效果。
总体上来看，重建效果与论文中最后给出的结果类似，VTK封装了OpenGL底层的绘图命令，所以在光照与材质方面不需要我们去过多的设置就会有逼真的三维显示效果。




1.显示一个地球各大洲板块的轮廓线

2. 地图指北针图例



原文地址：Graphics Software  http://www.dgp.toronto.edu/~rms/links.htmlGraphics Software
贴出来贴出来贴出来，防止自己忘掉。。。。

Shape Modeling
Texturing
题目描述：反转整数输出，注意的是输入被假定为一个32位有符号整数。当反整数溢出时，函数应返回0。
  今年的华为的实习生招聘笔试的第一个题与这个有点类似，不过华为的是输入两个整数，反转，然后输出两个整数反转后两个数的和。
  测试代码：

自己封装的三维向量类Vector.h,包含一些常见的三维向量类的操作符重载和一些基本运算，可以直接复制粘贴作为头文件包含在项目文件中。

Win32编译环境下，用ADO数据库连接Access数据库一般都不会报错，但是最近由于项目上的需要，程序需要编译成64位以便申请到更多的使用内存空间，当把编译方式从Win32改为x64的时候，突然出现了数据库连接出现未知错误，这时候就猜到了应该是编译环境的改变导致了数据库连接出错，在参考了其他大神的解决方案之后，终于解决了这个问题,我的环境为Win7
 64+MFC(VS2010)+ADO+Access2007。
    参考链接如下：
    http://blog.csdn.net/sundacheng1989/article/details/17925431
    http://www.cnblogs.com/bluedoctor/p/3925871.html
    http://blog.csdn.net/kirawoo/article/details/39032387
    http://blog.csdn.net/u010891996/article/details/12522911


解决方法：
步骤1：去官网下载AccessDatabaseEngine_64.exe,下载链接
https://www.microsoft.com/zh-cn/download/details.aspx?id=13255
或者直接去我的下载频道进行下载
http://download.csdn.net/detail/hw140701/9830665





步骤2:这一个步骤是强制安装刚刚下载的AccessDatabaseEngine_64.exe，如果不强制安装的话，它会要求你卸载你所安装的全部的Office软件，那多麻烦！！！，所以选择忽略提醒，强制安装，
AccessDatabaseEngine_64.exe，如果不强制安装的话，它会要求你卸载你所安装的全部的Office软件，那多麻烦！！！，所以选择忽略提醒，强制安装，
打开cmd.exe,在命令行输入“你的AccessDatabaseEngine_64.exe的存放路径” /passive，比如我的就是"F:\软件\我下载的\Windows数据库编程\AccessDatabaseEngine_64.exe"
 /passive强制安装，输完这个命令就等待安装完成。
打开cmd.exe,在命令行输入“你的AccessDatabaseEngine_64.exe的存放路径” /passive，比如我的就是"F:\软件\我下载的\Windows数据库编程\AccessDatabaseEngine_64.exe"
 /passive强制安装，输完这个命令就等待安装完成。
AccessDatabaseEngine_64.exe的存放路径
AccessDatabaseEngine_64.exe
步骤3：在安装完上述引擎之后，你需要修改一下你的代码，在win32编译环境下我们的数据库的链接字符串是
步骤3：在安装完上述引擎之后，你需要修改一下你的代码，在win32编译环境下我们的数据库的链接字符串是
m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%s",databaseName);

如果你需要在x64的编译环境环境下连接Access数据库你需要修改为
如果你需要在x64的编译环境环境下连接Access数据库你需要修改为
m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

为了更好的适配不同的编译环境，我将我的代码修改为
为了更好的适配不同的编译环境，我将我的代码修改为


m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.ACE.OLEDB.12.0;Data Source=%s",databaseName);
当是32位程序的时候就为
当是32位程序的时候就为
当是32位程序的时候就为
m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);

m_connection.Format("Provider=Microsoft.Jet.OLEDB.4.0;Data
 Source=%s",databaseName);








然后重启一下PC，应该就可以编译成功了。
然后重启一下PC，应该就可以编译成功了。
然后重启一下PC，应该就可以编译成功了。
然后重启一下PC，应该就可以编译成功了。




在网上看见一个对3D建模介绍十分全面的博客，来自中国科技大学图形与几何计算实验室刘利刚老师，介绍的非常棒，膜拜一下。
此处注明转载博客网址：3D建模与处理软件简介-中国科技大学刘利刚
3D建模与处理软件简介
刘利刚
中国科技大学
http://staff.ustc.edu.cn/~lgliu
 
【前言】自半年前笔者发表博客“什么是计算机图形学”以来，时常有人来向笔者询问3D模型的构建方法与工具。
笔者的研究方向是以3D技术为主，具体包括3D建模，3D处理及3D打印三个方面，在3D建模与处理方面从事了
十多年的研究，接触过很多3D相关的软件，在这方面有些经验。因此，特撰写此文，以帮助我们的学生及关注3D
技术的人了解3D建模和3D技术。本文仅仅为笔者根据自己的经验对3D建模与处理软件浅薄的理解，不涉及对技术
的深入讨论，是非学术性的。因此，笔者尽量尝试用通俗的语言介绍一下各种3D建模的软件和工具，以帮助还未接
触3D技术的学生来了解这些工具，以便在今后的科研和工作中能够选择合适的3D工具。笔者对本文的有些内容的理
解也是很有限的，值得进一步的学习和交流。有不当之处，还请读者谅解指正。
 
 
一、           专业3D建模软件
 
1.       3DS
 Max
美国Autodesk公司的3D
 Studio Max（前身是Discreet公司的，后被Autodesk收购）是基于PC系统的三维建模、动画
、渲染的制作软件，为用户群最为广泛的3D建模软件之一。常用于建筑模型、工业模型、室内设计等行业。因为
其广泛性，它的插件也很多，有些很强大，基本上都能满足一般的3D建模的需求。我们的学生也需要经常用到3DS
Max来构建模型。网上关于3DS
 Max的教程和学习视频非常多，使用者众多。
 
2.       Maya
Maya也是Autodesk公司出品的世界顶级的3D软件，它集成了早年的两个3D软件Alias和Wavefront（这两个软件在我
读博时就非常有名，当时就代表了最先进的动画及数字技术，我曾用过Wavefront）。相比于3DS
 Max，Maya的专
业性更强，功能非常强大，渲染真实感极强，是电影级别的高端制作软件。在工业界，应用Maya的多是从事影视
广告，角色动画，电影特技等行业。我们的学生也经常用Maya来制作和渲染3D模型，生成漂亮的渲染结果放在论
文中。
 
3.       Softimage
Softimage曾经是加拿大Avid公司旗下的专业的3D动画设计软件，后被Autodesk收购。它在影视动画方面，特别是
角色功能非常强大。许多电影，比如《泰坦尼克号》、《失落的世界》、《第五元素》等，都曾使用Softimage来
制作大量的惊人的视觉效果。
 
4.       LightWave
LightWave是美国NewTek公司开发的一款3D动画制作软件，具有悠久的历史，我在读博时曾接触过。它的功能非
常强大，特别是在生物建模和角色动画方面功能异常强大，广泛应用在电影、电视、游戏、网页、广告、印刷、
动画等各领域。在电影《泰坦尼克号》中细致逼真的船体模型及其他众多游戏的场景和动画都曾使用LightWave
来制作的。
 
5.       Rhino（犀牛）
Rhino是美国Robert
 McNeel公司开发的专业3D造型软件，它对机器配置要求很低，安装文件才几十兆，但“麻雀虽
小，五脏俱全”，其设计和创建3D模型的能力是非常强大的，特别是在创建NURBS曲线曲面方面功能强大，也得到
很多建模专业人士的喜爱。在与上海造船厂研究所的合作项目中，我们用Rhino来进行船体曲面的NURBS建模和修
改，非常方便灵活。
 
6.       Cinema
 4D
Cinema 4D (C4D)是德国Maxon公司的3D创作软件，在苹果机上用得比较多，特别是在欧美日为最受欢迎的三维动
画制作工具。2009-2010年我在美国哈佛大学访问期间，经常看到学生用C4D在进行3D建模和动画的设计。
 
7.       Creator
MultiGen-Paradigm公司开发的Creator是专门创建用于大型3D虚拟仿真的实时三维模型的软件。其强大之处在于管
理3D模型数据的数据库，使得输入、结构化、修改、创建原型和优化模型数据库非常容易。前几年与一家从事数
字城市的公司合作时我们就用Creator快速创建大量的城市建筑模型，并且生成数据库来管理这些模型，还是相当
的方便。
 
注：从上述介绍可知，美国Autodesk公司当之无愧是当今3D建模和动画的“老大”，拥有3DS
 Max、Maya和Softimage等
3D建模和动画专业软件。3DS
 Max和Maya在3D建模方面各有特色，前者更为大众化些，相对容易掌握些，后者在专
业级的行业应用更为广泛，特别在制作动画和高质量渲染方面强于前者。我们的学生用Maya的相对多些，包括建模，
渲染和动画制作。Softimage和LightWave在3D动画方面表现强大。Rhino对NURBS曲面的支持更好。Creator适合于构
建大量的3D模型并构建数据库进行管理和修改。
 
 
二、           CAD建模和产品设计软件
 
1.       AutoCAD
AutoCAD (Auto Computer-Aided Design)是美国Autodesk公司出品的自动计算机辅助设计(CAD)软件，用于二维绘图
、文档规划和三维设计。适用于制作平面布置图、地材图、水电图、节点图及大样图等。广泛应用于土木建筑、装
饰装潢、城市规划、园林设计、电子电路、机械设计、航空航天、轻工化工等诸多领域。大家买房时看的房型图大
部分都是用AutoCAD来做的。
 
2.       CATIA
Catia由法国Dassault
 Systems公司开发的CAD/CAE/CAM一体化的三维软件，支持产品开发的整个过程，从概念(CAI
D)，到设计(CAD)，到分析(CAE)，到制造(CAM)的完整流程。可帮助制造厂商设计未来的产品，并支持从项目前阶
段、具体的设计、分析、模拟、组装到维护在内的全部工业设计流程，在机械行业，航空航天、汽车工业、造船工
业等应用广泛。其实体造型和曲面设计的功能非常强大。我读博期间曾接触过Catia，在它上面写过一个NURBS曲
面转换的插件程序。
 
3.       SolidWorks
SolidWorks是世界上第一个基于Windows开发的三维CAD系统，后被法国Dassault
 Systems公司(开发Catia的公司)所
收购。相对于其他同类产品，SolidWorks操作简单方便、易学易用，国内外的很多教育机构（大学）都把SolidWork
s列为制造专业的必修课。SolidWorks在杭州有专门的研发机构，我有个学生硕士毕业后在那里进行研发工作。
 
4.       UG
 NX
UG NX由美国Unigraphics
 Solutions (UGS)公司开发的CAD/CAE/CAM一体化的三维软件，后被德国西门子公司收购
。广泛用于通用机械，航空航天、汽车工业、医疗器械等领域。现在西门子公司在上海有专门的研发机构对UG
 NX
产品进行升级完善，我有2个学生博士毕业后在那里负责产品的开发和维护。
 
5.       Pro/E
Pro/Engineer是美国PTC公司(Parametric
 Technology Corporation)旗下的CAD/CAM/CAE一体化的三维软件。在参数化
设计，基于特征的建模方法具有独特的功能，在模具设计与制造方面功能强大，机械行业用的比较多。
 
注：除了上述所介绍的CAD/CAE
 /CAM系统软件（它们各有特色，在市场中都占有一定的份额）外，还有其他一些同
类产品，比如法国Missler公司的Topsolid和以色列Cimatron公司的Cimatron。一般在机械设计与产品研发相关的行业中
才会接触到这些软件，专业性比较强，在网上很容易能找到它们的相关资料。
 
 
三、           3D雕刻建模软件：笔刷式高精度建模软件
 
3D雕刻建模软件(Sculpturing
 modeling)，也称为笔刷式高精度建模软件，顾名思义，就是像艺术家那样用不同的“笔
刷”工具在模型表面上进行“雕刻”的自由创作。建模过程就像玩橡皮泥一样，利用拉，捏，推，扭等操作来对几何
进行编辑，生成任意的高度复杂和丰富的几何细节（如怪兽的复杂表面细节）。这些工具的出现颠覆了过去传统三
维设计工具的工作模式，解放了艺术家们的双手和思维，告别过去那种依靠鼠标和参数来笨拙创作的模式，完全尊
重设计师的创作灵感和传统工作习惯。
 
1.       ZBrush
美国Pixologic公司开发的ZBrush软件是世界上第一个让艺术家感到无约束自由创作的3D设计工具。 ZBrush能够雕刻
高达 10 亿多边形的模型，所以说限制只取决于的艺术家自身的想象力。
 
2.       MudBox
MudBox是Autodesk公司的3D雕刻建模软件，它和ZBrush相比各有千秋。在某些人看来，MudBox的功能甚至超过了
ZBrush，可谓ZBrush的超级杀手。
 
3.       MeshMixer
最近，Autodesk公司又开发出一款笔刷式3D建模工具MeshMixer，它能让用户通过笔刷式的交互来融合现有的模型
来创建3D模型（似乎是类似与Poisson融合或Laplacian融合的技术），比如类似“牛头马面”的混合3D模型。
值得注
意的是，最新版本的
MeshMixer
还添加
3D
打印支撑优化新算法，值得关注。我们
Siggraph
 Asia 2013
的论文“
Cost-effe
ctive
 Printing of 3D Objects with Skin-Frame Structures
”也给出了一种为
3D
打印加尽可能少的支撑材料的新算法（详
见我的博文“
经济节约型的3D打印技术
”），该算法也是具有较好的市场前景，我们也在努力进行产业转化。
 
4.       其他
其他还有一些同类的3D雕刻建模软件，比如3DCoat，Sculptris，Modo等。这里就不再详细介绍了。
 
注1：在工业界，人们更偏向于使用四边形网格(quad
 mesh)，而不是三角网格，一个很重要的原因就是这些雕刻建模
工具善于在四边形网格上进行细节的生成和编辑，因为四边形网格的边更能反应物体表面的流线方向(edge
 flow)。我
们Pacific Graphics 2010的一篇论文B-mesh，就是在建模过程中同时生成具有良好流线方向的四边形基网格(base
 mesh)，
然后直接可以导入到这些雕刻软件中进行进一步的细节雕刻建模。
 
注2：虽然这些笔刷式建模工具上手容易，给了用户便利的方式进行3D细节建模，但是，要想真正构建一个细节复杂
和逼真的3D模型还是不容易的，除了用户需要熟练掌握软件的各种工具及雕刻技巧外，还需要用户具有较好的艺术和
绘画功底。
 
 
四、           基于草图的3D建模软件
 
基于笔划或草图的交互方式由于其符合人类原有日常生活中的思考习惯，交互方式直观简单（就像在图纸上画画
一样来构建3D模型），是最近十多年来计算机图形学中研究的热点建模方法之一。这方面的研究论文有很多，比
如Siggraph 1999年的Teddy，到Siggraph
 2006年的SmoothSketch，Graphics
 Interface 2007的Magic Canvas，Siggraph 
2007年的FiberMesh，SigCHI
 2010年的ICanDraw等。最近，我们也提出一种基于阴影引导的草图交互的3D建模的
技术“Modeling
 by Drawing with Shadow Guidance”，从已知的模型数据库中提取信息来引导用户的笔划交互，能构
建更为精准的3D模型，该工作发表在Pacific
 Graphics 2013上。
虽然在科研上提出了很多基于草图的
3D
建模技术，
但是至今仍未能有比较成熟的商业化的软件出现，可能是因为要理解不同用户的划线和草图还是一件比较困难的
事情。对于一些比较规则的物体，比如建筑、家具等人造物体，这种方式相对可行些，比如
Google
的
SketchUp
（在
国内我们也称为“草图大师”）。
SketchUp
是一套面向普通用户的易于使用的
3D
建模软件。使用
SketchUp
，创建
3D
模型就像我们使用铅笔在图纸上作图一般，软件能自动识别你画的这些线条，加以自动捕捉。它的建模流程简单
明了，就是画线成面，而后拉伸成体，这也是建筑或室内场景建模最常用的方法。
SketchUp
还可以将你自己的制
作成果发布到
Google
 Earth
上和其他人共享，或者是提交到
Google
的
3D
 Warehouse
（
Google
的
3D
模型库）。当然你
也能从
Warehouse
那儿得到想要的素材，以此作为创作的基础。很有趣的是，在
2012
年
Google
公司的
SketchUp
被美
国
Trimble
公司收购了。去年出了个
Trimble
 SketchUp 2013
，网评似乎不太好。不知其是否能继续免费。
最近国内出
了一款叫做“
EasyToy
”的采用草图式的
3D
建模软件，适用于卡通动漫形象与玩具的设计。但我还没有试用过，不知
用户体验如何。另外，日本东京大学的
Takeo
 Igarashi
教授也发布了一些基于草图式的
3D
建模系统，比如
Teddy
，在
其主页上可以下载到。
另外，值得一提的是，基于草图的交互方式在现在正在兴起的
Web3D
建模领域会有新的广阔
空间。
Web3D
建模在稍后会介绍。
 
 
五、           基于照片的3D建模软件
 
从物体的照片来进行3D模型的构建，是计算机图形学和计算机视觉的一大研究方向，称为基于图像的几何建模(Ima
ge based modeling)。这种技术已逐渐成熟且走向实用阶段，最近有些软件能够让用户拿着普通相机或者手机对着要
建模的实物从不同视角拍摄若干照片，然后软件就能根据这些照片自动地生成相应的3D模型。这种基于
图片的建
模技术提供给了非专业建模人士来构建
3D
模型的工具。
 
1.       Autodesk
 123D
Autodesk公司最近发布了一套平民级的建模软件Autodesk
 123D，用户不需复杂的专业知识，只要为物体从不同的
视角拍摄几张照片，该软件就能自动地为其生成3D模型，而且软件是完全免费的。
(1)    Autodesk
 123D是一款免费的3D CAD 工具，用户可以使用一些简单的图形来设计、创建、编辑三维模型，或者
在一个已有的模型上进行修改。
(2)    Autodesk
 123D Catch是建模软件的重点，用户使用相机或手机来从不同角度拍摄物体、人物或场景，然后上传
到云，然后该软件利用云计算的强大计算能力，可将数码照片中几分钟的时间内转换为3D模型，而且还自动带上
纹理信息。我们试用过几次，感觉它的使用还是很方便的。但是其生成的3D几何的细节不多，主要是通过纹理信
息来表现真实感的。有时软件也会失败，生成的几何是不正确的。
(3)    Autodesk
 123D Make是将3D模型转换为2D的切割图案，用户可利用硬纸板、木料、金属或塑料等低成本材料
将这些图案迅速拼装成实物，从而再现原来的数字化模型。这让用户能够“制造”出所造的3D模型，有点像3D打印
的雏形。目前123D Make只有Mac版的。
(4)    Autodesk
 123D Sculpt是一款运行在iPad上的3D雕刻软件（前面已介绍过），通过绘画的方式在模型上雕刻
几何细节。
 
2.       3DSOM
 Pro
3DSOM Pro是一款从高质量的照片来生成3D建模的软件，它可以通过一个真实物体的照片来进行3D建模，并且制
作的模型可以在网络上以交互的方式呈现。
 
3.       PhotoSynth
微软开发了一款产品PhotoSynth，可将大量的照片做3D处理，但是它不是真正创建3D模型，而是根据照片之间的
相机参数及空间对应关系，建构一个虚拟的3D场景，使得用户能够在从不同角度和位置来查看该场景，而显示的
场景图像是由给定的照片所合成的。其基本原理来自于Siggraph 2006的论文“Photo
 Tourism: exploring photo colle
ctions in
 3D”及其他相关论文。
 
注：从多幅不同角度拍摄的照片来重建3D物体，从技术原理上来讲是可行的，但是由于算法的一些步骤，比如图像
中物体特征点的检测和匹配，相机参数的估计等，还会出现不太正确的结果，使得重建结果有时不够稳定，甚至不
正确。随着技术和计算能力的不断发展，相信这些会逐步得到解决。到时，从照片来重建3D模型的技术可能是最为
方便的3D建模技术了，因为人人都有手机，随时都可以拍照上传到云端来构建3D模型。如果有了大数据库的支持，
从单张照片来构建3D模型也是可能的，可以参看我们的Siggraph
 2011的论文。
 
 
六、           其他3D建模软件
 
1.       人体建模软件
关于构建人体模型及动画，首推Metacreations公司的Poser软件（俗称“人物造型大师”）和开源的MakeHuman软件
。这两款软件都是基于大量人类学形态特征数据，可以快速形成不同年龄段的男女脸部及肢体模型，并对局部体
形进行调整。可以轻松快捷地设计人体造型、动作和动画。我读博期间用过Poser构建人体模型来做morphing，
还是蛮方便的。
 
2.       城市建模软件
加拿大Esri公司的CityEngine是三维城市建模的首选软件，可以利用二维数据快速创建三维场景，并能高效的进行
规划设计。应用于数字城市、城市规划、轨道交通、管线、建筑、游戏开发和电影制作等领域。另外，CityEngine
对ArcGIS的完美支持，使很多已有的基础GIS数据不需转换即可迅速实现三维建模，缩短了三维GIS系统的建设周
期。该软件的核心技术是Siggraph 2001的论文“Procedural
 Modeling of Cities”及其他相关论文，早期是ETH Zurich
大学的Pascal Mueller研究小组创办的Procedural公司开发的，后被Esri公司收购。
 
3.       其他小巧的3D建模软件
下面的这个网页还介绍了一些其他3D建模相关的软件或程序：
http://tech.sina.com.cn/s/2008-10-20/08192519895.shtml
这些软件大部分都非常小巧，而且是开源且完全免费的。有很多媒体工作者和艺术家用这些小软件来制作3D作品
，其中Blender, K-3D, Art of Illusion, Seamless3d,
 Wings3D等软件的使用面稍微广泛些。有兴趣的读者可以到网上找
到相关资料去了解和学习，这里不作详细介绍。
 
4.       网页3D
 (Web3D)建模工具
最近，出现了一些基于网页(web)开发的3D模型设计软件，即基于WebGL，可以在浏览器中完成3D建模的工具。
比如3DTin，TinkerCAD（去年被Autodesk收购）等，它们的界面简单直观，有Chrome等浏览器插件插件，可以在
线生成3D模型，直接存在云端，并在社区分享模型。
在互联网的时代，
Web3D
技术将被越来越被广泛使用，建议
大家多关注。
 
 
七、           虚拟现实软件和平台
 
虚拟现实软件本质上不是用于3D建模的，而是用来对生成好的3D模型和场景提供关于视觉、听觉、触觉等虚拟的
模拟，让用户如同身历其境一般。相关软件也有很多，这不是本文的重点，只大致提及几个比较常见的。
 
1.       VirTools和Quest3D
法国VirTools公司的VirTools和美国Act-3D公司的Quest3D都是元老级的虚拟现实制作软件，简单来说，就是工业
或游戏用的实时图形渲染引擎，是3D虚拟和互动技术的集成工具。可以让没有程序基础的美术人员利用内置的行
为模块快速制作出许多不同用途的3D产品，如网际网络、计算机游戏、多媒体、建筑设计、交互式电视、教育训
练、仿真与产品展示等 。网上的学习资料比较多。
 
2.       Unity3D
 (U3D)
Unity Technologies开发的Unity3D
 (U3D)是最近几年冒出来的新秀，是一个全面整合的专业虚拟3D和游戏引擎。
它在制作虚拟现实及3D游戏方面上手非常容易，操作简单，互动性好，有强大的地形渲染器。我们的学生使用
U3D可以很快地制作一个3D游戏，因此也强烈推荐大家学习使用。
 
3.       Vega
Vega是MultiGen-Paradigm公司开发的用于实时视觉模拟和虚拟现实应用的开发引擎，提供很多的C/C++语言的应
用程序接口API，结合其应用程序的图形用户GUI界面软件LynX，可以迅速创建各种实时交互的3D环境。对于开
发3D游戏和3D场景漫游的项目非常方便。
 
4.       OSG
 (Open Scene Graph)
OSG (Open Scene Graph)是一套开源的基于C++平台的应用程序接口API，能够让开发者快速、便捷地创建高性能
、跨平台的交互式图形程序。它将3D场景定义为空间中一系列连续的对象，能够对3D场景进行有效的管理。由于
OSG是开源和完全免费的，很多3D应用的软件都选用OSG作为基础架构。几年前，我们与一个公司合作开发的义
齿软件就选用OSG作为管理3D数据的框架，使得开发非常方便。
 
5.       其他
其他的一些用于3D应用程序开发的软件开发包(SDK)或API还有GLUT(OpenGL
 Utility Toolkit), OpenGL Performer, 
CG2 VTree, Quamtum3D Mantis等。有兴趣的读者也可以去了解一下。
 
注：相比于十年前，由于有了上述开发平台和开发包，现在开发一个看起来还比较cool的3D应用程序或游戏不是那么
困难，随着技术的不断发展和3D应用不断渗入到各行各业，相信以后会更加方便。
 
 
八、           开源3D网格处理库
 
1.       PCL
 (Point Cloud Library)
Point Cloud Library (PCL)是一个独立的大型跨平台的处理二维/三维图像和点云数据的C++模板库，它基于许多第三
方库，比如Boost、Eigen、FLANN、VTK、CUDA、OpenNI、Qhull等，实现了大量点云相关的通用算法和高效数
据结构，涉及到点云获取、滤波、分割、配准、检索、特征提取、识别、追踪、曲面重建（包括Poisson重建算法
）、可视化等。早期的PCL是由Dr.
 Radu Bogdan Rusu在德国慕尼黑工业大学读博士期间开发的，目的是要为三维
点云数据处理的研究及应用，建立出一个共同的基础架构。另外，PCL利用OpenMP、GPU、CUDA等先进高性能
计算技术，通过并行化提高程序实时性。集成了Kinect Fusion重建算法。有人将其地位比喻为3D的OpenCV，足以
可见其对3D的开发和研究的重要性，我们的学生在科研过程中经常用到PCL。
 
2.       CGAL
 (Computational Geometry Algorithms Library)
CGAL是一套开源的C++算法库，提供了计算几何相关的数据结构和算法，诸如三角剖分（2D约束三角剖分及二维
和三维Delaunay三角剖分），Voronoi图（二维和三维的点，2D加权Voronoi图，分割Voronoi图等），多边形，多
面体（布尔运算），网格生成（二维Delaunay网格生成和三维表面和体积网格生成等），几何处理（表面网格简
化，细分和参数化等），凸壳算法，搜索结构（近邻搜索，kd树等），插值，形状分析，拟合等。CGAL功能强
大，是我们学生做科研的必备程序库之一。
 
3.       MeshLab
MeshLab是一个开源的处理三角形网格的C++算法库，提供了三角网格的数据结构和算法，诸如曲面重建、编辑
、修复、光顺、编辑等算法。MeshLab也是我们学生做科研的必备程序库之一。
 
4.       其他开源网格处理库
OpenMesh：由德国RWTH
 Aachen大学的Leif Kobbelt研究小组开发的C++网格处理库
Libigl: 由瑞士Ethz大学的Olga
 Sorkine研究小组开发的C++网格处理库
Trimesh：有美国Princeton大学的Thomas
 Funkhouser研究小组开发的C++网格处理库
 
5.       网格剖分(Delaunay)与生成库
Triangle, NetGen：平面三角网格生成库
TetGen, Stellar：空间四面体网格生成库
 
注：这里列出了几个主要的网格处理的C++代码库，我们的学生在学习和科研的过程中会经常用到它们。当然，网上
还有其他的各种算法库，对我们的科研和开发都是非常有用，我们有时也会用到，这里就不再详述。
 
 
九、           基于扫描（逆向设计）的3D建模软件
 
随着深度相机的普及及扫描仪的价格迅速下降，人们采集三维数据变得容易，从采集到的三维点云来重建三维
模型的工作在最近几年的Siggraph(Asia)上能常见到，比如我们Siggraph
 Asia 2010，Siggraph
 2013等的工作。最近
几年产生了许多基于点云数据的建模与处理（或逆向工程和设计）的软件，而且各种扫描设备的生产厂商也会发
布相应的点云重建的软件。
 
1.       Geomagic
Geomagic (俗称“杰魔”) 包括系列软件Geomagic
 Studio、Geomagic Qualify和Geomagic
 Piano。其中Geomagic Studio
是被广泛使用的逆向工程软件，具有下述所有特点：确保完美无缺的多边形和 NURBS 模型处理复杂形状或自由
曲面形状时，生产效率比传统 CAD软件提高数倍；可与主要的三维扫描设备和CAD/CAM软件进行集成；能够作
为一个独立的应用程序运用于快速制造，或者作为对CAD软件的补充。是我们学生科研的必备软件之一。
 
2.       RapidForm
RapidForm是韩国INUS公司出品的逆向工程软件，提供了新一代运算模式，可实时将点云数据运算出无接缝的多
边形曲面，使它成为 3D扫描数据的最佳化的接口，是很多3D扫描仪的OEM软件。我们购买的Konica
 Minolta的激
光扫描仪Range 7就是用RapidForm来进行逆向设计。我们SGP
 2010的ARAP参数化算法作为目前为止最好的参数化
算法之一，被集成到了RapidForm软件中。
 
3.       ReconstructMe
ProFactor公司开发的ReconstructMe是一个功能强大且易于使用的三维重建软件，能够使用微软的Kinect或华硕的
Xtion进行实时3D场景扫描（核心算法是Kinect
 Fusion），几分钟就可以完成一张全彩3D场景。我们尝试过，效果
还可以。ReconstructMeQt提供了一个实时三维重建利用ReconstructMe
 SDK（开源）的图形用户界面。
 
注：法国ManCTL公司开发的Skanect为Mac平台的第一款3D 扫描软件，也支持者华硕的Xtion或者微软的Kinect进行
实时3D 扫描。
 
4.       Artec
 Studio
Artec公司出品的Artec
 Eva, Artec Spider等手持式的结构光3D扫描仪，重量轻且易于使用，成为许多3D体验馆扫描
物体的首选产品。我试用过Artec Eva后感觉还是需要较多的技巧才能扫描好物体，而且后期需要用软件进行较多
的处理，比如数据的去噪、修复、光滑、补洞等。
同时，
Artec
公司还开发了一款软件
Artec
 Studio
，可以和微软的
Kinect
或华硕的
 
Xtion
以及其他厂商的体感周边外设配合使用，使其成为三维扫描仪。
Kinect
通过
Artec
 Studio
可以
完成模型扫描，然后进行后期处理，填补漏洞、清理数据、进行测量、导出数据等。不确定它是否也使用了
Kinect 
Fusion
算法。
 
5.       PolyWorks
PolyWorks是加拿大InnovMetric公司开发的点云处理软件，提供工程和制造业3D测量解决方案，包含点云扫描、
尺寸分析与比较、CAD和逆向工程等功能。
 
注1：全球四大逆向工程软件除了Geomagic
 Studio和RapidForm外，还包括ImageWare和CopyCAD，由于后两者我不
熟悉，在此就不介绍了，有兴趣的读者可以到网上去找相关资料了解。
 
注2：微软的Kinect作为快速获取3D数据的传感器，可以作为3D扫描仪来使用，我们曾使用3台Kinects来扫描人体全
身，论文发在2012年的IEEE
 TVCG期刊。现在有多款软件或者开发库（包括上面介绍的PCL，ReconstrutMe，Artec
Studio，Skanect），支持将单台Kinect作为手持式扫描仪来扫描物体，其核心都是Kinect
 Fusion算法。
 
 
十、           后记
 
最近，随着人们对3D建模的需求越来越大，出现了许多其他形式的3D建模软件和工具，比如Blokify, 基于块状化
3D建模软件，特别适合孩子们制作模型。这些新出现的工具我这里就不一一介绍了，大家可以关注网上的一些科
技新闻网站、论坛或博客等。
 
 
1.       3D模型数据浏览与转换软件
上面介绍的大部分的软件或库都支持查看不同格式的3D模型数据。如果仅仅是浏览或查看现有的3D模型数据，我
个人推荐3D Exploration软件（相当于查看图像的ACDSee软件），它是一个专门用来查看各种格式的3D模型文件，
包括3DS数据 (*.3ds,
 *.prj, *.asc)、LightWave Objects (*.lwo,*.lw)、 DirectX(*.x)、AutoCAD
 (*.dxf)、Object File Fo
rmat (*.off)、Wavefront
 (*.obj)等，还可以用鼠标交互从不同视角来查看。而且还能查看各种图像文件，包括bmp
、rle、dib、gif、jpg、png、tif、tga、pcx等。当然也能查看带纹理的3D模型。3D
 Exploration是我的机器必装软件
之一，强烈推荐。另一个我推荐的同类软件是Deep Exploration，它除了可以浏览3D数据外，还可以转换数据格式
（最新版本还支持Sketchup文件），同时它还可以对你的模型进行编辑及添加注释制作动画等，我也强烈推荐。
注：现在有很多3D数据格式，几乎每个3D建模软件都会定义自己的数据格式。几种比较公认的3D数据格式有VR
ML、obj、off、stl
 (用于3D打印的数据格式)等。现在有些组织在力推3D数据的标准。相信随着3D技术的发展，这
些格式都将越来越标准化和统一化。对各种数据格式需要更多了解的，可以到网上找找，比如：
http://www.cnblogs.com/sunliming/archive/2012/02/28/2372398.html
 
 
2.       3D模型渲染软件
本文介绍的各种3D建模软件一般都能渲染3D模型，但要得到更为逼真的真实感渲染效果，还可以使用专门的3D
模型渲染软件，比如Pixar Renderman、POV-Ray、 V-Ray、 Mental
 Ray、Final-Render等，这里就不详细介绍。一
般我们使用Maya进行渲染放在论文中，已经足够漂亮了，读者可以在我们的许多论文中看到利用Maya渲染的结果
图。
 
3.       其他相关的软件
本文以介绍3D建模的软件和库为主，另外，还有许多跟3D技术相关的软件和开发包我没有提及，比如图像处理、
可视化、处理医学图像、建筑设计、装潢设计及艺术设计等。读者可以根据各自的专业去网上寻找所需要的专业
软件。
 
4.       学习使用3D建模软件
相比于2D平面软件Adobe
 Photoshop，Illustrator，CorelDraw等，学习3D软件难度稍大些，需要了解和掌握一些3D
的概念、3D交互习惯和技巧。因此，想要在短期熟练掌握好一个3D建模软件，是不太可能的，需要多用、多摸索
、多体会。网上有许多教材和视频，您可以跟着去学习。总之，您要多去玩，就能玩熟了。如果您能有个确定的
目标来学习3D软件，比如完成项目或者论文中所需要的效果，您就能掌握得更快！因为，带有确定目标和任务的
学习，是最高效的学习。但您如果暂时用不到，暂可不必花太多时间去学习，学了但不去用，也容易忘。只要您
学习软件的速度快就可以，而这正是我们对学生的基本要求。
 
5.       3D时代的来临
最近两年3D打印机的兴起，引起人们的极大好奇与广泛关注，同时也有些争论。虽然还不清楚它是否能成为人们
生活中不可或缺的一项技术，但不可否认，3D打印技术确实已经给世界带来巨变，已逐渐在某些领域表现出巨大
的价值，比如，提高了制造行业的生产力，在医学领域得到了广泛应用（义齿，假肢，器官等），为艺术家提供
了有效的创作工具等等。个人认为，3D打印提供给了平民零技能制造的技术，会朝着“私人定制”（个性化需求）
的方向发展；随着大量草根参与到3D的设计和制造，3D打印将逐步颠覆人们创造东西的能力。正因人们对3D模型
有了巨大的需求，3D打印技术才使得计算机图形学“落地”，这也使得我们这个学科终于在人们生活中体现了巨大
的价值。关于3D打印技术将给大规模工业经济带来的巨大冲击以及给我们的生活将带来的巨大变化，这里不展开
讨论，我将以后抽空撰文加以详述。
我们再来看一下这几年的一些巨头科技公司的变化，
2011
年微软公司的
Kinect
让人们获取
3D
数据的硬件代价降低了许多，
2012
年
3D
打印的兴起造就了两家上市公司
Stratasys
和
3D
 Systems
，
2013
年苹果公司收购了
Kinect
的核心技术公司
PrimeSense
，谷歌公司收购了大名鼎鼎的机器人公司
Boston
 Dynamics
，这
些都说明，越来越多的高科技企业在快速发展
3D
科技，
3D
时代已经来临！
随着人们对
3D
技术有了越来越多的需求，本文所介绍的
3D
建模工具将会发挥出更为巨大的价值。随着科学和技术的发展，云计算与物联网的进一步发展，将会出现越来越便利的
3D
建模工具，比如
Autodesk
 123D
正在将
3D
技术从专业变成非专业，人们接触
3D
技术的门槛将越来越低，创造的
3D
模型越来越丰富。我坚信，日后
3D
技术将“飞入寻常百姓家”，会越来越平民化，且成为人们生活中重要的一部分。
当然，当前人们对3D技术的了解还远远不够，大部分的人对3D技术仍然很陌生。另一个我个人看好的市场就是3D
教育与培训，普及3D技术与培养3D技术人才已时不我待。
另外，现在也开始有了一些
3D
模型共享的网站在运营，
能够提供给全世界的用户下载、上传、分享
3D
数据；类似于十多年随着
Internet
发展而产生的图像共享网站，这些
3D
数据共享网站也将在不久的未来产生巨大的价值，
3D
模型数据也将逐步进入“大数据时代”。
我们很庆幸成为
3D
科技新时代的弄潮儿，有很多的机会和挑战在等待着我们！让我们一起努力！
Python的强大除了其简单的语法以及易用性，还有其不得不说的海量的第三库的支持。
但是，我们电脑上由于需要可能安装了多个版本的Python，如Python2.X和Python3.X,这时候我们除了在电脑上要解决多个Python版本共存的问题，还需要针对不同的版本安装支持不同版本的第三方库，而且在安装第三方库的时候在cmd.exe上可能会出现输入字符错误，或者其他的错误，简而言之，就是没有交互式的界面，不能让人像傻瓜一样简单的安装第三方包，但是Pycharm这个强大的pythonIDE（集成开发环境）给我们提供了这种便利，以下就介绍如何使用Pycharm安装不同Python版本的第三方库。
1.打开Pycharm,我的Pycharm版本为Pycharm4.5.4


2.打开File菜单下的Setting菜单，如下






3.选择Settings下Project:Python下的Project Interpreter，并选择Python的版本，点右侧+号进入第三方库的搜索界面


4.在第三方包的搜索界面输入要安装的第三方包的名字，点击左下角Install Package按钮，后会提示安装成功




到这里，第三步就安装完成了，快去试一试新的库的强大功能吧！
VTK根据几个点插值成样条曲线，然后以样条曲线为中心线，生成圆柱体管道
1.单文档应用程序的类与类之间的访问
2.多文档应用程序类与类之间的交互
3.在一个对话框中获取另一对话框的指针，由此可以访问另一对话框的函数和变量
MFC在很多的对话框操作中,我们经常要用到在一个对话框中调用另一个对话框的函数或变量.可以用如下方法来解决.
HWND hWnd=::FindWindow(NULL,_T("Sphere"));     
 //得到对话框的句柄
   C***Dialog* pWnd= (C***Dialog*)FromHandle(hWnd); //由句柄得到对话框的对象指针
   pWnd->xxx( );                                             //调用C***Dialog中的函数xxx();

HWND hWnd=::FindWindow(NULL,_T("Sphere"));     
 //得到对话框的句柄
   C***Dialog* pWnd= (C***Dialog*)FromHandle(hWnd); //由句柄得到对话框的对象指针
   pWnd->xxx( );                                             //调用C***Dialog中的函数xxx();




比如：
比如：
在这个对话框.cpp中包含要获取的对话框类的头文件
在这个对话框.cpp中包含要获取的对话框类的头文件


通过窗口类函数:CWnd *GetWindow获得窗口指针,pWnd->m_hWnd(The handle of the Windows window attached to this 
CWnd
)在::FromHandle(hWnd);


 
  
    CWnd *wnd  = AfxGetMainWnd();
                     HWND hwnd = wnd->GetSafeHwnd();


设置控件为窗口焦点：
GetDlgItem(IDC_TREE1)->SetFocus();


获取控件句柄：
HWND hwndctrl = ::GetDlgItem(mainHwnd, IDC_TREE1);
//
获取树形控件的句柄
IDC_TREE
 IDC_COMBO1


获取当前最上层窗口的句柄： HWND  mainHwnd = ::GetForegroundWindow();//获取当前topmost的窗口句柄
获取当前最上层窗口的句柄： HWND  mainHwnd = ::GetForegroundWindow();
//
获取当前
topmost
的窗口句柄
获取当前窗口的焦点句柄：
       
在MFC的主窗口中添加了tab control控件之后，可以在一个窗口中显示不同的页面。
假如主对话框类为CMainDialog, 子对话框类为CChildDialog
有时候会遇到tab 的子窗口访问主窗口中变量和函数的问题，具体方法是：
CMainDialog *pDlg = (CMainDialog *)GetParent()->GetParent()->GetParent();
pDlg->函数或者变量；
上述语句中，第一个GetParent()获取的是tab control指针，再通过tab control获取主对话框指针。
这个问题简单但是又容易犯错，当代码出现错误的时候让人非常的懊恼；
比如有两个类：CleftView和CImplicitModelView两个类，现在有这样的需求需要在两个类中都调用对方的函数，所以就在CleftView.h中加上#include "CImplicitModelView"，在CImplicitModelView.h中加上#include "CleftView.h"，
但是当我们兴高采烈地的去编译时，会出现缺少分号的错误，但是当我检查了很久的代码，发现并没有出现缺少分号，这个原因是因为类与类之间的头文件互相包含所导致的。
解决方法就是：
在两个类的头文件中进行类先导声明，然后在各自类的.cpp文件中进行头文件的包含
例如：
(1)在CleftView.h中进行CImplicitModelView的类先导声明class CImplicitModelView;(有分号),然后在CleftView.cpp文件中包含CImplicitModelView类的头文件，#include"CImplicitModelView.h"
(2)在CImplicitModelView.h中进行CIeftView的类先导声明class CleftView;(有分号),然后在CImplicitModelView.cpp文件中包含CIeftView类的头文件，#include"CIeftView.h"
在CImplicitModelView.h中进行CIeftView的类先导声明class CleftView;(有分号),然后在CImplicitModelView.cpp文件中包含CIeftView类的头文件，#include"CIeftView.h"
CImplicitModelView
CImplicitModelView
这样，就可以实现在两个类中进行互访问
这样，就可以实现在两个类中进行互访问
问题描述：给定两个非空的链表，表示两个非负整数。 数字以相反的顺序存储，每个节点包含一个数字。 添加两个数字并将其作为链表返回。
测试代码：

在我们建立三维模型的过程中，当用多边形网格或者是三角面片来近似的表示曲面的表面时，曲面被离散成许多的平面多边形，如果我们的网格较大，离散度较粗，在模型表面使用明暗处理后，两两相邻的多边形会出现凸起或者是凹陷的折痕，在连接处显得比周围处亮或者暗，这就是所谓的马赫夫效应，如下图所示
针对于出现的马赫夫效应，我们需要进行明暗处理，消除或者是减少三维模型的马赫夫效应，使其看上去更加的光滑美观，常用的明暗处理技术有双线性光强插值—Gouraud明暗处理技术和双线性法向插值-Phong明暗处理技术。以下展示经过明暗处理前后结果对比
OpenGL提供了两种着色模式
void glShadeModel ( GLenum mode)，恒定着色
GL_FLAT，光滑着色GL_SMOOTH，而GL_SMOOTH中则是使用了Gouraud明暗处理技术，对于Phong明暗处理技术可以参见http://blog.csdn.net/dalewzm/article/details/46291397
http://blog.csdn.net/silangquan/article/details/10011169

Gouraud明暗处理算法在处理亮度的不连续性方面很有效，但是在明暗强度函数的斜率急剧变化处仍然可以看到马赫夫效应，不能完全消除光强度的不连续性。而Phong明暗处理是对表面的法向量而不是亮度进行插值，大大改善了Gouraud模型对高亮度镜面反射光的处理，在每一点都是用法向量的一个近似值，所以一般法向量插值的结果要优于亮度插值，在很大程度上消除了马赫夫效应，但是会大大增加明暗处理的时间。


鉴于此，我在用MC算法建立三维模型的时候，由于我的网格设置较大，导致出现了马赫夫效应，即模型表面的可视化效果不光滑，如下：



于是使用OpenGL自带的Gouraud明暗处理技术，以一个MC算法生成的章鱼模型为例子，效果如下
相比未使用明暗处理的模型，使用了Gouraud处理的模型从可视化的角度上来看更加的光滑，效果更好。




Python并不是我的主业，当初学Python主要是为了学爬虫，以为自己觉得能够从网上爬东西是一件非常神奇又是一件非常有用的事情，因为我们可以获取一些方面的数据或者其他的东西，反正各有用处。
这两天闲着没事，主要是让脑子放松一下就写着爬虫来玩，上一篇初略的使用BeautifulSoup去爬某个CSDN博客的基本统计信息（http://blog.csdn.net/hw140701/article/details/55048364），今天就想要不就直接根据某个CSDN博客的主页的地址爬取该博客的所有文章链接，进而提取每一篇文章中的元素，我这里是提取每一篇博客中的文字信息。
一、主要思路
通过分析CSDN博客的网站源码，我们发现当我们输入某博客主页网址时，如：http://blog.csdn.net/hw140701
在主页会有多篇文章，以及文章的链接，默认的是15篇。在主页博客的底部会有分页的链接，如下图


如图所示，一共65篇分5页，每一页中又包含了15篇文章的链接。
所以我们总体的思路是：
1.输入博客主页地址，先获取当前页所有文章的链接；
2.获取每个分页的链接地址
3.通过每个分页的链接地址获取每一个分页上所有文章的链接地址
4.根据每一篇文章的链接地址，获取每一篇文章的内容，直到该博客所有文章都爬取完毕


二、代码分析
2.1分页链接源码分析
用浏览器打开网页地址，使用开发者工具查看博客主页网站源码，发现分页链接地址隐藏在下列标签之中


所以我们通过下列代码所有分页链接进行匹配



2.2分页上每一篇文章链接源码分析
得到每一个分页的链接后，对每一个分页上的文章链接源码进行分析，其源码如下


通过分析，所以我们采取以下的方法进行匹配


通过对每一篇文章中的网站源码进行分析，发现其内容位于源码中的以下位置


所以通过下列代码进行匹配

现附上全部代码，注释部分可能有错，可以根据此代码自行修改，去爬取某CSDN博客中的任意元素

先说说题外话，OpenGL是一个跨平台优秀的三维可视化库，而在Windows中内部封装的OpenGL还是1.1版本，不吐槽，维护自身Direct3D的发展也是情有可原。如果你是Win32系统，编译环境也是Win32的话，对OpenGL只是练习，那么就用简单的GLUT来配置OpenGL环境就好了，但是如果你想用X64(64位)环境来编译的话，这个GLUT会编译不成功，因为它不提供64位下的使用环境，而且太老掉牙了，版本已经不更新了，那么这个时候你就需要freeglut这个包(国外推荐使用freeglut，摒弃glut),这个包提供了32位(x86)和64(x64)两种编译环境下可用的静态链接库和动态链接库。关于64位环境编译的程序与32环境编译的程序之间的区别就是32位程序在系统中最多能申请到2G内存（2的32次方字节），而64位程序在系统中最多能申请到（2的64次方字节）的内存，64位程序理论上可以使用当前PC机上所装载的全部的内存，极大的提高了程序的性能。下面介绍了Glut和FreeGlut的详细配置教程，以便在32位编译环境和64位编译环境都得心应手的使用OpenGL。
*我的VS2010的安装位置：D:\Program Files (x86)\Microsoft Visual Studio 10.0
1.关于Glut的配置
1.1. 下载GLUT。Windows环境下的GLUT下载地址：
http://www.opengl.org/resources/libraries/glut/glutdlls37beta.zip



1.2
1.3 
1.4 
1.5 

2.Freeglut的配置




我使用的环境具体是Win764位+VS2010+Freeglut2.8.1,而Freeglut2.8.1这个版本支持VS2010,可使用最高的版本3.0，同样支持各种VS版本。


2.1 Freeglut的下载
Freeglut2.8.1:http://download.csdn.net/detail/hw140701/9830604
Freeglut其他版本的下载地址：
Freeglut3.0版本：
http://www.transmissionzero.co.uk/software/freeglut-devel/

http://download.csdn.net/detail/hw140701/9830606



2.2 生成VS2010 64位编译环境下下可用的Freeglut的包含头文件，静态链接库lib,动态链接库dll。
解压缩包，打开解压后的压缩文件夹，里面会有一个VisualStduio的文件夹，如下


    打开VisualStudio文件夹，里面会有VS2008，VS2010，VS2012三个版本的


    选择VS2010，打开项目文件freeglut.sln。


    选择Release版本，x64平台编译，右键解决方案，点击全部生成


然后你会在解压的文件夹下发现两个新的文件夹inclue和lib文件夹




include文件夹下会有GL文件夹，里面包含了freeglut所需用到的头文件，freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h,注意这里的glut.h与Glut包的glut.h文件不相同。
lib文件夹下会有一个x64文件夹，里面包含了freeglut.lib和freeglut.dll文件。
2.3 具体配置
 Freeglut配置本质上与Glut的配置原理相同，不过，我们这里配置的是64位的freeglut，稍微有一些不同。这里也简单介绍一下freeglut32位的配置，如果你要生成freeglut32可用的包含文件，静态链接库以及动态链接库，请参见上节中64的生成方法，不要需要将编译平台改为Win32，此节不再赘述。
1.将\freeglut-2.8.1\freeglut-2.8.1\include\GL文件夹下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2.将freeglut.lib复制到D:\ProgramFiles (x86)\Microsoft Visual Studio 10.0\VC\lib下。
    3.将freeglut.dll复制到C:\Windows\System32下
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\SysWOW64下。
    1.将\freeglut-2.8.1\freeglut-2.8.1\include\GL文件夹下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2.将freeglut.lib复制到D:\ProgramFiles (x86)\Microsoft Visual Studio 10.0\VC\lib\amd64下，注意这里是放64位静态链接库的地方。
    3.将freeglut.dll复制到C:\Windows\SysWOW64下
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\ System32下。
 
最后在使用的时候只需添加#include<GL/freeglut.h>就可以了。
2.4 Freeglut3.0的配置
    类似于Freeglut2.8.1的配置
下载网址就是
http://www.transmissionzero.co.uk/software/freeglut-devel/
选择freeglut3.0.0 MSVC Package




解压缩文件，有include,bin,lib三个文件夹
2.4.1 Freeglut3.0 32位的配置
    1.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\include\GL下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\lib下的
freeglut.lib复制到D:\Program Files (x86)\Microsoft Visual Studio10.0\VC\lib。
    3.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\bin下的
freeglut.dll复制到C:\Windows\System32下。
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\SysWOW64下。
 
2.4.2 Freeglut3.0 64位配置
    1.将\freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\include\GL下的四个头文件freeglut.h,freeglut_ext.h,freeglut_std.h,glut.h复制到D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\GL下（以我的VS2010安装位置为准）。
    2. \freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\lib\x64下的
freeglut.lib复制到D:\Program Files (x86)\Microsoft Visual Studio10.0\VC\lib\amd64下。
    3. \freeglut\freeglut-MSVC-3.0.0-2.mp\freeglut\bin\x64下的
freeglut.dll复制到C:\Windows\ SysWOW64下
注意：如果出现错误，建议将freeglut.dll同时复制到C:\Windows\ System32下。




3.Glew的配置
3.1 Glew的下载
http://www.cnblogs.com/Akunwjy/p/Freeglut.html













显示文件夹窗口默认显示效果：


加上语句bi.ulFlags=BIF_BROWSEINCLUDEFILES;后不仅可以显示文件夹，还可以显示文件：

加上语句bi.ulFlags=BIF_BROWSEINCLUDEFILES;后不仅可以显示文件夹，还可以显示文件：




加上语句bi.ulFlags=BIF_NEWDIALOGSTYLE;后窗口可以调整大小，并有新建文件夹按钮：

加上语句bi.ulFlags=BIF_NEWDIALOGSTYLE;后窗口可以调整大小，并有新建文件夹按钮：

加上语句bi.ulFlags=BIF_NEWDIALOGSTYLE;后窗口可以调整大小，并有新建文件夹按钮：






加上语句bi.lpszTitle=L"指定要处理的文件夹";
 后在窗口内显示提示用户的语句：

加上语句bi.lpszTitle=L"指定要处理的文件夹";
 后在窗口内显示提示用户的语句：

加上语句bi.lpszTitle=L"指定要处理的文件夹";
 后在窗口内显示提示用户的语句：

加上语句bi.lpszTitle=L"指定要处理的文件夹";
 后在窗口内显示提示用户的语句：








easysize.h自行在CSDN下载频道进行下载。
步骤一：把easysize.h拷贝到CMyDlg项目文件夹中，同时在CMyDlg的.h文件和.cpp文件中加入#include "easysize.h"；
步骤二：在CMyDlg类的h文件中，加入DECLARE_EASYSIZE，注意结尾处不要加“；”。
步骤三：在CMyDlg类的OnInitDialog()函数的结尾处加入INIT_EASYSIZE, 注意此处结尾处要加“；”。
步骤四：增加WM_SIZE消息响应函数OnSize()，在函数中加入UPDATE_EASYSIZE，注意此处结尾处要加“；”。
步骤五：在CMyDlg的cpp文件中添加EASYSIZE 的宏映射
EASYSIZE(control,left,top,right,bottom,options)
Control---控件的ID，需要设置的控件
left top right bottom---矩形框的位置，可以设置的参数：ES_BORDER、ES_KEEPSIZE、其他control的ID。
        ES_BORDER代表控件与边框的距离保持不变
        ES_KEEPSIZE代表控件的宽度和高度保持不变，left/right只能设置其中一个为ES_KEEPSIZE,top/bottom亦然。
Control  ID代表以另一个空间为参照
        具体注释如下，待设置控件记为ID1，参照控件记为ID2
        i left=ID2  ID1左边到ID2右边的距离保持不变（不管ID2如何变化）
        ii right=ID2 ID1右边到ID2左边的距离保持不变（不管ID2如何变化）
iii top=ID2  ID1上边到ID2下边的距离保持不变（不管ID2如何变化）
iv bottom=ID2 ID1下边到ID2上边的距离保持不变（不管ID2如何变化）
options---特别操作ES_HCENTER, ES_VCENTER and 0的结合。
0代表没有任何操作；
ES_HCENTER代表控件在left/right之间水平居中，此时left/right都不能设置成ES_KEEPSIZE，控件的宽度保持不变；
ES_VCENTER同理ES_HCENTER
注意： 布局风格的设置将很大程序影响控件在对话框上的布局，不同设置布局会有天壤之别！！！！


由于有这个需求，就是当在对话框设置一些数值的时候，可以在对话框上预览三维图像。
（1）生成一个基于对话框的程序，或者直接在单文档或者多文档上插入一个对话框，生成一个新的对话框类CGridingDlg,名字可以任取。
（2）配置好工程的OpenGL环境，不知道可以百度。
（3）在CGridingDlg的头文件中添加以下变量:
CGridingDlg的头文件中添加以下变量:






(4)重载对话框类CGridingDlg的虚函数OnInitDialog(),添加WM_TIMER消息，
(4)重载对话框类CGridingDlg的虚函数OnInitDialog(),添加WM_TIMER消息，
CGridingDlg的虚函数OnInitDialog(),添加WM_TIMER消息，
添加函数SetupPixelFormat(HDC hDC)---->用于设置OpenGL的像素格式
添加函数SetupPixelFormat(HDC hDC)---->用于设置OpenGL的像素格式
添加函数SetupPixelFormat(HDC hDC)---->用于设置OpenGL的像素格式



在对话框上面添加一个Picture控件，用于显示图形，设置其ID为IDC_STATIC_PictureRender
在对话框上面添加一个Picture控件，用于显示图形，设置其ID为IDC_STATIC_PictureRender
在对话框上面添加一个Picture控件，用于显示图形，设置其ID为IDC_STATIC_PictureRender






添加InitializeOpenGL()函数用于在对话框中初始化OpenGL。
添加InitializeOpenGL()函数用于在对话框中初始化OpenGL。
添加InitializeOpenGL()函数用于在对话框中初始化OpenGL。















RenderScene()函数添加进去，每隔多少毫秒就调用RenderScene()，时间间隔设置的越少就可以形成连续绘制的效果
RenderScene()，时间间隔设置的越少就可以形成连续绘制的效果






RenderScene()函数中封装一个函数，将该函数放置于RenderScene()函数的绘图代码区就好了。
RenderScene()函数的绘图代码区就好了。
绘制的效果如下
绘制的效果如下
绘制的效果如下
绘制的效果如下
绘制的效果如下




















但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
但是上面中的模型并不能进行交互操作，所以须在CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。
CGridingDlg该类中添加鼠标左键，鼠标中键以及鼠标滑轮的消息响应函数，但先需要在该类的构造函数中初始化控制变量。


























































































问题描述：判断一个数是不是回文数。
回文数：就是从左往右念和从右往左念都是一样的，对称的一个数，如121,789987等。
注意：负数不是回文数，如-121。
解题思路一：如果一个数倒序输出后还等于原始的值，那么该数为回文数。
解题思路2：如果一个数最左边的数等于最右边的数，然后再去除这两个数，然后再判断最左边的数依然等于最右边的数，直到最后一个数，那么该数为回文数。


在leetcode里面提交的结果是第一种方法貌似比第二种要快。
配置步骤
1.在pycharm编译其中按上一篇文章简单粗暴：使用pycharm安装对应的Python版本第三方包，在包的搜索窗口输入Selenium，然后点击Install Package即可。




2.下载最新版本的Chrome浏览器安装


3.下载最新版本ChromeDrive.exe
可进入以下网址进行下载
http://chromedriver.storage.googleapis.com/index.html

下载下来为一个压缩包文件，解压缩，得到chromedrive.exe
chromedrive.exe


4.将下载的最新版本的chromedrive.exe拷贝到你的python3.x的安装目录，或者是C:Windows目录下
整个Selenium+Chrome的环境配置就完成了
我的python3.x安装路劲为：C:\Users\Administrator\AppData\Local\Programs\Python\Python35\




到这里整个Selenium+Chrome环境配置就完成了，快使用下列代码打开你的浏览器吧

5.上面代码每次都会打开一次Chrome浏览器，但是假如我们循环次数较多时，每次都打开一次浏览器会干扰我们在桌面上的其他工作，所以这里介绍一个无界面的浏览器包PhantomJS
首先在官网下载地址：http://phantomjs.org/download.html
或者CSDN下载频道以往版本：http://download.csdn.net/detail/tylanbin/7211747
然后得到压缩包，解压，将里面的PhantomJS.exe文件复制到你的python安装路径或者C:windows下，只要是系统的环境path目录都行
PhantomJS.exe文件复制到你的python安装路径或者C:windows下，只要是系统的环境path目录都行
然后只需要把上面driver=webdriver.Chrome()改成driver=webdriver.PhantomJS()即可


driver=webdriver.PhantomJS()即可
PhantomJS


最近在项目中有一种结构体数据需要存储，数据结构体如下

现在需要根据在m_Vector中的每一个结构体的ID来获得其对应的pinwei值，所以就写了一个函数，如下
然后上程序上面测试，对于一个size大约15000的容器，大概每次循环需要进行20次FindpinweiValueInVector（）函数的调用，所以在Vector中查找值的最坏的情况是时间复杂度为O(n),即进行15000*20，这还是每次的循环，当一个菜单执行完毕整整花了大概6个半小时左右，程序运行效率低下。


所以，必须要有一种查找效率较高的容器，就想到的map,map为平衡二叉树，查找效率为对数级别，时间复杂度为O(logN)，查找相对来说较快，1000大小的数据最坏只需要3次就可以查找到，15000只需要4次多就可以查找到。
所以声明一个map<int,double>型的容器，用于建立mystruct的ID与pinwei之间的对应关系，然后将Vector存储的值插入到map中，然后在map中根据键值（ID）查找Value(pinwei)。
函数如下



总结：以前在项目中用惯了STL的Vector，因为其比数组来的方便，不需要定义数组长度，可以不断的pushback(),但是其在大数据量中的查找效率简直令人发指，所以以后在什么时候得根据特定的情况使用特定的容器，不要习惯性的使用Vector。
后来又测试了下，用hash_map更快。


1.OpenMP介绍
OpenMP 是 Open MultiProcessing 的缩写，用于共享内存并行系统的多处理器程序设计的一套指导性编译处理方案。在项目程序已经完成好的情况下不需要大幅度的修改源代码，只需要加上专用的pragma来指明自己的意图，由此编译器可以自动将程序进行并行化，并在必要之处加入同步互斥以及通信。当选择忽略这些pragma，或者编译器不支持OpenMp时，程序又可退化为通常的程序(一般为串行)，代码仍然可以正常运作，只是不能利用多线程来加速程序执行。OpenMP提供的这种对于并行描述的高层抽象降低了并行编程的难度和复杂度，这样程序员可以把更多的精力投入到并行算法本身，而非其具体实现细节。对基于数据分集的多线程程序设计，OpenMP是一个很好的选择。



2.VS2010中开启OpenMP
右键项目属性-配置属性-C/C++-语言-OpenMP支持-点击是。






3. OpenMP并行化测试
在已有源代码的基础上，要对此段代码进行并行化处理，只需要使用

程序结果




当我们修改为8个线程的时候，其结果为




可以看出4个线程和8个线程都执行了cout << "Thread  " << omp_get_thread_num() << endl; //omp_get_thread_num()是获取当前线程id号这句代码，而且先后顺序没有特定的从线程1到线程2执行，可以看出简单的实现了并行块的设计。


下面以一个较大的for循环来测试OpenMP并行程序与普通串行程序的速度问题。
需要对for程序代码段执行并行化需要添加#pragma omp parallel for
串行化程序：





并行化程序：










1.error c3861:"_T:找不到标识符"
2.error C2664: “CreateFileW”: 不能将参数 1 从“const char [19]”转换为“LPCWSTR”
3.error C3861: “setprecision”: 找不到标识符
4. error C2501: 'vector' : missing storage-class or type specifiers
5.VS2010提示资源已在另一编辑器中打开
6.VS中出现error C2665:“AfxMessageBox”:
 2 个重载中没有一个可以转换所有参数类型
选择“项目”菜单->项目属性->配置属性->常规->字符集，改为“未设置”即可。
7.
无法解析的外部符号"public:__thiscall cv::SURF::SURF(void)" (??0SURF@cv@@QAE@XZ)，该符号在函数main 中被引用
无法解析的外部符号"public:__thiscall cv::SURF::SURF(double,int,int,bool,bool)"(??0SURF@cv@@QAE@NHH_N0@Z)，该符号在函数main
 中被引用
解决方法：
（1）添加#include"opencv2/nonfree/features2d.hpp"头文件
（2）用VS2010的话就在通用属性->连接器->输入->附加依赖项里边添加上库文件opencv_nonfree249d.lib这里最后的249具体可能根据你的版本变化，为你当前opencv版本，d字母表示debug，也可去掉，表示Release。


8.error
 RC2170: bitmap file res\XXX.bmp is not in 3.00 format

9.
去除VS2010对汉字的拼写检查后留下的红色波浪线
VAssistX菜单栏->Visual Assist X Options->Underlines->把underlines spelling errors in comments and strings using前面的勾去掉就行


10.

在程序开发中我们经常看见有一些软件左侧有目录树或者是图层树，点击之后就可以右侧View窗口显示相关的内容，其实实现这种机制有两种方法，第一种就是对MFC的View窗口进行窗口分割，左侧的窗口view类派生于CTreeView，其中CTreeView自带一个变量用于View中的树控件的控制。第二种方法就是用一个可停靠的面板嵌套一个对话框，再在对话框中添加树控件，同样可以达到相同的目的。
以下详解搭建步骤：
第一步：在VS2010中生成一个MFC经典风格的单文档程序，命名为CMyTestMFCDlg，编译下保证没有出错。

第二步：为该工程添加一个新类CMyDockablePane，派生于CDockablePane。



第三步：新建上述类完成后，在CMainFrame头文件中包含该类的头文件#include
 "MyDockablePane.h"
   声明该类的对象：



编译运行：


第四步：插入一个新的对话框，命名为IDD_DIALOG_DOCKDIALOG，在对话框属性中将Style设为Child，Border设为None。
为该对话框新建类：CDockDialog，基类为CDialogEx。
添加一个树控件，IDC_TREE_Test，为树控件关联一个控件变量m_TreeControl
在MyDockablePane.h中包含头文件#include
 "DockDialog.h"
添加CDockDialog
 类的成员变量：CDockDialog m_TestDlg;
添加CMyDockablePane的WM_CREATE和WM_SIZE消息响应函数
在函数中添加以下代码

CDockDialog类中重载虚函数OnInitDialog()，添加以下代码初始化树控件

CDockDialog头文件中添加#include "resource.h"




最后即可编译成功
最后即可编译成功





